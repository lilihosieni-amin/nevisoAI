-- MySQL dump 10.13  Distrib 8.0.43, for Linux (x86_64)
--
-- Host: localhost    Database: neviso_db
-- ------------------------------------------------------
-- Server version	8.0.43

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!50503 SET NAMES utf8mb4 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `activity_logs`
--

DROP TABLE IF EXISTS `activity_logs`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `activity_logs` (
  `id` bigint unsigned NOT NULL AUTO_INCREMENT,
  `user_id` int unsigned DEFAULT NULL,
  `action_type` varchar(50) COLLATE utf8mb4_unicode_ci NOT NULL,
  `details` json DEFAULT NULL,
  `ip_address` varchar(45) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `user_agent` text COLLATE utf8mb4_unicode_ci,
  `created_at` timestamp NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  KEY `idx_user_action` (`user_id`,`action_type`,`created_at`),
  CONSTRAINT `activity_logs_ibfk_1` FOREIGN KEY (`user_id`) REFERENCES `users` (`id`) ON DELETE SET NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `activity_logs`
--

LOCK TABLES `activity_logs` WRITE;
/*!40000 ALTER TABLE `activity_logs` DISABLE KEYS */;
/*!40000 ALTER TABLE `activity_logs` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `alembic_version`
--

DROP TABLE IF EXISTS `alembic_version`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `alembic_version` (
  `version_num` varchar(32) NOT NULL,
  PRIMARY KEY (`version_num`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `alembic_version`
--

LOCK TABLES `alembic_version` WRITE;
/*!40000 ALTER TABLE `alembic_version` DISABLE KEYS */;
INSERT INTO `alembic_version` VALUES ('004_add_is_active_field');
/*!40000 ALTER TABLE `alembic_version` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `chat_messages`
--

DROP TABLE IF EXISTS `chat_messages`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `chat_messages` (
  `id` int unsigned NOT NULL AUTO_INCREMENT,
  `session_id` int unsigned NOT NULL,
  `role` varchar(20) COLLATE utf8mb4_unicode_ci NOT NULL,
  `content` text COLLATE utf8mb4_unicode_ci NOT NULL,
  `created_at` timestamp NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  KEY `session_id` (`session_id`),
  CONSTRAINT `chat_messages_ibfk_1` FOREIGN KEY (`session_id`) REFERENCES `chat_sessions` (`id`) ON DELETE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=82 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `chat_messages`
--

LOCK TABLES `chat_messages` WRITE;
/*!40000 ALTER TABLE `chat_messages` DISABLE KEYS */;
INSERT INTO `chat_messages` VALUES (10,2,'user','انواع حافظه رو برام توضیح میدی','2025-12-01 21:33:34'),(11,2,'model','حافظه به دو بخش اصلی تقسیم می‌شود:\n\n*   **Stack (پشته):**\n    *   استاتیک است.\n    *   برای متغیرهای محلی (local variables) و فراخوانی توابع (function calls) استفاده می‌شود.\n    *   داده‌هایی که به آن وارد می‌شوند، ماندگاری کمتری دارند.\n    *   سریع‌تر است.\n*   **Heap:**\n    *   ماندگاری اطلاعات بیشتری دارد.\n    *   کندتر است.\n    *   توسط Garbage Collector (GC) مدیریت می‌شود (در زبان‌هایی مانند C# و Java).\n    *   مقدار حافظه‌ای که در آن ذخیره می‌شود، بیشتر است.\n    *   اشیاء را به صورت \'باکس\' ذخیره می‌کند. آدرس شیء در Heap ذخیره می‌شود و یک رفرنس به آن آدرس در Stack قرار می‌گیرد.','2025-12-01 21:33:36'),(48,1,'user','از جزوه ازم سوال بپرس','2025-12-01 21:50:06'),(49,1,'model','بسیار خوب! سوال من از جزوه این است:\n\nهدف اصلی دیتاست Bank Marketing چیست و چند ویژگی دارد؟ همچنین، چند نمونه از ویژگی‌های آن را نام ببرید.','2025-12-01 21:50:22'),(50,1,'user','داشتن دیتاهای زیاد','2025-12-01 21:50:32'),(51,1,'model','از اینکه پاسخ دادی ممنونم. اما سؤالی که من پرسیدم (درباره دیتاست Bank Marketing) در محتوای جزوه ارائه شده وجود ندارد و من نباید از مطالبی خارج از جزوه سؤال بپرسم. از این بابت پوزش می‌طلبم.\n\nحالا، سؤالی جدید و مطابق با محتوای جزوه از شما می‌پرسم:\n\nچه تفاوت‌هایی بین نمایش داده‌های گراف به صورت \"لیست همسایگی\" و \"ماتریس همسایگی\" وجود دارد، به ویژه در مورد داده‌های پراکنده و شبکه‌های بزرگ؟ و نگهداری کدام یک آسان‌تر است؟','2025-12-01 21:50:38'),(52,1,'user','لیست همسایگی بهتره. چون ماترسی خیلی فضای زیادی از ما میگیرن','2025-12-01 21:51:22'),(53,1,'model','پاسخ شما تا حدودی درست است.\nبله، یکی از دلایل اصلی برتری لیست همسایگی در شبکه‌های بزرگ و داده‌های پراکنده (sparse) این است که ماتریس همسایگی فضای ذخیره‌سازی بسیار زیادی اشغال می‌کند (پرمصرف و wasteful است). در مواردی مانند شبکه‌های اجتماعی با میلیاردها کاربر، ماتریس همسایگی بسیار بزرگ می‌شود و لیست همسایگی مناسب‌تر است.\n\nاما در مورد نگهداری، جزوه بیان می‌کند که نگهداری لیست همسایگی \"آسان نیست\" و تغییرات و نگهداری آن نیاز به پشتیبانی دارد. همچنین، در ماتریس همسایگی، سرعت دسترسی (مثلاً از گره ۱ به گره ۴) راحت‌تر است و برای ماتریس‌های متراکم (dense) که تعداد صفرها زیاد نیست، ماتریس همسایگی بهتر عمل می‌کند.\n\nپس به طور خلاصه:\n*   **لیست همسایگی:** برای **داده‌های پراکنده** و **شبکه‌های بسیار بزرگ** مناسب‌تر است زیرا در فضای ذخیره‌سازی صرفه‌جویی می‌کند. اما نگهداری آن **آسان نیست**.\n*   **ماتریس همسایگی:** برای **داده‌های متراکم** (که تعداد صفرها زیاد نیست) بهتر است. سرعت دسترسی در آن راحت‌تر است، اما برای داده‌های پراکنده و شبکه‌های بزرگ، از نظر فضا **پرمصرف** است.','2025-12-01 21:51:29'),(54,2,'user','شی گرایی چچند جز دارد','2025-12-02 08:40:51'),(55,2,'user','شی گرایی چچند جز دارد','2025-12-02 08:46:56'),(56,3,'user','هوش چیه','2025-12-02 08:57:34'),(57,3,'model','بر اساس محتوای ارائه شده از جزوات، تعریفی مستقیم از \"هوش\" وجود ندارد. محتوا بیشتر بر مفاهیم \"هوش مصنوعی\" و \"هوش مصنوعی مولد\" تمرکز دارد.','2025-12-02 08:57:47'),(60,4,'user','وراثت چیست','2025-12-02 20:10:15'),(61,4,'model','این مورد در جزوه ذکر نشده است، اما پاسخ صحیح این است که:\n\nوراثت (Inheritance) یکی از چهار ستون اصلی برنامه‌نویسی شی‌گرا (OOP) است که به یک کلاس امکان می‌دهد ویژگی‌ها (فیلدها) و رفتارها (متدها)ی کلاس دیگری را به ارث ببرد.\n\nبه عبارت دیگر:\n*   **کلاس والد (Parent Class / Superclass):** کلاسی که ویژگی‌ها و رفتارهای خود را به کلاس‌های دیگر منتقل می‌کند.\n*   **کلاس فرزند (Child Class / Subclass):** کلاسی که از کلاس والد ارث‌بری می‌کند و به تمام ویژگی‌ها و رفتارهای عمومی (public و protected) والد خود دسترسی پیدا می‌کند، علاوه بر اینکه می‌تواند ویژگی‌ها و رفتارهای جدیدی را به خود اضافه کند یا رفتارهای والد را بازنویسی (Override) کند.\n\nهدف اصلی وراثت، استفاده مجدد از کد (Code Reusability)، ایجاد سلسله‌مراتب منطقی بین کلاس‌ها و پشتیبانی از چندریختی (Polymorphism) است.','2025-12-02 20:10:29'),(62,4,'user','OOP چی بود؟','2025-12-02 20:10:52'),(63,4,'model','این مورد در جزوه ذکر نشده است، اما پاسخ صحیح این است که:\n\nOOP مخفف عبارت **Object-Oriented Programming** به معنای **برنامه‌نویسی شی‌گرا** است.\n\nبرنامه‌نویسی شی‌گرا یک پارادایم برنامه‌نویسی است که حول مفهوم \"اشیاء\" سازماندهی شده است. این اشیاء ترکیبی از داده‌ها (معروف به فیلدها یا ویژگی‌ها) و کدی هستند که روی آن داده‌ها عمل می‌کنند (معروف به متدها یا رفتارها).\n\nاصول اصلی OOP عبارتند از:\n*   **Encapsulation (کپسوله‌سازی):** بسته‌بندی داده‌ها و متدها در یک واحد واحد (شیء) و پنهان کردن جزئیات پیاده‌سازی از دنیای بیرون.\n*   **Inheritance (وراثت):** توانایی یک کلاس (فرزند) برای به ارث بردن ویژگی‌ها و رفتارهای کلاس دیگر (والد) به منظور استفاده مجدد از کد و ایجاد سلسله‌مراتب.\n*   **Polymorphism (چندریختی):** توانایی اشیاء برای گرفتن اشکال مختلف یا نمایش رفتار متفاوت در شرایط مختلف. به این معنی که یک نام می‌تواند برای انجام اعمال مرتبط استفاده شود، اما به روش‌های مختلف.\n*   **Abstraction (تجرید):** نمایش فقط اطلاعات ضروری و پنهان کردن جزئیات پیاده‌سازی پیچیده. تمرکز بر \"چه کاری\" انجام می‌شود به جای \"چگونه\" انجام می‌شود.\n\nهدف OOP، طراحی برنامه‌هایی است که قابل نگهداری‌تر، مقیاس‌پذیرتر و قابل استفاده مجدد باشند.','2025-12-02 20:10:59'),(64,4,'user','(Default Constructor) چجوری باید تعریف کنم؟','2025-12-02 20:11:20'),(65,4,'model','طبق محتوای جزوه، سازنده پیش‌فرض (Default Constructor) به صورت خودکار توسط کامپایلر ایجاد می‌شود و شما نیازی به تعریف صریح آن ندارید، مگر اینکه شرایط خاصی وجود داشته باشد:\n\n*   **اگر شما هیچ سازنده‌ای در کلاس خود تعریف نکنید:**\n    *   کامپایلر به صورت خودکار یک سازنده پیش‌فرض بدون پارامتر برای کلاس شما ایجاد می‌کند.\n    *   این سازنده:\n        *   بدون پارامتر است.\n        *   هم‌نام با کلاس خودش است.\n        *   محتوای داخلی آن خالی است (هیچ کاری انجام نمی‌دهد).\n\n*   **اگر شما حداقل یک سازنده صریح (با یا بدون پارامتر) در کلاس خود تعریف کنید:**\n    *   در این حالت، کامپایلر دیگر سازنده پیش‌فرض بدون پارامتر را به صورت خودکار ایجاد نمی‌کند.\n    *   اگر در چنین شرایطی، به یک سازنده بدون پارامتر نیاز دارید (که رفتاری شبیه به سازنده پیش‌فرض داشته باشد)، باید آن را به صورت صریح و به شکل زیر تعریف کنید:\n\n    ```java\n    class MyClass {\n        public MyClass() {\n            // محتوای این سازنده می‌تواند خالی باشد یا کارهای اولیه را انجام دهد.\n            // به عنوان مثال: System.out.println(\"سازنده پیش‌فرض فراخوانی شد.\");\n        }\n        // ... سایر سازنده‌ها یا متدها ...\n    }\n    ```\n\nخلاصه اینکه، برای داشتن یک سازنده پیش‌فرض، یا هیچ سازنده‌ای تعریف نکنید تا کامپایلر آن را بسازد، یا اگر سازنده‌های دیگری دارید، خودتان یک سازنده بدون پارامتر (با نام کلاس و بدون آرگومان) بنویسید.','2025-12-02 20:11:28'),(66,4,'user','(Default Constructor)','2025-12-02 20:21:39'),(67,4,'model','طبق محتوای جزوه، (Default Constructor) یا سازنده پیش‌فرض دارای ویژگی‌های زیر است:\n\n*   **وجود همیشگی:** هر کلاسی، حتی اگر شما هیچ سازنده‌ای برای آن تعریف نکنید، یک سازنده پیش‌فرض دارد.\n*   **بدون پارامتر:** این سازنده هیچ پارامتری دریافت نمی‌کند.\n*   **هم‌نام با کلاس:** نام آن دقیقاً هم‌نام با کلاس خودش است.\n*   **محتوای خالی:** محتوای داخلی آن خالی است و هیچ کاری انجام نمی‌دهد.\n*   **فراخوانی خودکار:** وقتی شما یک شیء از کلاس را بدون فراخوانی صریح سازنده ایجاد می‌کنید (مانند `new MyClass()`)، این سازنده پیش‌فرض به صورت خودکار در زمان اجرا فراخوانی می‌شود، حتی اگر خالی باشد.\n*   **قانون ایجاد توسط کامپایلر:**\n    *   اگر کلاسی هیچ سازنده‌ای نداشته باشد، کامپایلر یک سازنده پیش‌فرض بدون پارامتر برای آن ایجاد می‌کند.\n    *   اگر کلاسی حداقل یک سازنده صریح (با یا بدون پارامتر) داشته باشد، کامپایلر دیگر سازنده پیش‌فرض بدون پارامتر را به صورت خودکار ایجاد نمی‌کند.','2025-12-02 20:22:00'),(68,1,'user','ماتریس همسایگی چیه؟','2025-12-02 20:30:59'),(69,1,'model','طبق محتوای جزوه، ماتریس همسایگی (Adjacency Matrix) به صورت زیر تعریف می‌شود:\n\n*   **چیستی:** یک ماتریس است که برای نمایش داده‌ها در گراف‌ها استفاده می‌شود.\n*   **عناصر:** عناصر آن معمولاً ۰ یا ۱ هستند (که نشان‌دهنده وجود یا عدم وجود ارتباط بین گره‌هاست).\n*   **ویژگی‌ها:**\n    *   بسیار پراکنده (sparse) است، یعنی ممکن است عناصر آن عمدتاً صفر یا خالی باشند.\n    *   از نظر فضا پرمصرف (wasteful) است و با اتلاف حافظه زیادی همراه است.\n    *   اما از نظر مفهومی بسیار مفید و کاربردی است.\n    *   در سرعت دسترسی عملکرد بهتری دارد، زیرا می‌توان به راحتی از یک گره به گره دیگر دسترسی پیدا کرد.\n*   **کاربرد:**\n    *   در وب مپ‌ها و کاربردهایی مانند Google Maps استفاده می‌شود.\n    *   برای ماتریس‌های متراکم (dense) که تعداد صفرها زیاد نیست، بهتر است.\n*   **محدودیت:** وقتی ابعاد ماتریس بسیار بالا می‌رود (مانند شبکه‌های اجتماعی بزرگ)، حجم آن بسیار زیاد شده و محاسبات پیچیده می‌گردند و نگهداری این مدل مناسب نخواهد بود.','2025-12-02 20:31:05'),(76,5,'user','چطور مطمئن شویم کلید عمومی لزوماً متعلق به شخصی است که ادعا می‌کند؟','2025-12-03 04:34:53'),(77,5,'model','این مورد در جزوه ذکر نشده است، اما پاسخ صحیح این است که:\n\nبرای اطمینان از اینکه کلید عمومی لزوماً متعلق به شخصی است که ادعا می‌کند، از ساختاری به نام زیرساخت کلید عمومی (Public Key Infrastructure - PKI) و گواهی‌های دیجیتال (Digital Certificates) استفاده می‌شود:\n\n*   **گواهی‌های دیجیتال:** این گواهی‌ها اسنادی الکترونیکی هستند که یک کلید عمومی را به هویت یک فرد یا سازمان مشخص (مثلاً نام، آدرس ایمیل، نام شرکت و...) پیوند می‌دهند.\n*   **مراجع صدور گواهی (Certificate Authorities - CAs):** این مراجع، سازمان‌های معتمدی هستند که هویت افراد را تأیید کرده و سپس گواهی‌های دیجیتال را صادر و امضا می‌کنند. وقتی شما یک کلید عمومی را دریافت می‌کنید، می‌توانید امضای CA روی گواهی را بررسی کنید تا مطمئن شوید که یک مرجع معتبر، هویت مالک کلید را تأیید کرده است.\n*   **زنجیره اعتماد:** مرورگرها و سیستم‌عامل‌ها لیستی از CAs معتبر را به صورت پیش‌فرض دارند. این به شما امکان می‌دهد تا اعتبار یک گواهی را از طریق زنجیره‌ای از اعتماد (از گواهی CA ریشه تا گواهی مربوط به کلید عمومی مورد نظر) تأیید کنید.\n\nبه این ترتیب، اگر گواهی دیجیتال مربوط به یک کلید عمومی توسط یک CA معتبر امضا شده باشد، می‌توان با اطمینان بیشتری گفت که کلید عمومی واقعاً متعلق به شخصی است که ادعا می‌کند و خطر حملاتی مانند Man-in-the-Middle کاهش می‌یابد.','2025-12-03 04:35:10'),(78,5,'user','یه مثال از سناریوی حمله Man-in-the-Middle','2025-12-03 04:35:59'),(79,5,'model','طبق محتوای جزوه، یک مثال از سناریوی حمله Man-in-the-Middle به شرح زیر است:\n\n*   **سناریو:** فردی به نام آیدین می‌خواهد به پیام‌های ارسالی برای بردیار دسترسی پیدا کند.\n*   **جعل هویت:** آیدین خودش را جای بردیار جا می‌زند.\n*   **توزیع کلید:** آیدین کلید عمومی *خودش* را به شما (فرستنده پیام) می‌دهد، در حالی که شما فکر می‌کنید این کلید عمومی متعلق به بردیار است.\n*   **رمزنگاری اشتباه:** شما پیام خود را با استفاده از کلید عمومی *آیدین* (که فکر می‌کنید کلید عمومی بردیار است) رمز می‌کنید.\n*   **دسترسی به پیام:** آیدین به راحتی می‌تواند پیام رمز شده را با کلید خصوصی خودش باز کند و به محتوای پیام شما دسترسی پیدا کند.\n\nاین حمله نشان می‌دهد که مشکل در این است که چطور مطمئن شویم کلید عمومی لزوماً متعلق به شخصی است که ادعا می‌کند.','2025-12-03 04:36:03'),(80,1,'user','ماتریس چیست','2025-12-07 16:02:09'),(81,1,'model','این مورد در جزوه ذکر نشده است، اما پاسخ صحیح این است که:\n\nماتریس (Matrix) به طور کلی، یک آرایه مستطیلی از اعداد، نمادها یا عبارات است که در سطرها و ستون‌ها سازماندهی شده‌اند. ماتریس‌ها ابزاری بنیادی در ریاضیات هستند و کاربردهای گسترده‌ای در علوم کامپیوتر، فیزیک، مهندسی و سایر رشته‌ها دارند.\n\nویژگی‌های اصلی ماتریس‌ها عبارتند از:\n*   **بعد (Dimension):** یک ماتریس با تعداد سطرها و ستون‌هایش مشخص می‌شود (مثلاً ماتریس m×n دارای m سطر و n ستون است).\n*   **عناصر (Elements):** هر مقدار یا ورودی در ماتریس یک عنصر نامیده می‌شود.\n*   **کاربردها:** برای نمایش داده‌ها، حل سیستم‌های معادلات خطی، تبدیل‌های خطی و بسیاری محاسبات دیگر به کار می‌روند.','2025-12-07 16:02:48');
/*!40000 ALTER TABLE `chat_messages` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `chat_sessions`
--

DROP TABLE IF EXISTS `chat_sessions`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `chat_sessions` (
  `id` int unsigned NOT NULL AUTO_INCREMENT,
  `notebook_id` int unsigned NOT NULL,
  `user_id` int unsigned NOT NULL,
  `created_at` timestamp NULL DEFAULT CURRENT_TIMESTAMP,
  `updated_at` timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  UNIQUE KEY `notebook_id` (`notebook_id`),
  KEY `user_id` (`user_id`),
  CONSTRAINT `chat_sessions_ibfk_1` FOREIGN KEY (`notebook_id`) REFERENCES `notebooks` (`id`) ON DELETE CASCADE,
  CONSTRAINT `chat_sessions_ibfk_2` FOREIGN KEY (`user_id`) REFERENCES `users` (`id`) ON DELETE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `chat_sessions`
--

LOCK TABLES `chat_sessions` WRITE;
/*!40000 ALTER TABLE `chat_sessions` DISABLE KEYS */;
INSERT INTO `chat_sessions` VALUES (1,7,1,'2025-12-01 21:29:31','2025-12-01 21:29:31'),(2,1,1,'2025-12-01 21:33:34','2025-12-01 21:33:34'),(3,4,1,'2025-12-01 21:35:32','2025-12-01 21:35:32'),(4,6,1,'2025-12-02 20:01:32','2025-12-02 20:01:32'),(5,5,1,'2025-12-02 20:37:59','2025-12-02 20:37:59');
/*!40000 ALTER TABLE `chat_sessions` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `credit_transactions`
--

DROP TABLE IF EXISTS `credit_transactions`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `credit_transactions` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `user_id` int unsigned NOT NULL,
  `subscription_id` int unsigned DEFAULT NULL,
  `note_id` int unsigned DEFAULT NULL,
  `transaction_type` enum('deduct','refund','purchase','bonus') COLLATE utf8mb4_unicode_ci NOT NULL,
  `amount` decimal(10,2) NOT NULL COMMENT 'Amount in minutes',
  `balance_before` decimal(10,2) NOT NULL,
  `balance_after` decimal(10,2) NOT NULL,
  `description` varchar(500) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `created_at` timestamp NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  KEY `idx_user_created` (`user_id`,`created_at`),
  KEY `idx_note` (`note_id`),
  KEY `idx_subscription` (`subscription_id`),
  KEY `idx_type` (`transaction_type`),
  CONSTRAINT `credit_transactions_ibfk_1` FOREIGN KEY (`user_id`) REFERENCES `users` (`id`) ON DELETE CASCADE,
  CONSTRAINT `credit_transactions_ibfk_2` FOREIGN KEY (`subscription_id`) REFERENCES `user_subscriptions` (`id`) ON DELETE SET NULL,
  CONSTRAINT `credit_transactions_ibfk_3` FOREIGN KEY (`note_id`) REFERENCES `notes` (`id`) ON DELETE SET NULL
) ENGINE=InnoDB AUTO_INCREMENT=46 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='Log of all credit transactions';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `credit_transactions`
--

LOCK TABLES `credit_transactions` WRITE;
/*!40000 ALTER TABLE `credit_transactions` DISABLE KEYS */;
INSERT INTO `credit_transactions` VALUES (1,1,5,43,'deduct',34.54,900.00,865.46,'پردازش یادداشت: _⁨هوش ۵⁩','2025-11-09 06:30:35'),(2,1,5,44,'deduct',36.64,865.00,828.36,'پردازش یادداشت: _⁨هوش مصنوعی ۲⁩','2025-11-09 06:38:15'),(3,1,12,50,'deduct',66.19,350.00,283.81,'پردازش یادداشت: _⁨هوش مصنوعی⁩','2025-11-09 07:00:48'),(4,1,12,51,'deduct',10.98,284.00,273.02,'پردازش یادداشت: _⁨سیار۲۷-۴⁩','2025-11-09 07:28:35'),(5,1,12,52,'deduct',34.54,273.00,238.46,'پردازش یادداشت: _⁨هوش ۵⁩','2025-11-09 07:30:45'),(6,1,5,53,'deduct',34.54,238.00,203.46,'پردازش یادداشت: _⁨هوش ۵⁩','2025-11-09 08:13:21'),(7,1,5,54,'deduct',15.00,203.00,188.00,'پردازش یادداشت: _⁨سیار ۱۱⁩','2025-11-09 08:20:53'),(8,1,12,54,'deduct',20.46,188.00,167.54,'پردازش یادداشت: _⁨سیار ۱۱⁩','2025-11-09 08:20:53'),(9,1,12,55,'deduct',2.58,168.00,165.42,'پردازش یادداشت: _Khone Barat Ridan','2025-11-15 15:20:29'),(10,1,12,55,'refund',2.58,165.00,167.58,'بازگشت اعتبار به دلیل خطا: _Khone Barat Ridan','2025-11-15 15:20:30'),(11,1,12,56,'deduct',2.58,168.00,165.42,'پردازش یادداشت: _Khone Barat Ridan','2025-11-15 15:30:17'),(12,1,12,56,'refund',2.58,165.00,167.58,'بازگشت اعتبار به دلیل خطا: _Khone Barat Ridan','2025-11-15 15:30:27'),(13,1,12,57,'deduct',33.71,168.00,134.29,'پردازش یادداشت: _⁨داده کاوی⁩','2025-12-01 18:52:28'),(14,1,12,57,'refund',33.71,134.00,167.71,'بازگشت اعتبار به دلیل خطا: _⁨داده کاوی⁩','2025-12-01 18:52:29'),(15,1,12,58,'deduct',33.71,168.00,134.29,'پردازش یادداشت: _⁨داده کاوی⁩','2025-12-01 18:54:01'),(16,1,12,58,'refund',33.71,134.00,167.71,'بازگشت اعتبار به دلیل خطا: _⁨داده کاوی⁩','2025-12-01 18:54:02'),(17,1,12,59,'deduct',33.71,168.00,134.29,'پردازش یادداشت: _⁨داده کاوی⁩','2025-12-01 18:55:03'),(18,1,12,59,'refund',33.71,134.00,167.71,'بازگشت اعتبار به دلیل خطا: _⁨داده کاوی⁩','2025-12-01 18:55:09'),(19,1,12,60,'deduct',33.71,168.00,134.29,'پردازش یادداشت: _⁨داده کاوی⁩','2025-12-01 18:56:13'),(20,1,12,60,'refund',33.71,134.00,167.71,'بازگشت اعتبار به دلیل خطا: _⁨داده کاوی⁩','2025-12-01 18:56:15'),(21,1,12,61,'deduct',33.71,168.00,134.29,'پردازش یادداشت: _⁨داده کاوی⁩','2025-12-01 19:04:57'),(22,1,12,61,'refund',33.71,134.00,167.71,'بازگشت اعتبار به دلیل خطا: _⁨داده کاوی⁩','2025-12-01 19:04:59'),(23,1,12,62,'deduct',33.71,168.00,134.29,'پردازش یادداشت: _⁨داده کاوی⁩','2025-12-01 19:06:17'),(24,1,12,62,'refund',33.71,134.00,167.71,'بازگشت اعتبار به دلیل خطا: _⁨داده کاوی⁩','2025-12-01 19:06:19'),(25,1,12,63,'deduct',33.71,168.00,134.29,'پردازش یادداشت: _⁨داده کاوی⁩','2025-12-01 19:11:20'),(26,1,12,64,'deduct',33.71,134.00,100.29,'پردازش یادداشت: _⁨داده کاوی⁩','2025-12-02 08:34:25'),(27,1,12,64,'refund',33.71,100.00,133.71,'بازگشت اعتبار به دلیل خطا: _⁨داده کاوی⁩','2025-12-02 08:34:25'),(28,1,12,65,'deduct',33.71,134.00,100.29,'پردازش یادداشت: _⁨داده کاوی⁩','2025-12-02 08:35:00'),(29,1,12,65,'refund',33.71,100.00,133.71,'بازگشت اعتبار به دلیل خطا: _⁨داده کاوی⁩','2025-12-02 08:45:03'),(30,1,12,66,'deduct',33.71,134.00,100.29,'پردازش یادداشت: _⁨داده کاوی⁩','2025-12-02 08:58:08'),(31,1,12,66,'refund',33.71,100.00,133.71,'بازگشت اعتبار به دلیل خطا: _⁨داده کاوی⁩','2025-12-02 09:08:11'),(32,1,12,67,'deduct',33.71,134.00,100.29,'پردازش یادداشت: _⁨داده کاوی⁩','2025-12-02 20:00:09'),(33,1,12,67,'refund',33.71,100.00,133.71,'بازگشت اعتبار به دلیل خطا: _⁨داده کاوی⁩','2025-12-02 20:10:13'),(34,1,12,68,'deduct',34.21,134.00,99.79,'پردازش یادداشت: _⁨داده کاوی⁩','2025-12-02 20:21:18'),(37,1,12,68,'deduct',1.00,100.00,99.00,'Test deduction','2025-12-02 20:45:00'),(38,1,12,68,'refund',1.00,129.00,130.00,'Refund test deduction','2025-12-02 20:45:40'),(39,1,12,69,'deduct',33.71,130.00,96.29,'پردازش یادداشت: _⁨داده کاوی⁩','2025-12-02 20:46:27'),(40,1,12,70,'deduct',29.13,96.00,66.87,'پردازش یادداشت: _⁨امنیت ۵اذر-۱⁩','2025-12-03 04:08:48'),(41,1,12,71,'deduct',33.71,67.00,33.29,'پردازش یادداشت: _⁨داده کاوی⁩','2025-12-03 07:13:29'),(42,1,12,72,'deduct',3.00,33.00,30.00,'پردازش یادداشت: _⁨اندروید-۹اذر⁩','2025-12-06 19:19:39'),(43,1,13,72,'deduct',22.59,30.00,7.41,'پردازش یادداشت: _⁨اندروید-۹اذر⁩','2025-12-06 19:19:39'),(44,1,13,73,'deduct',7.00,307.00,300.00,'پردازش یادداشت: _⁨سیار⁩','2025-12-06 19:22:48'),(45,1,14,73,'deduct',11.08,300.00,288.92,'پردازش یادداشت: _⁨سیار⁩','2025-12-06 19:22:48');
/*!40000 ALTER TABLE `credit_transactions` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `notebooks`
--

DROP TABLE IF EXISTS `notebooks`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `notebooks` (
  `id` int unsigned NOT NULL AUTO_INCREMENT,
  `user_id` int unsigned NOT NULL,
  `title` varchar(100) COLLATE utf8mb4_unicode_ci NOT NULL,
  `created_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `updated_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  KEY `idx_user_notebook` (`user_id`,`created_at`),
  CONSTRAINT `notebooks_ibfk_1` FOREIGN KEY (`user_id`) REFERENCES `users` (`id`) ON DELETE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `notebooks`
--

LOCK TABLES `notebooks` WRITE;
/*!40000 ALTER TABLE `notebooks` DISABLE KEYS */;
INSERT INTO `notebooks` VALUES (1,1,'سیار','2025-10-10 19:52:58','2025-10-10 19:52:58'),(2,1,'IOT','2025-10-10 22:16:02','2025-10-10 22:16:02'),(4,1,'هوش مصنوعی','2025-10-13 10:23:24','2025-10-13 10:23:29'),(5,1,'امنیت','2025-11-04 08:56:39','2025-11-04 08:56:39'),(6,1,'تست','2025-11-09 07:27:17','2025-11-09 07:27:17'),(7,1,'داده کاوی','2025-12-01 18:42:28','2025-12-01 18:42:28');
/*!40000 ALTER TABLE `notebooks` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `notes`
--

DROP TABLE IF EXISTS `notes`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `notes` (
  `id` int unsigned NOT NULL AUTO_INCREMENT,
  `notebook_id` int unsigned NOT NULL,
  `user_id` int unsigned NOT NULL,
  `title` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL,
  `session_date` varchar(10) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT 'Jalali date format: YYYY/MM/DD',
  `gemini_output_text` longtext COLLATE utf8mb4_unicode_ci,
  `user_edited_text` longtext COLLATE utf8mb4_unicode_ci,
  `status` enum('processing','completed','failed') COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT 'processing',
  `created_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `updated_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  `error_message` varchar(500) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `error_detail` text COLLATE utf8mb4_unicode_ci,
  `retry_count` smallint NOT NULL DEFAULT '0',
  `last_error_at` timestamp NULL DEFAULT NULL,
  `is_active` tinyint(1) NOT NULL DEFAULT '1',
  `error_type` varchar(50) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `idx_notebook` (`notebook_id`,`created_at`),
  KEY `idx_user_note` (`user_id`,`status`),
  CONSTRAINT `notes_ibfk_1` FOREIGN KEY (`notebook_id`) REFERENCES `notebooks` (`id`) ON DELETE CASCADE,
  CONSTRAINT `notes_ibfk_2` FOREIGN KEY (`user_id`) REFERENCES `users` (`id`) ON DELETE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=74 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `notes`
--

LOCK TABLES `notes` WRITE;
/*!40000 ALTER TABLE `notes` DISABLE KEYS */;
INSERT INTO `notes` VALUES (13,1,1,'مفاهیم برنامه‌نویسی شیءگرا (OOP) و اجزای Java','1404/07/22','<div style=\"max-width: 100%; overflow-x: hidden; word-wrap: break-word; padding: 1rem; box-sizing: border-box;\"><div style=\"max-width: 100%; overflow-x: hidden; word-wrap: break-word; padding: 1rem; box-sizing: border-box;\"><h1>مقدمه‌ای بر Java و مفاهیم شیءگرایی</h1><p>این یادداشت شامل مفاهیم بنیادی جاوا و اصول برنامه‌نویسی شیءگرا (OOP) است که در طول جلسه مورد بحث قرار گرفتند. هدف اصلی، درک عمیق‌تر این مفاهیم فراتر از صرفاً پیاده‌سازی سینتکسی است.</p><h2>اجزای اساسی Java</h2><p>جاوا از سه جزء اصلی برای توسعه و اجرای برنامه‌ها استفاده می‌کند:</p><ul><li><strong>JVM (Java Virtual Machine - ماشین مجازی جاوا):</strong> این جزء مسئول اجرای کد بایت (Bytecode) جاوا است. کد بایت یک فرم میانی است که پس از کامپایل کد منبع جاوا تولید می‌شود. JVM یک محیط اجرایی مستقل از پلتفرم را فراهم می‌کند که شعار «یک بار بنویسید، همه جا اجرا کنید» جاوا را محقق می‌سازد.</li><li><strong>JRE (Java Runtime Environment - محیط زمان اجرای جاوا):</strong> این محیط شامل JVM و کتابخانه‌های لازم برای اجرای برنامه‌های جاوا است. JRE به تنهایی برای اجرای برنامه‌های از پیش کامپایل شده جاوا کافی است اما برای توسعه برنامه به آن نیاز نیست.</li><li><strong>JDK (Java Development Kit - کیت توسعه جاوا):</strong> این کیت شامل JRE و ابزارهای توسعه‌دهنده مانند کامپایلر (javac) و دیباگر است. JDK برای نوشتن، کامپایل کردن و اجرای برنامه‌های جاوا ضروری است. همانطور که در تصاویر مشاهده شد، JDK شامل JRE و JRE شامل JVM است.</li></ul><h2>چهار ستون اصلی برنامه‌نویسی شیءگرا (OOP)</h2><p>برنامه‌نویسی شیءگرا بر چهار اصل اساسی استوار است:</p><h3>۱. ارث‌بری (Inheritance)</h3><p>ارث‌بری مکانیزمی است که به یک کلاس (کلاس فرزند یا زیرکلاس) اجازه می‌دهد ویژگی‌ها و رفتارهای کلاس دیگری (کلاس والد یا بالاکلاس) را به ارث ببرد. این اصل برای <mark>استفاده مجدد از کد</mark> (Code Reusability) طراحی شده است.</p><ul><li><strong>تعریف:</strong> شما یک کلاس می‌سازید و کلاس‌های دیگر می‌توانند از آن ارث‌بری کنند. این کار با استفاده از کلمه کلیدی <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">extends</code> در جاوا انجام می‌شود. برای مثال، اگر یک کلاس <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">Vehicle</code> داشته باشیم که ویژگی‌هایی مانند <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">price</code>، <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">year</code> و متدهایی مانند <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">display</code> دارد، می‌توانیم کلاس‌های <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">BMW</code> یا <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">Motor</code> را از <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">Vehicle</code> ارث‌بری دهیم. این کلاس‌های فرزند، به طور خودکار به ویژگی‌ها و متدهای <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">Vehicle</code> دسترسی خواهند داشت و می‌توانند ویژگی‌های خاص خود (مانند <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">model</code> برای <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">BMW</code> یا <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">horsepower</code> برای <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">Motor</code>) و متدهای خود (مانند <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">info</code> یا <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">displayInfo</code>) را اضافه کنند.</li><li><strong>مفهوم رابطه \"is-a\" و \"has-a\":</strong> نکته بسیار مهمی که غالباً نادیده گرفته می‌شود، درک صحیح زمان استفاده از ارث‌بری است. ارث‌بری تنها زمانی باید استفاده شود که رابطه \"is-a\" برقرار باشد. برای مثال، \"Student is a Person\" (دانشجو یک انسان است) یک رابطه \"is-a\" است، بنابراین <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">Student</code> می‌تواند از <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">Person</code> ارث ببرد. اما \"House has a Door\" (خانه یک در دارد) یک رابطه \"has-a\" است. در این حالت، <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">Door</code> نباید از <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">House</code> ارث ببرد؛ بلکه <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">House</code> باید یک شیء از <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">Door</code> را در خود داشته باشد (Composition). نادیده گرفتن این اصل منجر به معماری نرم‌افزاری ضعیف و ناکارآمدی حافظه می‌شود.</li></ul><h3>۲. پلی‌مورفیسم (Polymorphism)</h3><p>پلی‌مورفیسم به معنای \"چندریختی\" است و به توانایی یک شیء برای نشان دادن رفتارهای مختلف در موقعیت‌های مختلف اشاره دارد. این اصل به کد شما انعطاف‌پذیری و توسعه‌پذیری می‌دهد.</p><ul><li><strong>تعریف:</strong> یک شیء واحد می‌تواند در سناریوهای گوناگون، کنش‌های متفاوتی از خود نشان دهد. به عنوان مثال، یک فرد (مانند مدرس) در محیط کلاس، در جمع دوستان یا در خانواده، رفتارهای متفاوتی دارد، در حالی که هویت اصلی او تغییر نمی‌کند. در برنامه‌نویسی، یک متغیر از نوع کلاس والد (مثلاً <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">Vehicle</code>) می‌تواند به اشیاء از انواع کلاس‌های فرزند (مانند <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">BMW</code> یا <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">Motor</code>) اشاره کند. هنگامی که متدی روی این متغیر فراخوانی می‌شود، متد اجرایی بر اساس نوع واقعی شیء در زمان اجرا (runtime) تعیین می‌شود.</li><li><strong>اهمیت در زمان اجرا:</strong> با استفاده از پلی‌مورفیسم، می‌توانیم بر اساس ورودی کاربر یا شرایط مختلف، یک شیء از نوع والد را به شیءهای مختلف فرزند تخصیص دهیم (مثلاً <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">Vehicle v = new Motor();</code> یا <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">Vehicle v = new BMW();</code>). این کار باعث می‌شود کد ما دینامیک‌تر شود و نیاز به نوشتن تعداد زیادی شرط <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">if-else</code> برای مدیریت انواع مختلف اشیاء کاهش یابد.</li></ul><h3>۳. کپسوله‌سازی (Encapsulation)</h3><p>کپسوله‌سازی به معنای بسته‌بندی داده‌ها (ویژگی‌ها) و متدهایی که روی آن داده‌ها عمل می‌کنند، در یک واحد (کلاس) است. این اصل به کنترل دسترسی و محافظت از داده‌ها کمک می‌کند.</p><ul><li><strong>تعریف:</strong> این اصل به معنای <mark>محدود کردن دسترسی</mark> به اجزای داخلی یک کلاس است. هدف این است که از تغییرات ناخواسته یا دسترسی غیرمجاز به داده‌ها جلوگیری شود. داده‌ها معمولاً به صورت <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">private</code> تعریف می‌شوند و دسترسی یا تغییر آن‌ها تنها از طریق متدهای <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">public</code> (معمولاً Getters و Setters) کلاس امکان‌پذیر است.</li><li><strong>چرا Getters و Setters؟</strong> در نگاه اول، ممکن است ایجاد فیلدهای <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">private</code> و سپس دسترسی به آن‌ها از طریق متدهای <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">public</code> (Setter برای تغییر و Getter برای خواندن) متناقض به نظر برسد. اما دلیل اصلی این کار، <mark>کنترل و اعتبارسنجی</mark> داده‌ها است. برای مثال، اگر یک فیلد <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">color</code> (رنگ) داشته باشیم، می‌توانیم در متد <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">setColor</code> منطقی را قرار دهیم که تنها به رنگ‌های خاصی مانند \"قرمز\"، \"سبز\" یا \"آبی\" اجازه تغییر دهد. این متد تضمین می‌کند که داده‌ها مطابق با قوانین تجاری (Business Rules) یا محدودیت‌های برنامه تغییر می‌کنند. مثال دیگر، اعتبارسنجی رمز عبور است که می‌توانیم در متد <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">setPassword</code> قوانین پیچیدگی رمز (حداقل طول، حروف بزرگ و کوچک، نمادها) را اعمال کنیم.</li></ul><h3>۴. انتزاع (Abstraction)</h3><p>انتزاع به معنای <mark>پنهان کردن جزئیات پیاده‌سازی</mark> و نمایش تنها اطلاعات ضروری به کاربر یا سایر توسعه‌دهندگان است. این اصل به ساده‌سازی پیچیدگی‌ها کمک می‌کند.</p><ul><li><strong>تعریف:</strong> انتزاع به معنای عدم نمایش جزئیات داخلی و پیچیده یک سیستم به خارج است. هدف آن فراهم آوردن یک رابط کاربری ساده و قابل فهم است، در حالی که پیچیدگی‌های داخلی پنهان می‌مانند. به عنوان مثال، وقتی شما دکمه‌ای را روی ماشین لباسشویی فشار می‌دهید، فقط می‌دانید که ماشین شروع به کار می‌کند، اما نیازی به دانستن جزئیات مکانیکی و الکترونیکی عملکرد داخلی آن ندارید.</li><li><strong>مقایسه با کپسوله‌سازی:</strong> کپسوله‌سازی بر <mark>کنترل دسترسی</mark> متمرکز است (چه کسی می‌تواند به چه چیزی دسترسی داشته باشد)، در حالی که انتزاع بر <mark>پنهان کردن جزئیات پیاده‌سازی</mark> تمرکز دارد (چگونه یک کار انجام می‌شود). کاربر نهایی نیازی به دانستن کد داخلی متد <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">display()</code> یک شیء <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">Vehicle</code> ندارد؛ او فقط به خروجی آن علاقه‌مند است. این پنهان‌سازی جزئیات، همان انتزاع است.</li></ul><h2>نکات متفرقه</h2><ul><li><strong>پکیج‌ها (Packages):</strong> اگر چندین کلاس در یک پکیج (پوشه منطقی) قرار داشته باشند، نیازی به <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">import</code> کردن آن‌ها نیست و مستقیماً می‌توانند یکدیگر را ببینند و از یکدیگر استفاده کنند.</li><li><strong>تنظیمات IDE:</strong> در محیط‌های توسعه مانند IDE، تنظیماتی برای مقیاس‌بندی (Scaling) رابط کاربری وجود دارد که می‌توان آن را به مقادیر مختلف (مثلاً ۱۰۰٪ یا ۱۲۵٪) تنظیم کرد تا خوانایی بهبود یابد.</li></ul><p><strong>هدف نهایی:</strong> فراتر از حفظ سینتکس و نحوه پیاده‌سازی، درک مفاهیم و \"چرایی\" وجود این اصول در برنامه‌نویسی شیءگرا برای تبدیل شدن به یک مهندس نرم‌افزار توانمند ضروری است.</p></div></div>','<h1>مقدمه‌ای بر Java و مفاهیم شیءگرایی</h1><p>این یادداشت شامل مفاهیم بنیادی جاوا و اصول برنامه‌نویسی شیءگرا (OOP) است که در طول جلسه مورد بحث قرار گرفتند. هدف اصلی، درک عمیق‌تر این مفاهیم فراتر از صرفاً پیاده‌سازی سینتکسی است.</p><h2>اجزای اساسی Java</h2><p>جاوا از سه جزء اصلی برای توسعه و اجرای برنامه‌ها استفاده می‌کند:</p><ul><li><strong>JVM (Java Virtual Machine - ماشین مجازی جاوا):</strong> این جزء مسئول اجرای کد بایت (Bytecode) جاوا است. کد بایت یک فرم میانی است که پس از کامپایل کد منبع جاوا تولید می‌شود. JVM یک محیط اجرایی مستقل از پلتفرم را فراهم می‌کند که شعار «یک بار بنویسید، همه جا اجرا کنید» جاوا را محقق می‌سازد.</li><li><strong>JRE (Java Runtime Environment - محیط زمان اجرای جاوا):</strong> این محیط شامل JVM و کتابخانه‌های لازم برای اجرای برنامه‌های جاوا است. JRE به تنهایی برای اجرای برنامه‌های از پیش کامپایل شده جاوا کافی است اما برای توسعه برنامه به آن نیاز نیست.</li><li><strong>JDK (Java Development Kit - کیت توسعه جاوا):</strong> این کیت شامل JRE و ابزارهای توسعه‌دهنده مانند کامپایلر (javac) و دیباگر است. JDK برای نوشتن، کامپایل کردن و اجرای برنامه‌های جاوا ضروری است. همانطور که در تصاویر مشاهده شد، JDK شامل JRE و JRE شامل JVM است.</li></ul><h2>چهار ستون اصلی برنامه‌نویسی شیءگرا (OOP)</h2><p>برنامه‌نویسی شیءگرا بر چهار اصل اساسی استوار است:</p><h3>۱. ارث‌بری (Inheritance)</h3><p>ارث‌بری مکانیزمی است که به یک کلاس (کلاس فرزند یا زیرکلاس) اجازه می‌دهد ویژگی‌ها و رفتارهای کلاس دیگری (کلاس والد یا بالاکلاس) را به ارث ببرد. این اصل برای  (Code Reusability) طراحی شده است.</p><ul><li><strong>تعریف:</strong> شما یک کلاس می‌سازید و کلاس‌های دیگر می‌توانند از آن ارث‌بری کنند. این کار با استفاده از کلمه کلیدی <code>extends</code> در جاوا انجام می‌شود. برای مثال، اگر یک کلاس <code>Vehicle</code> داشته باشیم که ویژگی‌هایی مانند <code>price</code>، <code>year</code> و متدهایی مانند <code>display</code> دارد، می‌توانیم کلاس‌های <code>BMW</code> یا <code>Motor</code> را از <code>Vehicle</code> ارث‌بری دهیم. این کلاس‌های فرزند، به طور خودکار به ویژگی‌ها و متدهای <code>Vehicle</code> دسترسی خواهند داشت و می‌توانند ویژگی‌های خاص خود (مانند <code>model</code> برای <code>BMW</code> یا <code>horsepower</code> برای <code>Motor</code>) و متدهای خود (مانند <code>info</code> یا <code>displayInfo</code>) را اضافه کنند.</li><li><strong>مفهوم رابطه \"is-a\" و \"has-a\":</strong> نکته بسیار مهمی که غالباً نادیده گرفته می‌شود، درک صحیح زمان استفاده از ارث‌بری است. ارث‌بری تنها زمانی باید استفاده شود که رابطه \"is-a\" برقرار باشد. برای مثال، \"Student is a Person\" (دانشجو یک انسان است) یک رابطه \"is-a\" است، بنابراین <code>Student</code> می‌تواند از <code>Person</code> ارث ببرد. اما \"House has a Door\" (خانه یک در دارد) یک رابطه \"has-a\" است. در این حالت، <code>Door</code> نباید از <code>House</code> ارث ببرد؛ بلکه <code>House</code> باید یک شیء از <code>Door</code> را در خود داشته باشد (Composition). نادیده گرفتن این اصل منجر به معماری نرم‌افزاری ضعیف و ناکارآمدی حافظه می‌شود.</li></ul><h3>۲. پلی‌مورفیسم (Polymorphism)</h3><p>پلی‌مورفیسم به معنای \"چندریختی\" است و به توانایی یک شیء برای نشان دادن رفتارهای مختلف در موقعیت‌های مختلف اشاره دارد. این اصل به کد شما انعطاف‌پذیری و توسعه‌پذیری می‌دهد.</p><ul><li><strong>تعریف:</strong> یک شیء واحد می‌تواند در سناریوهای گوناگون، کنش‌های متفاوتی از خود نشان دهد. به عنوان مثال، یک فرد (مانند مدرس) در محیط کلاس، در جمع دوستان یا در خانواده، رفتارهای متفاوتی دارد، در حالی که هویت اصلی او تغییر نمی‌کند. در برنامه‌نویسی، یک متغیر از نوع کلاس والد (مثلاً <code>Vehicle</code>) می‌تواند به اشیاء از انواع کلاس‌های فرزند (مانند <code>BMW</code> یا <code>Motor</code>) اشاره کند. هنگامی که متدی روی این متغیر فراخوانی می‌شود، متد اجرایی بر اساس نوع واقعی شیء در زمان اجرا (runtime) تعیین می‌شود.</li><li><strong>اهمیت در زمان اجرا:</strong> با استفاده از پلی‌مورفیسم، می‌توانیم بر اساس ورودی کاربر یا شرایط مختلف، یک شیء از نوع والد را به شیءهای مختلف فرزند تخصیص دهیم (مثلاً <code>Vehicle v = new Motor();</code> یا <code>Vehicle v = new BMW();</code>). این کار باعث می‌شود کد ما دینامیک‌تر شود و نیاز به نوشتن تعداد زیادی شرط <code>if-else</code> برای مدیریت انواع مختلف اشیاء کاهش یابد.</li></ul><h3>۳. کپسوله‌سازی (Encapsulation)</h3><p>کپسوله‌سازی به معنای بسته‌بندی داده‌ها (ویژگی‌ها) و متدهایی که روی آن داده‌ها عمل می‌کنند، در یک واحد (کلاس) است. این اصل به کنترل دسترسی و محافظت از داده‌ها کمک می‌کند.</p><ul><li><strong>تعریف:</strong> این اصل به معنای  به اجزای داخلی یک کلاس است. هدف این است که از تغییرات ناخواسته یا دسترسی غیرمجاز به داده‌ها جلوگیری شود. داده‌ها معمولاً به صورت <code>private</code> تعریف می‌شوند و دسترسی یا تغییر آن‌ها تنها از طریق متدهای <code>public</code> (معمولاً Getters و Setters) کلاس امکان‌پذیر است.</li><li><strong>چرا Getters و Setters؟</strong> در نگاه اول، ممکن است ایجاد فیلدهای <code>private</code> و سپس دسترسی به آن‌ها از طریق متدهای <code>public</code> (Setter برای تغییر و Getter برای خواندن) متناقض به نظر برسد. اما دلیل اصلی این کار،  داده‌ها است. برای مثال، اگر یک فیلد <code>color</code> (رنگ) داشته باشیم، می‌توانیم در متد <code>setColor</code> منطقی را قرار دهیم که تنها به رنگ‌های خاصی مانند \"قرمز\"، \"سبز\" یا \"آبی\" اجازه تغییر دهد. این متد تضمین می‌کند که داده‌ها مطابق با قوانین تجاری (Business Rules) یا محدودیت‌های برنامه تغییر می‌کنند. مثال دیگر، اعتبارسنجی رمز عبور است که می‌توانیم در متد <code>setPassword</code> قوانین پیچیدگی رمز (حداقل طول، حروف بزرگ و کوچک، نمادها) را اعمال کنیم.</li></ul><h3>۴. انتزاع (Abstraction)</h3><p>انتزاع به معنای  و نمایش تنها اطلاعات ضروری به کاربر یا سایر توسعه‌دهندگان است. این اصل به ساده‌سازی پیچیدگی‌ها کمک می‌کند.</p><ul><li><strong>تعریف:</strong> انتزاع به معنای عدم نمایش جزئیات داخلی و پیچیده یک سیستم به خارج است. هدف آن فراهم آوردن یک رابط کاربری ساده و قابل فهم است، در حالی که پیچیدگی‌های داخلی پنهان می‌مانند. به عنوان مثال، وقتی شما دکمه‌ای را روی ماشین لباسشویی فشار می‌دهید، فقط می‌دانید که ماشین شروع به کار می‌کند، اما نیازی به دانستن جزئیات مکانیکی و الکترونیکی عملکرد داخلی آن ندارید.</li><li><strong>مقایسه با کپسوله‌سازی:</strong> کپسوله‌سازی بر  متمرکز است (چه کسی می‌تواند به چه چیزی دسترسی داشته باشد)، در حالی که انتزاع بر  تمرکز دارد (چگونه یک کار انجام می‌شود). کاربر نهایی نیازی به دانستن کد داخلی متد <code>display()</code> یک شیء <code>Vehicle</code> ندارد؛ او فقط به خروجی آن علاقه‌مند است. این پنهان‌سازی جزئیات، همان انتزاع است.</li></ul><h2>نکات متفرقه</h2><ul><li><strong>پکیج‌ها (Packages):</strong> اگر چندین کلاس در یک پکیج (پوشه منطقی) قرار داشته باشند، نیازی به <code>import</code> کردن آن‌ها نیست و مستقیماً می‌توانند یکدیگر را ببینند و از یکدیگر استفاده کنند.</li><li><strong>تنظیمات IDE:</strong> در محیط‌های توسعه مانند IDE، تنظیماتی برای مقیاس‌بندی (Scaling) رابط کاربری وجود دارد که می‌توان آن را به مقادیر مختلف (مثلاً ۱۰۰٪ یا ۱۲۵٪) تنظیم کرد تا خوانایی بهبود یابد.</li></ul><p><strong>هدف نهایی:</strong> فراتر از حفظ سینتکس و نحوه پیاده‌سازی، درک مفاهیم و \"چرایی\" وجود این اصول در برنامه‌نویسی شیءگرا برای تبدیل شدن به یک مهندس نرم‌افزار توانمند ضروری است.</p>','completed','2025-10-12 08:57:35','2025-12-06 19:31:39',NULL,NULL,0,NULL,1,NULL),(26,1,1,'مفاهیم برنامه‌نویسی شیءگرا و ابزارهای توسعه جاوا (جلسه دوم)','1404/07/24','<div style=\"max-width: 100%; overflow-x: hidden; word-wrap: break-word; padding: 1rem; box-sizing: border-box;\"><div style=\"max-width: 100%; overflow-x: hidden; word-wrap: break-word; padding: 1rem; box-sizing: border-box;\"><h1>مرور مطالب جلسه گذشته</h1><p>ابتدا مروری بر مطالب جلسه گذشته خواهیم داشت.</p><h2>مفاهیم شیءگرایی (OOP)</h2><ul><li><h3>پنهان‌سازی (Encapsulation)</h3><p>مفهوم پنهان‌سازی به این معناست که یک جعبه در نظر می‌گیریم که از اجزای مختلفی تشکیل شده است.</p></li><li><h3>تفسیر چندریختی (Polymorphism)</h3><p>تفسیر چندریختی یعنی یک شیء می‌تواند حالت‌های مختلفی از خود نشان دهد. به عنوان مثال، یک شیء از یک کلاس می‌تواند به چند شیء مختلف تبدیل شود و هر یک نیز حالت‌های متفاوتی را در کلاس‌های دیگر از خود نشان دهند. (به عنوان مثال، در یک بازی، یک بازیکن می‌تواند یک انسان، یک الف یا یک دورف باشد و هر کدام از این‌ها ویژگی‌های خاص خود را دارند).</p></li><li><h3>وراثت (Inheritance)</h3><p>وراثت به معنای این است که یک فرزند ویژگی‌های پدرش را به ارث می‌برد. برای استفاده از وراثت باید رابطه \"is a\" (هستِ) برقرار باشد. به عنوان مثال، \"انسان یک موجود است\" یا \"حیوان یک موجود است\". این نشان می‌دهد که یک کلاس فرزندی، \"یک نوع از\" کلاس والد خود است.</p></li></ul><h2>تفاوت “is a” و “has a”</h2><p>تفاوت “is a” (هستِ) و “has a” (داردِ) در این است که “is a” نشان می‌دهد که چیزی هست یا از نوع دیگری است، در حالی که “has a” نشان می‌دهد که چیزی ویژگی‌ای را دارد یا شامل چیزی است. مثلاً “خانه در دارد” (has a). هرگاه رابطه “is a” وجود داشته باشد می‌توان از وراثت استفاده کرد.</p><h2>مخفف‌های جاوا</h2><p>در جلسه گذشته سه مخفف مهم مرتبط با جاوا را بررسی کردیم:</p><ul><li><h3>JRE</h3><p>مخفف “Java Runtime Environment” است. این پلتفرم برای اجرای برنامه‌های جاوا به کار می‌رود و شامل JVM و کتابخانه‌های مورد نیاز است.</p></li><li><h3>JDK</h3><p>مخفف “Java Development Kit” است. این کیت برای توسعه‌دهندگان جاوا طراحی شده و شامل JRE به همراه ابزارهای توسعه مانند کامپایلر (javac) و دیباگر (jdb) است. بزرگترین مجموعه بین سه مورد است و توسعه‌دهندگان برای کدنویسی و کامپایل به آن نیاز دارند.</p></li><li><h3>JVM</h3><p>مخفف “Java Virtual Machine” است. این محیط مجازی وظیفه اجرای کد بایت جاوا را بر عهده دارد و بخشی از JRE است.</p></li></ul><p><strong>رابطه بین این سه:</strong> JDK شامل JRE است و JRE شامل JVM است. به عبارت دیگر، JDK (بزرگترین) برای توسعه‌دهندگان، JRE برای کاربرانی که فقط می‌خواهند برنامه اجرا کنند و JVM (کوچکترین) قلب اجرای جاوا است.</p><h2>توضیح در مورد Interface و Abstraction</h2><p>امروز می‌خواهم در مورد Interface و Abstraction توضیح بدهم و تمرینی حول این موضوعات به شما خواهم داد.</p><h3>Interface (واسط)</h3><p>یک Interface در جاوا یک ساختار بدون جزئیات است. فرض کنید من یک شرکت بزرگ نرم‌افزاری دارم و شما همه توسعه‌دهندگان آن هستید. ما یک پروژه از یک مشتری گرفته‌ایم. من به عنوان یک کارفرما یا مدیر ارشد (Senior) که تجربه زیادی دارم، یک معماری اولیه برای پروژه در نظر می‌گیرم. پیش‌بینی می‌کنم که برای نوشتن این سامانه، باید این کلاس‌ها را داشته باشیم و هر کلاس باید قابلیت‌هایی مانند ایجاد توکن، فراخوانی شبکه‌های دیگر، یا ارتباط با سایر سیستم‌ها را داشته باشد. یک سری متدها باید در این کلاس‌ها پیاده‌سازی شود.</p><p>من نمی‌آیم تمام این‌ها را خودم کدنویسی کنم، زیرا این کار باعث می‌شود زمان و هزینه زیادی صرف شود. اینترفیس مثل یک امضا است که مشخص می‌کند هر کلاس باید چه متدهایی با چه ورودی‌ها و خروجی‌هایی داشته باشد، اما نحوه پیاده‌سازی آن‌ها را مشخص نمی‌کند. این کار به تیم توسعه‌دهنده کمک می‌کند تا کارها تقسیم شود و هر کسی روی بخش مربوط به خود کار کند بدون تداخل و بدون اینکه زمان افراد با تجربه بالا صرف کارهای ساده شود. اینترفیس به مدیریت بهتر پروژه، بهبود پرفورمنس، و مسائل امنیتی کمک می‌کند. اینترفیس، مشکل تقسیم کار را از دیدگاه کاربردی حل می‌کند.</p><h3>Abstraction (انتزاع)</h3><p>Abstraction هم همین کار را می‌کند، یعنی شما متدهای مورد نیاز را با ورودی و خروجی‌هایشان تعریف می‌کنید. اما تفاوت اصلی بین Abstraction و Interface در جاوا این است که در <strong>Abstraction (کلاس انتزاعی)</strong>، یک سری متدها همانند اینترفیس به صورت چکیده‌شده (فقط تعریف) هستند و یک سری متدها نیز پیاده‌سازی شده‌اند. اما در <strong>Interface</strong>، شما نمی‌توانید متدی داشته باشید که پیاده‌سازی شده باشد؛ <strong>تمام متدها باید به صورت تعریف‌شده و چکیده‌شده باشند</strong> و پیاده‌سازی آن‌ها به کلاس‌هایی که از اینترفیس ارث می‌برند، واگذار می‌شود.</p><p>این تفاوت را به دقت مطالعه کنید و برای جلسه بعد آماده باشید. این مطالب مهم هستند و در امتحان از آن‌ها سوال خواهد شد.</p><h2>تمرین: پروژه شرکت خودروسازی</h2><p>از الان شروع کنید. یک پروژه ایجاد کنید که در مورد یک شرکت خودروسازی است. این شرکت ماشین‌هایی مانند BMW و Benz تولید می‌کند. از اصول شیءگرایی (مانند وراثت) برای طراحی کلاس‌ها استفاده کنید. هر کلاس باید دو متد متفاوت داشته باشد (مثلاً در BMW: TakeOff کردن، ترمز ABS و غیره) و همچنین یک متد مشترک بین BMW و Benz (مثلاً روشن کردن موتور). همچنین، یک یا دو فیلد مشترک و یک یا دو فیلد غیرمشترک برای کلاس‌های خود در نظر بگیرید.</p><p><strong>نکات مهم برای تمرین:</strong></p><ul><li><strong>بدون استفاده از هوش مصنوعی (AI)</strong> کدنویسی کنید.</li><li>اگر سیستمی (IntelliJ IDEA) ندارید، روی کاغذ کد بنویسید و ارسال کنید (ولی برای جلسه بعد همه باید IntelliJ IDEA را نصب کنند).</li><li>این تمرین <strong>نیازی به استفاده از Interface یا Abstraction ندارد.</strong></li></ul><h2>نحوه ارسال تمرین</h2><p>برای ارسال تمرین، یک عکس از کد (اگر روی کاغذ نوشتید) یا خود فایل کد (اگر با IntelliJ IDEA نوشتید) برای من بفرستید. هنگام ارسال، <strong>حتماً</strong> از این فرمت برای نام‌گذاری پیام خود استفاده کنید: `#تمرین_سری_اول_سیار` (بجای \'سیار\' اسم خودتان را بنویسید). این نام‌گذاری برای من ضروری است تا بتوانم تمرین‌ها را در زمان امتحان پیدا و نمره بدهم. لطفاً این نکته را رعایت کنید.</p><p><strong>نصب IntelliJ IDEA:</strong> همه باید IntelliJ IDEA را نصب کنند. برای نصب IntelliJ IDEA، شما نیاز دارید که Java را نیز نصب کنید (خود Java، نه فقط JRE). مطمئن شوید که هر دو را به درستی نصب کرده‌اید. اگر IntelliJ IDEA را نصب نکرده‌اید، نمی‌توانید کدها را برای من بفرستید. برای نصب صحیح، اگر فقط JRE را نصب کرده‌اید، آن را حذف کنید و JDK را نصب کنید که شامل JRE هم می‌شود. سپس IntelliJ IDEA را نصب کنید.</p><h2>پایان جلسه</h2><p>اگر سوالی هست، بفرمایید. خسته نباشید. تمرینات را داخل کانال قرار خواهم داد و مهلت آن را مشخص می‌کنم. خودتان انجام دهید. جلسه بعدی از شما پرسیده می‌شود.</p></div></div>','<div style=\"max-width: 100%; overflow-x: hidden; word-wrap: break-word; padding: 1rem; box-sizing: border-box;\"><h1>مرور مطالب جلسه گذشته</h1><p>ابتدا مروری بر مطالب جلسه گذشته خواهیم داشت.</p><h2>مفاهیم شیءگرایی (OOP)</h2><ul><li><h3>پنهان‌سازی (Encapsulation)</h3><p>مفهوم پنهان‌سازی به این معناست که یک جعبه در نظر می‌گیریم که از اجزای مختلفی تشکیل شده است.</p></li><li><h3>تفسیر چندریختی (Polymorphism)</h3><p>تفسیر چندریختی یعنی یک شیء می‌تواند حالت‌های مختلفی از خود نشان دهد. به عنوان مثال، یک شیء از یک کلاس می‌تواند به چند شیء مختلف تبدیل شود و هر یک نیز حالت‌های متفاوتی را در کلاس‌های دیگر از خود نشان دهند. (به عنوان مثال، در یک بازی، یک بازیکن می‌تواند یک انسان، یک الف یا یک دورف باشد و هر کدام از این‌ها ویژگی‌های خاص خود را دارند).</p></li><li><h3>وراثت (Inheritance)</h3><p>وراثت به معنای این است که یک فرزند ویژگی‌های پدرش را به ارث می‌برد. برای استفاده از وراثت باید رابطه \"is a\" (هستِ) برقرار باشد. به عنوان مثال، \"انسان یک موجود است\" یا \"حیوان یک موجود است\". این نشان می‌دهد که یک کلاس فرزندی، \"یک نوع از\" کلاس والد خود است.</p></li></ul><h2>تفاوت “is a” و “has a”</h2><p>تفاوت “is a” (هستِ) و “has a” (داردِ) در این است که “is a” نشان می‌دهد که چیزی هست یا از نوع دیگری است، در حالی که “has a” نشان می‌دهد که چیزی ویژگی‌ای را دارد یا شامل چیزی است. مثلاً “خانه در دارد” (has a). هرگاه رابطه “is a” وجود داشته باشد می‌توان از وراثت استفاده کرد.</p><h2>مخفف‌های جاوا</h2><p>در جلسه گذشته سه مخفف مهم مرتبط با جاوا را بررسی کردیم:</p><ul><li><h3>JRE</h3><p>مخفف “Java Runtime Environment” است. این پلتفرم برای اجرای برنامه‌های جاوا به کار می‌رود و شامل JVM و کتابخانه‌های مورد نیاز است.</p></li><li><h3>JDK</h3><p>مخفف “Java Development Kit” است. این کیت برای توسعه‌دهندگان جاوا طراحی شده و شامل JRE به همراه ابزارهای توسعه مانند کامپایلر (javac) و دیباگر (jdb) است. بزرگترین مجموعه بین سه مورد است و توسعه‌دهندگان برای کدنویسی و کامپایل به آن نیاز دارند.</p></li><li><h3>JVM</h3><p>مخفف “Java Virtual Machine” است. این محیط مجازی وظیفه اجرای کد بایت جاوا را بر عهده دارد و بخشی از JRE است.</p></li></ul><p><strong>رابطه بین این سه:</strong> JDK شامل JRE است و JRE شامل JVM است. به عبارت دیگر، JDK (بزرگترین) برای توسعه‌دهندگان، JRE برای کاربرانی که فقط می‌خواهند برنامه اجرا کنند و JVM (کوچکترین) قلب اجرای جاوا است.</p><h2>توضیح در مورد Interface و Abstraction</h2><p>امروز می‌خواهم در مورد Interface و Abstraction توضیح بدهم و تمرینی حول این موضوعات به شما خواهم داد.</p><h3>Interface (واسط)</h3><p>یک Interface در جاوا یک ساختار بدون جزئیات است. فرض کنید من یک شرکت بزرگ نرم‌افزاری دارم و شما همه توسعه‌دهندگان آن هستید. ما یک پروژه از یک مشتری گرفته‌ایم. من به عنوان یک کارفرما یا مدیر ارشد (Senior) که تجربه زیادی دارم، یک معماری اولیه برای پروژه در نظر می‌گیرم. پیش‌بینی می‌کنم که برای نوشتن این سامانه، باید این کلاس‌ها را داشته باشیم و هر کلاس باید قابلیت‌هایی مانند ایجاد توکن، فراخوانی شبکه‌های دیگر، یا ارتباط با سایر سیستم‌ها را داشته باشد. یک سری متدها باید در این کلاس‌ها پیاده‌سازی شود.</p><p>من نمی‌آیم تمام این‌ها را خودم کدنویسی کنم، زیرا این کار باعث می‌شود زمان و هزینه زیادی صرف شود. اینترفیس مثل یک امضا است که مشخص می‌کند هر کلاس باید چه متدهایی با چه ورودی‌ها و خروجی‌هایی داشته باشد، اما نحوه پیاده‌سازی آن‌ها را مشخص نمی‌کند. این کار به تیم توسعه‌دهنده کمک می‌کند تا کارها تقسیم شود و هر کسی روی بخش مربوط به خود کار کند بدون تداخل و بدون اینکه زمان افراد با تجربه بالا صرف کارهای ساده شود. اینترفیس به مدیریت بهتر پروژه، بهبود پرفورمنس، و مسائل امنیتی کمک می‌کند. اینترفیس، مشکل تقسیم کار را از دیدگاه کاربردی حل می‌کند.</p><h3>Abstraction (انتزاع)</h3><p>Abstraction هم همین کار را می‌کند، یعنی شما متدهای مورد نیاز را با ورودی و خروجی‌هایشان تعریف می‌کنید. اما تفاوت اصلی بین Abstraction و Interface در جاوا این است که در <strong>Abstraction (کلاس انتزاعی)</strong>، یک سری متدها همانند اینترفیس به صورت چکیده‌شده (فقط تعریف) هستند و یک سری متدها نیز پیاده‌سازی شده‌اند. اما در <strong>Interface</strong>، شما نمی‌توانید متدی داشته باشید که پیاده‌سازی شده باشد؛ <strong>تمام متدها باید به صورت تعریف‌شده و چکیده‌شده باشند</strong> و پیاده‌سازی آن‌ها به کلاس‌هایی که از اینترفیس ارث می‌برند، واگذار می‌شود.</p><p>این تفاوت را به دقت مطالعه کنید و برای جلسه بعد آماده باشید. این مطالب مهم هستند و در امتحان از آن‌ها سوال خواهد شد.</p><h2>تمرین: پروژه شرکت خودروسازی</h2><p>از الان شروع کنید. یک پروژه ایجاد کنید که در مورد یک شرکت خودروسازی است. این شرکت ماشین‌هایی مانند BMW و Benz تولید می‌کند. از اصول شیءگرایی (مانند وراثت) برای طراحی کلاس‌ها استفاده کنید. هر کلاس باید دو متد متفاوت داشته باشد (مثلاً در BMW: TakeOff کردن، ترمز ABS و غیره) و همچنین یک متد مشترک بین BMW و Benz (مثلاً روشن کردن موتور). همچنین، یک یا دو فیلد مشترک و یک یا دو فیلد غیرمشترک برای کلاس‌های خود در نظر بگیرید.</p><p><strong>نکات مهم برای تمرین:</strong></p><ul><li><strong>بدون استفاده از هوش مصنوعی (AI)</strong> کدنویسی کنید.</li><li>اگر سیستمی (IntelliJ IDEA) ندارید، روی کاغذ کد بنویسید و ارسال کنید (ولی برای جلسه بعد همه باید IntelliJ IDEA را نصب کنند).</li><li>این تمرین <strong>نیازی به استفاده از Interface یا Abstraction ندارد.</strong></li></ul><h2>نحوه ارسال تمرین</h2><p>برای ارسال تمرین، یک عکس از کد (اگر روی کاغذ نوشتید) یا خود فایل کد (اگر با IntelliJ IDEA نوشتید) برای من بفرستید. هنگام ارسال، <strong>حتماً</strong> از این فرمت برای نام‌گذاری پیام خود استفاده کنید: `#تمرین_سری_اول_سیار` (بجای \'سیار\' اسم خودتان را بنویسید). این نام‌گذاری برای من ضروری است تا بتوانم تمرین‌ها را در زمان امتحان پیدا و نمره بدهم. لطفاً این نکته را رعایت کنید.</p><p><strong>نصب IntelliJ IDEA:</strong> همه باید IntelliJ IDEA را نصب کنند. برای نصب IntelliJ IDEA، شما نیاز دارید که Java را نیز نصب کنید (خود Java، نه فقط JRE). مطمئن شوید که هر دو را به درستی نصب کرده‌اید. اگر IntelliJ IDEA را نصب نکرده‌اید، نمی‌توانید کدها را برای من بفرستید. برای نصب صحیح، اگر فقط JRE را نصب کرده‌اید، آن را حذف کنید و JDK را نصب کنید که شامل JRE هم می‌شود. سپس IntelliJ IDEA را نصب کنید.</p><h2>پایان جلسه</h2><p>اگر سوالی هست، بفرمایید. خسته نباشید. تمرینات را داخل کانال قرار خواهم داد و مهلت آن را مشخص می‌کنم. خودتان انجام دهید. جلسه بعدی از شما پرسیده می‌شود.</p></div>','completed','2025-10-13 11:20:20','2025-12-06 19:31:39',NULL,NULL,0,NULL,1,NULL),(28,1,1,'مفاهیم پیشرفته در برنامه‌نویسی شیءگرا: انتزاع، واسط‌ها و سازنده‌ها','1404/07/28','<div style=\"max-width: 100%; overflow-x: hidden; word-wrap: break-word; padding: 1rem; box-sizing: border-box;\"><div style=\"max-width: 100%; overflow-x: hidden; word-wrap: break-word; padding: 1rem; box-sizing: border-box;\"><h1>مقدمه‌ای بر کلاس‌های انتزاعی و واسط‌ها</h1><p>بحث از کلاس‌هایی آغاز شد که اگر بخشی از متدهای آن‌ها پیاده‌سازی نشود، آن کلاس تبدیل به یک کلاس انتزاعی (Abstract Class) می‌شود. در چنین حالتی، نمی‌توانیم از آن کلاس شیء بسازیم.</p><h2>تفاوت کلاس انتزاعی با واسط (Interface)</h2><h3>کلاس انتزاعی (Abstract Class)</h3><ul><li><b>تعریف:</b> یک کلاس انتزاعی ممکن است متدهای پیاده‌سازی نشده داشته باشد. اگر کلاسی حداقل یک متد انتزاعی داشته باشد، خود کلاس نیز باید انتزاعی تعریف شود.</li><li><b>هدف:</b> تمرکز بر روی «چه چیزی انجام می‌شود» (نتیجه)، نه «چگونه انجام می‌شود» (جزئیات پیاده‌سازی). این به معنی انتزاع عملیات‌ها است.</li><li><b>مثال:</b> می‌توان آن را به یک نسخه ساده شده (نسخه ساده شده برای کاربر) تشبیه کرد که در آن جزئیات فنی پنهان هستند و فقط نتیجه مهم است.</li></ul><h3>واسط (Interface)</h3><ul><li><b>تعریف:</b> واسط به عنوان یک «رابط» یا قرارداد عمل می‌کند که مجموعه‌ای از متدها را بدون پیاده‌سازی تعریف می‌کند.</li><li><b>هدف:</b> تعریف یک رفتار یا قابلیت که کلاس‌های دیگر می‌توانند آن را پیاده‌سازی کنند.</li><li><b>تاریخچه در جاوا:</b> تا قبل از نسخه‌های اخیر جاوا، واسط‌ها تنها شامل امضای متدها (تعریف نشده) بودند و هیچ پیاده‌سازی نداشتند.</li></ul><h2>ارث‌بری چندگانه (Multiple Inheritance)</h2><h3>مفهوم ارث‌بری چندگانه</h3><p>ارث‌بری چندگانه به وضعیتی اطلاق می‌شود که یک کلاس می‌تواند به طور مستقیم از چندین کلاس والد ارث ببرد و ویژگی‌ها و رفتارهای آن‌ها را به ارث ببرد.</p><h3>محدودیت جاوا در ارث‌بری چندگانه کلاس‌ها</h3><ul><li><b>عدم پشتیبانی:</b> جاوا از ارث‌بری چندگانه برای کلاس‌ها پشتیبانی نمی‌کند. یعنی یک کلاس نمی‌تواند همزمان از دو کلاس دیگر <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">extends</code> کند (مثلاً <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">class A extends B, C</code>).</li><li><b>دلیل:</b> اصلی‌ترین دلیل این محدودیت، «مشکل ابهام» (Ambiguity Problem) است. اگر یک کلاس از دو والد ارث ببرد که هر دو متدی با نام و امضای یکسان دارند، کلاس فرزند نمی‌داند که هنگام فراخوانی آن متد، کدام نسخه را اجرا کند. این وضعیت به «مشکل الماس» (Diamond Problem) نیز معروف است.</li><li><b>مثال:</b> فرض کنید کلاس <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">Parent1</code> متد <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">talk()</code> را پیاده‌سازی کرده که می‌گوید \"سلام من والد یک هستم\" و کلاس <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">Parent2</code> نیز متد <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">talk()</code> را پیاده‌سازی کرده که می‌گوید \"سلام من والد دو هستم\". اگر کلاس <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">Child</code> از هر دو ارث ببرد، هنگام فراخوانی <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">child.talk()</code>، سیستم دچار ابهام می‌شود و نمی‌داند کدام متد را باید اجرا کند. این باعث خطای کامپایلر می‌شود.</li></ul><h3>راهکار جاوا برای شبیه‌سازی ارث‌بری چندگانه (با واسط‌ها)</h3><p>جاوا با وجود عدم پشتیبانی از ارث‌بری چندگانه کلاس‌ها، راهکاری را از طریق واسط‌ها ارائه داده است:</p><ul><li><b><code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">extends</code> و <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">implements</code>:</b> یک کلاس می‌تواند تنها از یک کلاس دیگر <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">extends</code> کند، اما می‌تواند چندین واسط را <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">implements</code> کند (مثلاً <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">public class A extends B implements C, D, ...</code>).</li><li><b>متدهای پیش‌فرض در واسط‌ها:</b> از نسخه‌های اخیر جاوا (مانند جاوا 8 و بالاتر)، واسط‌ها می‌توانند علاوه بر متدهای تعریف نشده، متدهای پیش‌فرض (<code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">default methods</code>) را نیز شامل شوند که دارای پیاده‌سازی هستند. این قابلیت به واسط‌ها این امکان را می‌دهد که به نوعی رفتار را به کلاس‌های پیاده‌ساز منتقل کنند.</li><li><b>چگونگی عملکرد:</b> با این روش، یک کلاس می‌تواند رفتارها را از یک کلاس والد (با <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">extends</code>) و از چندین واسط (با <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">implements</code>) به ارث ببرد. اگر در واسط‌های مختلف، متدهای پیاده‌سازی شده با نام‌های یکسان وجود داشته باشند، در صورت بروز ابهام، کامپایلر تشخیص داده و خطا می‌دهد. اما اگر نام‌ها متفاوت باشند، این مکانیزم به کلاس اجازه می‌دهد تا از چندین منبع مختلف «ارث‌بری» داشته باشد.</li></ul><h2>سازنده‌ها (Constructors)</h2><h3>تعریف سازنده</h3><p>سازنده یک متد خاص در یک کلاس است که هر زمان که یک شیء جدید از آن کلاس ایجاد می‌شود، به صورت خودکار فراخوانی می‌گردد. نقش اصلی سازنده مقداردهی اولیه به متغیرهای شیء و آماده‌سازی آن برای استفاده است.</p><h3>ویژگی‌های سازنده</h3><ul><li><b>نام یکسان با کلاس:</b> نام سازنده باید دقیقاً با نام کلاس یکسان باشد (با رعایت حساسیت به حروف کوچک و بزرگ). به عنوان مثال، اگر کلاس <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">A</code> باشد، سازنده آن <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">A()</code> خواهد بود.</li><li><b>عدم وجود نوع بازگشتی:</b> سازنده‌ها هیچ نوع بازگشتی (حتی <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">void</code>) ندارند.</li><li><b>فراخوانی خودکار:</b> هنگامی که با استفاده از کلمه کلیدی <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">new</code> یک شیء از کلاس ساخته می‌شود، سازنده به صورت خودکار فراخوانی و اجرا می‌گردد.</li><li><b>مکان تعریف:</b> سازنده معمولاً بلافاصله پس از تعریف پراپرتی‌ها یا اَتریبیوت‌های کلاس تعریف می‌شود.</li></ul><h3>فراخوانی سازنده والد (Parent Constructor)</h3><p>هنگامی که یک شیء از یک کلاس فرزند ساخته می‌شود، همیشه سازنده کلاس والد نیز فراخوانی می‌شود:</p><ul><li><b>فراخوانی ضمنی <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">super()</code>:</b> اگر در سازنده کلاس فرزند به صراحت سازنده والد فراخوانی نشود، به صورت پیش‌فرض، سازنده بدون پارامتر کلاس والد با <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">super()</code> فراخوانی می‌گردد.</li><li><b>فراخوانی صریح با پارامتر:</b> اگر کلاس والد سازنده بدون پارامتر نداشته باشد و فقط سازنده‌هایی با پارامتر تعریف کرده باشد، کلاس فرزند <b>باید</b> به صراحت و با استفاده از کلمه کلیدی <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">super()</code> و ارسال پارامترهای لازم، سازنده والد را فراخوانی کند.</li><li><b>مثال:</b> اگر <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">class A extends B</code> و <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">B</code> یک سازنده <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">B(int age)</code> دارد اما <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">B()</code> را ندارد، <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">A</code> باید در سازنده خود <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">super(someAge)</code> را فراخوانی کند.</li></ul><h3>کاربردها و دلایل استفاده از سازنده‌ها</h3><p>سازنده‌ها ابزاری قدرتمند برای اطمینان از صحت و آمادگی شیء در لحظه ایجاد آن هستند:</p><ol><li><b>مقداردهی اولیه (Initialization):</b><br/>اصلی‌ترین کاربرد سازنده، مقداردهی اولیه به متغیرهای شیء است. به جای اینکه پس از ساخت شیء، تک‌تک فیلدها را با مقادیر مورد نظر پر کنیم، می‌توانیم این فرآیند را در سازنده متمرکز کنیم. <pre style=\"white-space: pre-wrap !important; word-wrap: break-word !important; overflow-x: auto !important; max-width: 100% !important; padding: 1rem; background-color: #f5f5f5; border-radius: 4px; direction: ltr; font-family: \'Courier New\', monospace; font-size: 0.9em; line-height: 1.5; margin: 1rem 0;white-space: pre-wrap !important; word-wrap: break-word !important; overflow-x: auto !important; max-width: 100% !important; padding: 1rem; background-color: #f5f5f5; border-radius: 4px; direction: ltr; font-family: \'Courier New\', monospace; font-size: 0.9em; line-height: 1.5; margin: 1rem 0;\"><code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; display: block; overflow-x: auto; font-family: \'Courier New\', monospace;white-space: pre-wrap !important; word-wrap: break-word !important; display: block; overflow-x: auto; font-family: \'Courier New\', monospace;\">// بدون سازنده (تکرار کد)\nCar c1 = new Car();\nc1.year = 2020;\nc1.color = \"Red\";\n\nCar c2 = new Car();\nc2.year = 2021;\nc2.color = \"Blue\";\n\n// با سازنده (کد بهینه‌تر)\nCar c1 = new Car(2020, \"Red\");\nCar c2 = new Car(2021, \"Blue\");</code></pre></li><li><b>اعتبارسنجی (Validation):</b><br/>سازنده می‌تواند برای اعمال قوانین و محدودیت‌ها بر روی مقادیر اولیه شیء استفاده شود. به عنوان مثال، می‌توانیم در سازنده بررسی کنیم که سال تولید خودرو منطقی باشد (مثلاً بزرگتر از 2000).</li><li><b>تخصیص منابع (Resource Allocation):</b><br/>در موارد پیچیده‌تر، سازنده می‌تواند برای انجام کارهایی مانند برقراری اتصال به پایگاه داده، باز کردن فایل، یا تخصیص حافظه خاص استفاده شود. این کار تضمین می‌کند که شیء به محض ایجاد، در یک وضعیت معتبر و آماده به کار قرار گیرد. این مفهوم به «<code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">On-demand</code>» نیز معروف است که کارها در زمان نیاز انجام می‌شوند. این موضوع برای مدیریت حافظه در `Heap` نیز اهمیت دارد.<br/>برای مثال، زمانی که یک شیء از کلاس <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">DatabaseConnector</code> ساخته می‌شود، سازنده می‌تواند مسئول برقراری اتصال به پایگاه داده و انجام تنظیمات اولیه باشد.</li><li><b>جلوگیری از تکرار کد:</b><br/>سازنده‌ها به کاهش تکرار کد کمک می‌کنند. به جای نوشتن کدهای مقداردهی برای هر شیء جدید، کد مربوطه یک بار در سازنده نوشته می‌شود.</li></ol><h3>مفهوم `Blueprint` (طرح اولیه) و `Object`</h3><p>کلاس را می‌توان به یک `Blueprint` یا طرح اولیه تشبیه کرد (مثل تمپلیت در پاورپوینت). هدف از ساخت کلاس، ایجاد یک الگو برای ساخت شیءها است. هر شیء که از یک کلاس ساخته می‌شود، تمام پراپرتی‌ها و متدهای تعریف شده در آن کلاس را به صورت پیش‌فرض خواهد داشت.</p><p><b>نکته:</b> برای مدیریت حافظه و بهینه‌سازی، توصیه می‌شود مقادیردهی اولیه و تخصیص منابع در سازنده انجام شود تا از پر شدن حافظه `Heap` با مقادیر غیرضروری یا تکرار شده جلوگیری شود. سازنده تضمین می‌کند که این مقداردهی‌ها به صورت `Atomic` و در لحظه ساخت شیء اتفاق می‌افتند.</p></div></div>','<h1>مقدمه‌ای بر کلاس‌های انتزاعی و واسط‌ها</h1><p>بحث از کلاس‌هایی آغاز شد که اگر بخشی از متدهای آن‌ها پیاده‌سازی نشود، آن کلاس تبدیل به یک کلاس انتزاعی (Abstract Class) می‌شود. در چنین حالتی، نمی‌توانیم از آن کلاس شیء بسازیم.</p><h2>تفاوت کلاس انتزاعی با واسط (Interface)</h2><h3>کلاس انتزاعی (Abstract Class)</h3><ul><li><strong>تعریف:</strong> یک کلاس انتزاعی ممکن است متدهای پیاده‌سازی نشده داشته باشد. اگر کلاسی حداقل یک متد انتزاعی داشته باشد، خود کلاس نیز باید انتزاعی تعریف شود.</li><li><strong>هدف:</strong> تمرکز بر روی «چه چیزی انجام می‌شود» (نتیجه)، نه «چگونه انجام می‌شود» (جزئیات پیاده‌سازی). این به معنی انتزاع عملیات‌ها است.</li><li><strong>مثال:</strong> می‌توان آن را به یک نسخه ساده شده (نسخه ساده شده برای کاربر) تشبیه کرد که در آن جزئیات فنی پنهان هستند و فقط نتیجه مهم است.</li></ul><h3>واسط (Interface)</h3><ul><li><strong>تعریف:</strong> واسط به عنوان یک «رابط» یا قرارداد عمل می‌کند که مجموعه‌ای از متدها را بدون پیاده‌سازی تعریف می‌کند.</li><li><strong>هدف:</strong> تعریف یک رفتار یا قابلیت که کلاس‌های دیگر می‌توانند آن را پیاده‌سازی کنند.</li><li><strong>تاریخچه در جاوا:</strong> تا قبل از نسخه‌های اخیر جاوا، واسط‌ها تنها شامل امضای متدها (تعریف نشده) بودند و هیچ پیاده‌سازی نداشتند.</li></ul><h2>ارث‌بری چندگانه (Multiple Inheritance)</h2><h3>مفهوم ارث‌بری چندگانه</h3><p>ارث‌بری چندگانه به وضعیتی اطلاق می‌شود که یک کلاس می‌تواند به طور مستقیم از چندین کلاس والد ارث ببرد و ویژگی‌ها و رفتارهای آن‌ها را به ارث ببرد.</p><h3>محدودیت جاوا در ارث‌بری چندگانه کلاس‌ها</h3><ul><li><strong>عدم پشتیبانی:</strong> جاوا از ارث‌بری چندگانه برای کلاس‌ها پشتیبانی نمی‌کند. یعنی یک کلاس نمی‌تواند همزمان از دو کلاس دیگر <code>extends</code> کند (مثلاً <code>class A extends B, C</code>).</li><li><strong>دلیل:</strong> اصلی‌ترین دلیل این محدودیت، «مشکل ابهام» (Ambiguity Problem) است. اگر یک کلاس از دو والد ارث ببرد که هر دو متدی با نام و امضای یکسان دارند، کلاس فرزند نمی‌داند که هنگام فراخوانی آن متد، کدام نسخه را اجرا کند. این وضعیت به «مشکل الماس» (Diamond Problem) نیز معروف است.</li><li><strong>مثال:</strong> فرض کنید کلاس <code>Parent1</code> متد <code>talk()</code> را پیاده‌سازی کرده که می‌گوید \"سلام من والد یک هستم\" و کلاس <code>Parent2</code> نیز متد <code>talk()</code> را پیاده‌سازی کرده که می‌گوید \"سلام من والد دو هستم\". اگر کلاس <code>Child</code> از هر دو ارث ببرد، هنگام فراخوانی <code>child.talk()</code>، سیستم دچار ابهام می‌شود و نمی‌داند کدام متد را باید اجرا کند. این باعث خطای کامپایلر می‌شود.</li></ul><h3>راهکار جاوا برای شبیه‌سازی ارث‌بری چندگانه (با واسط‌ها)</h3><p>جاوا با وجود عدم پشتیبانی از ارث‌بری چندگانه کلاس‌ها، راهکاری را از طریق واسط‌ها ارائه داده است:</p><ul><li><code><strong>extends</strong></code><strong> و </strong><code><strong>implements</strong></code><strong>:</strong> یک کلاس می‌تواند تنها از یک کلاس دیگر <code>extends</code> کند، اما می‌تواند چندین واسط را <code>implements</code> کند (مثلاً <code>public class A extends B implements C, D, ...</code>).</li><li><strong>متدهای پیش‌فرض در واسط‌ها:</strong> از نسخه‌های اخیر جاوا (مانند جاوا 8 و بالاتر)، واسط‌ها می‌توانند علاوه بر متدهای تعریف نشده، متدهای پیش‌فرض (<code>default methods</code>) را نیز شامل شوند که دارای پیاده‌سازی هستند. این قابلیت به واسط‌ها این امکان را می‌دهد که به نوعی رفتار را به کلاس‌های پیاده‌ساز منتقل کنند.</li><li><strong>چگونگی عملکرد:</strong> با این روش، یک کلاس می‌تواند رفتارها را از یک کلاس والد (با <code>extends</code>) و از چندین واسط (با <code>implements</code>) به ارث ببرد. اگر در واسط‌های مختلف، متدهای پیاده‌سازی شده با نام‌های یکسان وجود داشته باشند، در صورت بروز ابهام، کامپایلر تشخیص داده و خطا می‌دهد. اما اگر نام‌ها متفاوت باشند، این مکانیزم به کلاس اجازه می‌دهد تا از چندین منبع مختلف «ارث‌بری» داشته باشد.</li></ul><h2>سازنده‌ها (Constructors)</h2><h3>تعریف سازنده</h3><p>سازنده یک متد خاص در یک کلاس است که هر زمان که یک شیء جدید از آن کلاس ایجاد می‌شود، به صورت خودکار فراخوانی می‌گردد. نقش اصلی سازنده مقداردهی اولیه به متغیرهای شیء و آماده‌سازی آن برای استفاده است.</p><h3>ویژگی‌های سازنده</h3><ul><li><strong>نام یکسان با کلاس:</strong> نام سازنده باید دقیقاً با نام کلاس یکسان باشد (با رعایت حساسیت به حروف کوچک و بزرگ). به عنوان مثال، اگر کلاس <code>A</code> باشد، سازنده آن <code>A()</code> خواهد بود.</li><li><strong>عدم وجود نوع بازگشتی:</strong> سازنده‌ها هیچ نوع بازگشتی (حتی <code>void</code>) ندارند.</li><li><strong>فراخوانی خودکار:</strong> هنگامی که با استفاده از کلمه کلیدی <code>new</code> یک شیء از کلاس ساخته می‌شود، سازنده به صورت خودکار فراخوانی و اجرا می‌گردد.</li><li><strong>مکان تعریف:</strong> سازنده معمولاً بلافاصله پس از تعریف پراپرتی‌ها یا اَتریبیوت‌های کلاس تعریف می‌شود.</li></ul><h3>فراخوانی سازنده والد (Parent Constructor)</h3><p>هنگامی که یک شیء از یک کلاس فرزند ساخته می‌شود، همیشه سازنده کلاس والد نیز فراخوانی می‌شود:</p><ul><li><strong>فراخوانی ضمنی </strong><code><strong>super()</strong></code><strong>:</strong> اگر در سازنده کلاس فرزند به صراحت سازنده والد فراخوانی نشود، به صورت پیش‌فرض، سازنده بدون پارامتر کلاس والد با <code>super()</code> فراخوانی می‌گردد.</li><li><strong>فراخوانی صریح با پارامتر:</strong> اگر کلاس والد سازنده بدون پارامتر نداشته باشد و فقط سازنده‌هایی با پارامتر تعریف کرده باشد، کلاس فرزند <strong>باید</strong> به صراحت و با استفاده از کلمه کلیدی <code>super()</code> و ارسال پارامترهای لازم، سازنده والد را فراخوانی کند.</li><li><strong>مثال:</strong> اگر <code>class A extends B</code> و <code>B</code> یک سازنده <code>B(int age)</code> دارد اما <code>B()</code> را ندارد، <code>A</code> باید در سازنده خود <code>super(someAge)</code> را فراخوانی کند.</li></ul><h3>کاربردها و دلایل استفاده از سازنده‌ها</h3><p>سازنده‌ها ابزاری قدرتمند برای اطمینان از صحت و آمادگی شیء در لحظه ایجاد آن هستند:</p><ol><li><strong>مقداردهی اولیه (Initialization):</strong></li><li>اصلی‌ترین کاربرد سازنده، مقداردهی اولیه به متغیرهای شیء است. به جای اینکه پس از ساخت شیء، تک‌تک فیلدها را با مقادیر مورد نظر پر کنیم، می‌توانیم این فرآیند را در سازنده متمرکز کنیم.</li></ol><pre class=\"ql-syntax\" spellcheck=\"false\">// بدون سازنده (تکرار کد)\nCar c1 = new Car();\nc1.year = 2020;\nc1.color = \"Red\";\n\nCar c2 = new Car();\nc2.year = 2021;\nc2.color = \"Blue\";\n\n// با سازنده (کد بهینه‌تر)\nCar c1 = new Car(2020, \"Red\");\nCar c2 = new Car(2021, \"Blue\");\n</pre><ol><li><strong>اعتبارسنجی (Validation):</strong></li><li>سازنده می‌تواند برای اعمال قوانین و محدودیت‌ها بر روی مقادیر اولیه شیء استفاده شود. به عنوان مثال، می‌توانیم در سازنده بررسی کنیم که سال تولید خودرو منطقی باشد (مثلاً بزرگتر از 2000).</li><li><strong>تخصیص منابع (Resource Allocation):</strong></li><li>در موارد پیچیده‌تر، سازنده می‌تواند برای انجام کارهایی مانند برقراری اتصال به پایگاه داده، باز کردن فایل، یا تخصیص حافظه خاص استفاده شود. این کار تضمین می‌کند که شیء به محض ایجاد، در یک وضعیت معتبر و آماده به کار قرار گیرد. این مفهوم به «<code>On-demand</code>» نیز معروف است که کارها در زمان نیاز انجام می‌شوند. این موضوع برای مدیریت حافظه در `Heap` نیز اهمیت دارد.</li><li>برای مثال، زمانی که یک شیء از کلاس <code>DatabaseConnector</code> ساخته می‌شود، سازنده می‌تواند مسئول برقراری اتصال به پایگاه داده و انجام تنظیمات اولیه باشد.</li><li><strong>جلوگیری از تکرار کد:</strong></li><li>سازنده‌ها به کاهش تکرار کد کمک می‌کنند. به جای نوشتن کدهای مقداردهی برای هر شیء جدید، کد مربوطه یک بار در سازنده نوشته می‌شود.</li></ol><h3>مفهوم `Blueprint` (طرح اولیه) و `Object`</h3><p>کلاس را می‌توان به یک `Blueprint` یا طرح اولیه تشبیه کرد (مثل تمپلیت در پاورپوینت). هدف از ساخت کلاس، ایجاد یک الگو برای ساخت شیءها است. هر شیء که از یک کلاس ساخته می‌شود، تمام پراپرتی‌ها و متدهای تعریف شده در آن کلاس را به صورت پیش‌فرض خواهد داشت.</p><p><strong>نکته:</strong> برای مدیریت حافظه و بهینه‌سازی، توصیه می‌شود مقادیردهی اولیه و تخصیص منابع در سازنده انجام شود تا از پر شدن حافظه `Heap` با مقادیر غیرضروری یا تکرار شده جلوگیری شود. سازنده تضمین می‌کند که این مقداردهی‌ها به صورت `Atomic` و در لحظه ساخت شیء اتفاق می‌افتند.</p>','completed','2025-10-26 07:56:28','2025-12-06 19:31:39',NULL,NULL,0,NULL,1,NULL),(29,4,1,'یادگیری ماشین: مفاهیم و رویکردها','1404/07/27','<div style=\"max-width: 100%; overflow-x: hidden; word-wrap: break-word; padding: 1rem; box-sizing: border-box;\"><div style=\"max-width: 100%; overflow-x: hidden; word-wrap: break-word; padding: 1rem; box-sizing: border-box;\"><h1>یادگیری ماشین و هوش مصنوعی: مفاهیم و رویکردها</h1><h2>تعریف الگوریتم‌های یادگیری ماشین</h2><h3>کارهای اصلی الگوریتم‌ها</h3><p>هر الگوریتمی دو کار اصلی انجام می‌دهد:</p><ol><li>جستجو در فضای فرضیه (فضای جواب‌ها).</li><li>انتخاب یک جواب و تأیید آن با اندازه‌گیری کیفیت (دقت، خطا، هزینه) بر اساس معیار (metric) مشخص.</li></ol><h3>ماهیت الگوریتم‌های یادگیری ماشین</h3><p>الگوریتم‌های یادگیری ماشین (ML) اغلب دارای یک هسته‌ی ریاضی هستند. این هسته می‌تواند از یک شرط ساده‌ی If-Then تا میلیون‌ها خط کد ریاضی و فیزیک و مدل‌های پیچیده متغیر باشد.</p><p>نکته مهم این است که پشت این الگوریتم‌ها جادو نیست؛ بلکه مجموعه‌ای از فرمول‌ها و روابط ریاضی قرار دارد.</p><p>این روابط ریاضی به صورت \"هاردکد\" یا از پیش تعیین شده به الگوریتم داده نمی‌شوند.</p><h2>فرایند یادگیری در یک معماری</h2><p>در یک \"معماری\" (Architecture)، الگوریتم می‌آموزد که الگوهای کلی و مشترک را شناسایی کند.</p><p>فرایند یادگیری شامل تکرار عملیات است، تا زمانی که منابع اجازه دهند (Epochs, Iterations).</p><h3>مراحل آموزش مدل</h3><p>مدل وارد فاز آموزش (Training) می‌شود.</p><p>برای هر داده‌ی آموزشی (Train Data) و مجموعه‌ی داده‌های آموزشی:</p><ol><li>مدل، داده‌ی ورودی (Input) و وزن‌های اولیه (Initial Weights) را دریافت می‌کند.</li><li>سپس یک پیش‌بینی (Prediction) انجام می‌دهد.</li><li>میزان خطا یا \"لاس\" (Loss) را با مقایسه بین پیش‌بینی و واقعیت (Ground Truth یا Label) محاسبه می‌کند.</li><li>این مقدار لاس برای اصلاح وزن‌ها در هر چرخه‌ی یادگیری استفاده می‌شود.</li></ol><pre style=\"white-space: pre-wrap !important; word-wrap: break-word !important; overflow-x: auto !important; max-width: 100% !important; padding: 1rem; background-color: #f5f5f5; border-radius: 4px; direction: ltr; font-family: \'Courier New\', monospace; font-size: 0.9em; line-height: 1.5; margin: 1rem 0;white-space: pre-wrap !important; word-wrap: break-word !important; overflow-x: auto !important; max-width: 100% !important; padding: 1rem; background-color: #f5f5f5; border-radius: 4px; direction: ltr; font-family: \'Courier New\', monospace; font-size: 0.9em; line-height: 1.5; margin: 1rem 0;\"><code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; display: block; overflow-x: auto; font-family: \'Courier New\', monospace;white-space: pre-wrap !important; word-wrap: break-word !important; display: block; overflow-x: auto; font-family: \'Courier New\', monospace;\">Weight = Update(Loss, Weight)</code></pre><p>این فرآیند به طور مداوم تکرار می‌شود تا وزن‌ها بهینه شوند.</p><h3>مفهوم Overfitting</h3><p>یکی از مشکلات ذاتی و رایج در یادگیری ماشین \"Overfitting\" است. این به این معنی است که مدل به جای یادگیری الگوهای کلی و مشترک، داده‌های آموزشی را حفظ می‌کند.</p><p>در نتیجه، مدل روی داده‌های آموزشی عملکرد بسیار خوبی (مثلاً ۱۰۰٪ دقت) دارد، اما روی داده‌های جدید و ندیده‌شده (که در مجموعه آموزشی نبوده) عملکرد ضعیفی از خود نشان می‌دهد و حدس‌های تصادفی می‌زند. این یک ایراد ذاتی است که باید در تمامی مدل‌ها به آن توجه داشت.</p><h2>دسته‌بندی کلی یادگیری ماشین</h2><p>یادگیری ماشین (Machine Learning) و هوش مصنوعی (AI) در بسیاری از زمینه‌ها کاربرد دارند. هوش مصنوعی یک سرفصل بسیار بالاتر و جامع‌تر از یادگیری ماشین است.</p><h3>دو نوع اصلی یادگیری ماشین</h3><p>یادگیری ماشین به دو نوع کلی تقسیم می‌شود:</p><ol><li><b>تشخیص (Discriminative)</b>: برای شناسایی یک چیز.</li><li><b>تولید (Generative)</b>: برای تولید چیزهای جدید.</li></ol><p>در حوزه‌ی تشخیص، دو نوع تسک (Task) اصلی وجود دارد:</p><ul><li><b>کلاسه‌بندی (Classification/Categorization)</b>: پرکاربردترین نوع (بالای ۹۰٪ مدل‌ها) که به معنای طبقه‌بندی کردن یک شیء یا پیش‌بینی برچسب آن است. این یک تسک قطعی محسوب می‌شود (مثلاً تشخیص نوع حیوان در یک عکس).</li><li><b>تخمین (Estimation)</b>: به معنای پیش‌بینی مقادیر عددی با دقت مشخص (مثلاً پیش‌بینی قیمت خانه).</li></ul><h3>هوش مصنوعی مولد (Generative AI)</h3><p>Generative AI داده‌ها را بررسی می‌کند، الگوهای کلی و مشترک را از آن‌ها استخراج کرده و یاد می‌گیرد.</p><p>سپس با افزودن مقدار کمی \"نویز\" (Noise) هدفمند (نه کاملاً تصادفی)، الگوهای جدیدی را تولید می‌کند. این فرایند تولید، جنبه‌ی \"خلاقیت\" مدل را نمایش می‌دهد، هرچند که هنوز تعریف دقیق و مدل ریاضی کاملی برای خلاقیت در هوش مصنوعی نداریم و تقلید خلاقیت فعلاً بسیار ناقص است.</p><h2>هوش ارگانیک و یادگیری</h2><h3>ویژگی‌های هوش ارگانیک</h3><p>ما تعریف دقیقی از هوش نداریم، اما هوش ارگانیک (انسانی) دارای ویژگی‌های کلیدی است:</p><ul><li><b>ژنوم‌محور (Genetic-driven)</b>: از نسلی به نسل دیگر منتقل می‌شود.</li><li>مفاهیم مشترک جهانی: مثالی از \"اژدها\" زده شد که در اکثر فرهنگ‌ها وجود دارد و تصور مشترکی از آن وجود دارد (بزرگ، دارای آتش، پرواز کننده، خزنده، دارای بال، دهان بزرگ، دندان‌های تیز، پنجه).</li><li>این مفهوم مشترک از تجربیات اجداد ما (مثلاً تهدید توسط حیوانات با این ویژگی‌ها) نشأت گرفته و به صورت نسل به نسل منتقل شده است.</li></ul><h3>یادگیری و تغییرات سخت‌افزاری</h3><p>یادگیری چیست؟ وقتی شما چیزی را یاد می‌گیرید، چه تغییرات سخت‌افزاری در شما رخ می‌دهد؟</p><p>چگونه یک ناظر بیرونی (معلم، استاد یا آزمون‌گیرنده) می‌فهمد که شما چیزی را یاد گرفته‌اید؟</p><p>این مفاهیم در هوش مصنوعی نیز مشابه هستند.</p><h3>ابتکار و اکتشاف (Innovation/Discovery)</h3><p>هوش مصنوعی جدید می‌تواند روابط غیرمنتظره‌ای را که ما نمی‌دانیم، یاد بگیرد. این فرایندها \"خودکار\" هستند.</p><p>یکی از ایرادات هوش مصنوعی این است که نمی‌تواند توضیح دهد که \"چرا\" تصمیمی گرفته یا \"چیزی\" را یاد گرفته است؛ یعنی شفاف نیست.</p><h2>سوگیری (Bias) در یادگیری ماشین</h2><p>دو نوع سوگیری (Bias) وجود دارد:</p><ol><li><b>سوگیری در الگوریتم (Algorithm Bias)</b>: این نوع سوگیری خوب است و به مدل کمک می‌کند تا یاد بگیرد و کار کند.</li><li><b>سوگیری در داده (Data Bias)</b>: این نوع سوگیری بد است. اگر داده‌های آموزشی دارای سوگیری باشند (مثلاً در یک سیستم پیش‌بینی دزد، اکثر دزدان در داده‌های واقعی از یک گروه خاص باشند)، مدل تصمیمات غیرواقعی یا حتی غیراخلاقی خواهد گرفت. در این حالت، مشکل از داده است و باید اصلاح شود.</li></ol><h2>مدل‌های بنیادی (Foundational Models) و تعمیم (Generalization)</h2><h3>مدل‌های بنیادی</h3><p>مدل‌های بنیادی، مدل‌های کلی هستند که دقت بالایی ندارند اما با انواع داده‌ها (بصری، زبانی، متنی) کار می‌کنند.</p><p>مثلاً، یک مدل خاص ممکن است فقط با متن خوب کار کند و با تصویر نه. اما مدل‌های بنیادی توانایی کار با همه‌ی این داده‌ها را دارند، هرچند با دقت حداکثری پایین‌تر.</p><p>کاربرد اصلی آن‌ها این است که می‌توان آن‌ها را برای کاربردهای خاص \"فاین‌تون\" (Fine-tune) کرد.</p><h3>تعمیم (Generalization)</h3><p>مهمترین جنبه‌ی مفید بودن یادگیری، \"تعمیم‌پذیری\" است.</p><p>یعنی مدلی که الگوهای اساسی را از چند مثال آموخته (مثلاً مفهوم جمع با چند مثال عددی)، بتواند آن الگو را به داده‌های جدید و ندیده‌شده (در زمان تست یا امتحان) اعمال کند و به درستی آن‌ها را حل کند.</p><p>هدف از یادگیری این است که بتوان مفاهیم آموخته شده را تعمیم (Generalize) داد.</p><h2>رویکردهای یادگیری ماشین (Learning Paradigms)</h2><p>برای پیدا کردن وزن‌ها و بایاس‌ها در مدل، سه روش یا پارادایم کلی وجود دارد:</p><ol><li><b>یادگیری نظارت‌شده (Supervised Learning)</b>:<ul><li>یادگیری \"با معلم\" است.</li><li>در این روش، جواب‌های درست (Labels) از قبل وجود دارند و معلم (سیستم) آن‌ها را به مدل ارائه می‌دهد.</li><li>بهترین نوع یادگیری برای دستیابی به دقت بالا در مسائل مشخص است.</li><li>کاربردها:<ul><li><b>رگرسیون (Regression)</b>: پیش‌بینی یک عدد حقیقی (مثلاً پیش‌بینی دما).</li><li><b>کلاسه‌بندی (Classification/Categorization)</b>: پیش‌بینی برچسب یا کلاس یک شیء.</li></ul></li><li>تقریباً تمام سیستم‌های هوش مصنوعی که در دسترس عموم هستند، از این روش استفاده می‌کنند.</li></ul></li><li><b>یادگیری بدون نظارت (Unsupervised Learning)</b>:<ul><li>یادگیری \"بدون معلم\" است.</li><li>مدل بدون دریافت جواب‌های درست، سعی می‌کند الگوها و ساختارهای پنهان در داده‌ها را پیدا کند (مثل دانش‌آموزی که خودش کتاب می‌خواند).</li><li>مشکل این روش این است که درستی چیزهایی که مدل یاد گرفته توسط ناظر بیرونی تأیید نمی‌شود.</li><li>کاربردها: خوشه‌بندی (Clustering)، کاهش ابعاد (Dimensionality Reduction).</li><li>اغلب از این روش برای یادگیری الگوهای کلی و ساخت مدل‌های بنیادی استفاده می‌شود. سپس این مدل‌های بنیادی را با استفاده از یادگیری نظارت‌شده \"فاین‌تون\" می‌کنند.</li></ul></li><li><b>یادگیری تقویتی (Reinforcement Learning)</b>:<ul><li>یادگیری \"تشویقی\" است.</li><li>یک عامل (Agent) در یک محیط (Environment) قرار دارد و بر اساس \"سیاست\" (Policy) خود، اقداماتی (Actions) انجام می‌دهد.</li><li>در قبال اقدامات صحیح، پاداش (Reward) دریافت می‌کند و در قبال اقدامات اشتباه، پاداشی دریافت نمی‌کند یا جریمه می‌شود.</li><li>مثال: بازی \"توپ را پیدا کن\" با چشم بسته، که در آن بقیه بازیکنان با تشویق یا عدم تشویق، بازیکن میانی را راهنمایی می‌کنند.</li><li>این نوع یادگیری به طور غیرمستقیم، بدون معلم صریح، الگوهای درست را می‌آموزد.</li><li>بخش اعظم مدل‌های زبانی (چت‌بات‌ها) از این روش استفاده می‌کنند (لایک و دیسلایک کاربران به عنوان پاداش عمل می‌کند).</li><li>روش \"Human Reinforcement Learning\" (Reinforcement Learning با بازخورد انسانی) در این زمینه کاربرد دارد، جایی که یک ناظر انسانی کیفیت پاسخ‌ها را تأیید یا رد می‌کند.</li></ul></li></ol><h2>پنج دسته‌ی اصلی رویکردهای یادگیری ماشین (Five Tribes)</h2><p>با وجود بی‌نهایت فرمول و روش یادگیری ماشین، می‌توان آن‌ها را به پنج دسته‌ی اصلی تقسیم کرد:</p><ol><li><b>نمادگرایان (Symbolists)</b>:<ul><li>تقریباً منقرض شده‌اند.</li><li>معتقد بودند که می‌توان دانش را با زبان و نمادها نمایش داد.</li><li>دو عملیات اصلی داشتند:<ul><li><b>کاهش (Deduction)</b>: بسط دادن دانش موجود (مانند بسط نظریات انیشتین). علم بالا نمی‌رود، فقط منبسط می‌شود.</li><li><b>استقرا (Induction)</b>: کشف دانش جدید (مانند نظریه‌های جدید انیشتین).</li></ul></li><li>محدودیت‌ها: این روش خیلی محدود بود و بیشتر به تحلیل می‌پرداخت. اکنون کمتر استفاده می‌شود.</li></ul></li><li><b>اتصال‌گرایان (Connectionists)</b>:<ul><li>شبکه‌های عصبی (Neural Networks) در این دسته قرار می‌گیرند.</li><li>هدفشان شبیه‌سازی مغز انسان بود.</li><li>مدل‌های معروف: پرسپترون‌ها (Perceptrons).</li><li>هوش مصنوعی مدرن (به ویژه شبکه‌های عصبی و یادگیری عمیق) که باعث تحول شده، از این رویکرد نشأت می‌گیرد.</li></ul></li><li><b>تکامل‌گرایان (Evolutionists)</b>:<ul><li>از اصول ژنتیک و عملگرهایی مانند جهش (Mutation) و ترکیب (Crossover) استفاده می‌کنند.</li><li>دارای چهار دسته‌ی کلی هستند.</li></ul></li><li><b>بیزی‌ها (Bayesians)</b>:<ul><li>از علم احتمال و آمار برای پیش‌بینی استفاده می‌کنند.</li><li>دقت بالایی ندارند اما یک \"بیس‌لاین\" (Baseline) بسیار خوب هستند.</li><li>قبل از ظهور یادگیری عمیق، بیشترین طرفدار را داشتند.</li></ul></li><li><b>قیاس‌گرایان (Analogists)</b>:<ul><li>با فرمول‌های کوچک و ساده، داده‌ها را \"متورم\" می‌کنند (به ابعاد بالاتر می‌برند).</li><li>این کار باعث می‌شود عمل تشخیص یا لیبل‌گذاری ساده‌تر شود.</li></ul></li></ol><h2>قضیه‌ی \"No Free Lunch\"</h2><p>این قضیه معروف می‌گوید:</p><ul><li>هر یک از این روش‌ها (پنج دسته) در یک کار خاص یا روی یک نوع خاص از داده‌ها (مثلاً پنج نوع دیتا) عملکرد خوبی دارند.</li><li>اما هیچ روشی وجود ندارد که در همه‌ی کارها و روی همه‌ی انواع داده‌ها به بهترین شکل عمل کند.</li><li>اگر عملکرد و دقت این روش‌ها را در مجموعه‌ای از تسک‌ها میانگین بگیریم، تقریباً همه‌ی آن‌ها عملکرد یکسانی خواهند داشت (مثلاً در حد ۵٪).</li><li>این قضیه بیان می‌کند که هیچ الگوریتم \"جامع و برتری\" وجود ندارد که در همه‌ی مسائل از بقیه بهتر باشد.</li><li><b>نقض قضیه</b>: قضیه \"No Free Lunch\" زمانی نقض می‌شود که بتوانیم یک بستر الگوریتمی ایجاد کنیم که برای یک زمان، مکان و شخص خاص (Similarity) به طور محسوسی از سایر روش‌ها بهتر عمل کند. چنین بستری فعلاً وجود ندارد.</li><li>(به عبارت دیگر، عملکرد آن‌ها روی مسائل مختلف به طور متوسط برابر است.)</li></ul></div></div>','<div style=\"max-width: 100%; overflow-x: hidden; word-wrap: break-word; padding: 1rem; box-sizing: border-box;\"><h1>یادگیری ماشین و هوش مصنوعی: مفاهیم و رویکردها</h1><h2>تعریف الگوریتم‌های یادگیری ماشین</h2><h3>کارهای اصلی الگوریتم‌ها</h3><p>هر الگوریتمی دو کار اصلی انجام می‌دهد:</p><ol><li>جستجو در فضای فرضیه (فضای جواب‌ها).</li><li>انتخاب یک جواب و تأیید آن با اندازه‌گیری کیفیت (دقت، خطا، هزینه) بر اساس معیار (metric) مشخص.</li></ol><h3>ماهیت الگوریتم‌های یادگیری ماشین</h3><p>الگوریتم‌های یادگیری ماشین (ML) اغلب دارای یک هسته‌ی ریاضی هستند. این هسته می‌تواند از یک شرط ساده‌ی If-Then تا میلیون‌ها خط کد ریاضی و فیزیک و مدل‌های پیچیده متغیر باشد.</p><p>نکته مهم این است که پشت این الگوریتم‌ها جادو نیست؛ بلکه مجموعه‌ای از فرمول‌ها و روابط ریاضی قرار دارد.</p><p>این روابط ریاضی به صورت \"هاردکد\" یا از پیش تعیین شده به الگوریتم داده نمی‌شوند.</p><h2>فرایند یادگیری در یک معماری</h2><p>در یک \"معماری\" (Architecture)، الگوریتم می‌آموزد که الگوهای کلی و مشترک را شناسایی کند.</p><p>فرایند یادگیری شامل تکرار عملیات است، تا زمانی که منابع اجازه دهند (Epochs, Iterations).</p><h3>مراحل آموزش مدل</h3><p>مدل وارد فاز آموزش (Training) می‌شود.</p><p>برای هر داده‌ی آموزشی (Train Data) و مجموعه‌ی داده‌های آموزشی:</p><ol><li>مدل، داده‌ی ورودی (Input) و وزن‌های اولیه (Initial Weights) را دریافت می‌کند.</li><li>سپس یک پیش‌بینی (Prediction) انجام می‌دهد.</li><li>میزان خطا یا \"لاس\" (Loss) را با مقایسه بین پیش‌بینی و واقعیت (Ground Truth یا Label) محاسبه می‌کند.</li><li>این مقدار لاس برای اصلاح وزن‌ها در هر چرخه‌ی یادگیری استفاده می‌شود.</li></ol><pre style=\"white-space: pre-wrap !important; word-wrap: break-word !important; overflow-x: auto !important; max-width: 100% !important; padding: 1rem; background-color: #f5f5f5; border-radius: 4px; direction: ltr; font-family: \'Courier New\', monospace; font-size: 0.9em; line-height: 1.5; margin: 1rem 0;\"><code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; display: block; overflow-x: auto; font-family: \'Courier New\', monospace;\">Weight = Update(Loss, Weight)</code></pre><p>این فرآیند به طور مداوم تکرار می‌شود تا وزن‌ها بهینه شوند.</p><h3>مفهوم Overfitting</h3><p>یکی از مشکلات ذاتی و رایج در یادگیری ماشین \"Overfitting\" است. این به این معنی است که مدل به جای یادگیری الگوهای کلی و مشترک، داده‌های آموزشی را حفظ می‌کند.</p><p>در نتیجه، مدل روی داده‌های آموزشی عملکرد بسیار خوبی (مثلاً ۱۰۰٪ دقت) دارد، اما روی داده‌های جدید و ندیده‌شده (که در مجموعه آموزشی نبوده) عملکرد ضعیفی از خود نشان می‌دهد و حدس‌های تصادفی می‌زند. این یک ایراد ذاتی است که باید در تمامی مدل‌ها به آن توجه داشت.</p><h2>دسته‌بندی کلی یادگیری ماشین</h2><p>یادگیری ماشین (Machine Learning) و هوش مصنوعی (AI) در بسیاری از زمینه‌ها کاربرد دارند. هوش مصنوعی یک سرفصل بسیار بالاتر و جامع‌تر از یادگیری ماشین است.</p><h3>دو نوع اصلی یادگیری ماشین</h3><p>یادگیری ماشین به دو نوع کلی تقسیم می‌شود:</p><ol><li><b>تشخیص (Discriminative)</b>: برای شناسایی یک چیز.</li><li><b>تولید (Generative)</b>: برای تولید چیزهای جدید.</li></ol><p>در حوزه‌ی تشخیص، دو نوع تسک (Task) اصلی وجود دارد:</p><ul><li><b>کلاسه‌بندی (Classification/Categorization)</b>: پرکاربردترین نوع (بالای ۹۰٪ مدل‌ها) که به معنای طبقه‌بندی کردن یک شیء یا پیش‌بینی برچسب آن است. این یک تسک قطعی محسوب می‌شود (مثلاً تشخیص نوع حیوان در یک عکس).</li><li><b>تخمین (Estimation)</b>: به معنای پیش‌بینی مقادیر عددی با دقت مشخص (مثلاً پیش‌بینی قیمت خانه).</li></ul><h3>هوش مصنوعی مولد (Generative AI)</h3><p>Generative AI داده‌ها را بررسی می‌کند، الگوهای کلی و مشترک را از آن‌ها استخراج کرده و یاد می‌گیرد.</p><p>سپس با افزودن مقدار کمی \"نویز\" (Noise) هدفمند (نه کاملاً تصادفی)، الگوهای جدیدی را تولید می‌کند. این فرایند تولید، جنبه‌ی \"خلاقیت\" مدل را نمایش می‌دهد، هرچند که هنوز تعریف دقیق و مدل ریاضی کاملی برای خلاقیت در هوش مصنوعی نداریم و تقلید خلاقیت فعلاً بسیار ناقص است.</p><h2>هوش ارگانیک و یادگیری</h2><h3>ویژگی‌های هوش ارگانیک</h3><p>ما تعریف دقیقی از هوش نداریم، اما هوش ارگانیک (انسانی) دارای ویژگی‌های کلیدی است:</p><ul><li><b>ژنوم‌محور (Genetic-driven)</b>: از نسلی به نسل دیگر منتقل می‌شود.</li><li>مفاهیم مشترک جهانی: مثالی از \"اژدها\" زده شد که در اکثر فرهنگ‌ها وجود دارد و تصور مشترکی از آن وجود دارد (بزرگ، دارای آتش، پرواز کننده، خزنده، دارای بال، دهان بزرگ، دندان‌های تیز، پنجه).</li><li>این مفهوم مشترک از تجربیات اجداد ما (مثلاً تهدید توسط حیوانات با این ویژگی‌ها) نشأت گرفته و به صورت نسل به نسل منتقل شده است.</li></ul><h3>یادگیری و تغییرات سخت‌افزاری</h3><p>یادگیری چیست؟ وقتی شما چیزی را یاد می‌گیرید، چه تغییرات سخت‌افزاری در شما رخ می‌دهد؟</p><p>چگونه یک ناظر بیرونی (معلم، استاد یا آزمون‌گیرنده) می‌فهمد که شما چیزی را یاد گرفته‌اید؟</p><p>این مفاهیم در هوش مصنوعی نیز مشابه هستند.</p><h3>ابتکار و اکتشاف (Innovation/Discovery)</h3><p>هوش مصنوعی جدید می‌تواند روابط غیرمنتظره‌ای را که ما نمی‌دانیم، یاد بگیرد. این فرایندها \"خودکار\" هستند.</p><p>یکی از ایرادات هوش مصنوعی این است که نمی‌تواند توضیح دهد که \"چرا\" تصمیمی گرفته یا \"چیزی\" را یاد گرفته است؛ یعنی شفاف نیست.</p><h2>سوگیری (Bias) در یادگیری ماشین</h2><p>دو نوع سوگیری (Bias) وجود دارد:</p><ol><li><b>سوگیری در الگوریتم (Algorithm Bias)</b>: این نوع سوگیری خوب است و به مدل کمک می‌کند تا یاد بگیرد و کار کند.</li><li><b>سوگیری در داده (Data Bias)</b>: این نوع سوگیری بد است. اگر داده‌های آموزشی دارای سوگیری باشند (مثلاً در یک سیستم پیش‌بینی دزد، اکثر دزدان در داده‌های واقعی از یک گروه خاص باشند)، مدل تصمیمات غیرواقعی یا حتی غیراخلاقی خواهد گرفت. در این حالت، مشکل از داده است و باید اصلاح شود.</li></ol><h2>مدل‌های بنیادی (Foundational Models) و تعمیم (Generalization)</h2><h3>مدل‌های بنیادی</h3><p>مدل‌های بنیادی، مدل‌های کلی هستند که دقت بالایی ندارند اما با انواع داده‌ها (بصری، زبانی، متنی) کار می‌کنند.</p><p>مثلاً، یک مدل خاص ممکن است فقط با متن خوب کار کند و با تصویر نه. اما مدل‌های بنیادی توانایی کار با همه‌ی این داده‌ها را دارند، هرچند با دقت حداکثری پایین‌تر.</p><p>کاربرد اصلی آن‌ها این است که می‌توان آن‌ها را برای کاربردهای خاص \"فاین‌تون\" (Fine-tune) کرد.</p><h3>تعمیم (Generalization)</h3><p>مهمترین جنبه‌ی مفید بودن یادگیری، \"تعمیم‌پذیری\" است.</p><p>یعنی مدلی که الگوهای اساسی را از چند مثال آموخته (مثلاً مفهوم جمع با چند مثال عددی)، بتواند آن الگو را به داده‌های جدید و ندیده‌شده (در زمان تست یا امتحان) اعمال کند و به درستی آن‌ها را حل کند.</p><p>هدف از یادگیری این است که بتوان مفاهیم آموخته شده را تعمیم (Generalize) داد.</p><h2>رویکردهای یادگیری ماشین (Learning Paradigms)</h2><p>برای پیدا کردن وزن‌ها و بایاس‌ها در مدل، سه روش یا پارادایم کلی وجود دارد:</p><ol><li><b>یادگیری نظارت‌شده (Supervised Learning)</b>:<ul><li>یادگیری \"با معلم\" است.</li><li>در این روش، جواب‌های درست (Labels) از قبل وجود دارند و معلم (سیستم) آن‌ها را به مدل ارائه می‌دهد.</li><li>بهترین نوع یادگیری برای دستیابی به دقت بالا در مسائل مشخص است.</li><li>کاربردها:<ul><li><b>رگرسیون (Regression)</b>: پیش‌بینی یک عدد حقیقی (مثلاً پیش‌بینی دما).</li><li><b>کلاسه‌بندی (Classification/Categorization)</b>: پیش‌بینی برچسب یا کلاس یک شیء.</li></ul></li><li>تقریباً تمام سیستم‌های هوش مصنوعی که در دسترس عموم هستند، از این روش استفاده می‌کنند.</li></ul></li><li><b>یادگیری بدون نظارت (Unsupervised Learning)</b>:<ul><li>یادگیری \"بدون معلم\" است.</li><li>مدل بدون دریافت جواب‌های درست، سعی می‌کند الگوها و ساختارهای پنهان در داده‌ها را پیدا کند (مثل دانش‌آموزی که خودش کتاب می‌خواند).</li><li>مشکل این روش این است که درستی چیزهایی که مدل یاد گرفته توسط ناظر بیرونی تأیید نمی‌شود.</li><li>کاربردها: خوشه‌بندی (Clustering)، کاهش ابعاد (Dimensionality Reduction).</li><li>اغلب از این روش برای یادگیری الگوهای کلی و ساخت مدل‌های بنیادی استفاده می‌شود. سپس این مدل‌های بنیادی را با استفاده از یادگیری نظارت‌شده \"فاین‌تون\" می‌کنند.</li></ul></li><li><b>یادگیری تقویتی (Reinforcement Learning)</b>:<ul><li>یادگیری \"تشویقی\" است.</li><li>یک عامل (Agent) در یک محیط (Environment) قرار دارد و بر اساس \"سیاست\" (Policy) خود، اقداماتی (Actions) انجام می‌دهد.</li><li>در قبال اقدامات صحیح، پاداش (Reward) دریافت می‌کند و در قبال اقدامات اشتباه، پاداشی دریافت نمی‌کند یا جریمه می‌شود.</li><li>مثال: بازی \"توپ را پیدا کن\" با چشم بسته، که در آن بقیه بازیکنان با تشویق یا عدم تشویق، بازیکن میانی را راهنمایی می‌کنند.</li><li>این نوع یادگیری به طور غیرمستقیم، بدون معلم صریح، الگوهای درست را می‌آموزد.</li><li>بخش اعظم مدل‌های زبانی (چت‌بات‌ها) از این روش استفاده می‌کنند (لایک و دیسلایک کاربران به عنوان پاداش عمل می‌کند).</li><li>روش \"Human Reinforcement Learning\" (Reinforcement Learning با بازخورد انسانی) در این زمینه کاربرد دارد، جایی که یک ناظر انسانی کیفیت پاسخ‌ها را تأیید یا رد می‌کند.</li></ul></li></ol><h2>پنج دسته‌ی اصلی رویکردهای یادگیری ماشین (Five Tribes)</h2><p>با وجود بی‌نهایت فرمول و روش یادگیری ماشین، می‌توان آن‌ها را به پنج دسته‌ی اصلی تقسیم کرد:</p><ol><li><b>نمادگرایان (Symbolists)</b>:<ul><li>تقریباً منقرض شده‌اند.</li><li>معتقد بودند که می‌توان دانش را با زبان و نمادها نمایش داد.</li><li>دو عملیات اصلی داشتند:<ul><li><b>کاهش (Deduction)</b>: بسط دادن دانش موجود (مانند بسط نظریات انیشتین). علم بالا نمی‌رود، فقط منبسط می‌شود.</li><li><b>استقرا (Induction)</b>: کشف دانش جدید (مانند نظریه‌های جدید انیشتین).</li></ul></li><li>محدودیت‌ها: این روش خیلی محدود بود و بیشتر به تحلیل می‌پرداخت. اکنون کمتر استفاده می‌شود.</li></ul></li><li><b>اتصال‌گرایان (Connectionists)</b>:<ul><li>شبکه‌های عصبی (Neural Networks) در این دسته قرار می‌گیرند.</li><li>هدفشان شبیه‌سازی مغز انسان بود.</li><li>مدل‌های معروف: پرسپترون‌ها (Perceptrons).</li><li>هوش مصنوعی مدرن (به ویژه شبکه‌های عصبی و یادگیری عمیق) که باعث تحول شده، از این رویکرد نشأت می‌گیرد.</li></ul></li><li><b>تکامل‌گرایان (Evolutionists)</b>:<ul><li>از اصول ژنتیک و عملگرهایی مانند جهش (Mutation) و ترکیب (Crossover) استفاده می‌کنند.</li><li>دارای چهار دسته‌ی کلی هستند.</li></ul></li><li><b>بیزی‌ها (Bayesians)</b>:<ul><li>از علم احتمال و آمار برای پیش‌بینی استفاده می‌کنند.</li><li>دقت بالایی ندارند اما یک \"بیس‌لاین\" (Baseline) بسیار خوب هستند.</li><li>قبل از ظهور یادگیری عمیق، بیشترین طرفدار را داشتند.</li></ul></li><li><b>قیاس‌گرایان (Analogists)</b>:<ul><li>با فرمول‌های کوچک و ساده، داده‌ها را \"متورم\" می‌کنند (به ابعاد بالاتر می‌برند).</li><li>این کار باعث می‌شود عمل تشخیص یا لیبل‌گذاری ساده‌تر شود.</li></ul></li></ol><h2>قضیه‌ی \"No Free Lunch\"</h2><p>این قضیه معروف می‌گوید:</p><ul><li>هر یک از این روش‌ها (پنج دسته) در یک کار خاص یا روی یک نوع خاص از داده‌ها (مثلاً پنج نوع دیتا) عملکرد خوبی دارند.</li><li>اما هیچ روشی وجود ندارد که در همه‌ی کارها و روی همه‌ی انواع داده‌ها به بهترین شکل عمل کند.</li><li>اگر عملکرد و دقت این روش‌ها را در مجموعه‌ای از تسک‌ها میانگین بگیریم، تقریباً همه‌ی آن‌ها عملکرد یکسانی خواهند داشت (مثلاً در حد ۵٪).</li><li>این قضیه بیان می‌کند که هیچ الگوریتم \"جامع و برتری\" وجود ندارد که در همه‌ی مسائل از بقیه بهتر باشد.</li><li><b>نقض قضیه</b>: قضیه \"No Free Lunch\" زمانی نقض می‌شود که بتوانیم یک بستر الگوریتمی ایجاد کنیم که برای یک زمان، مکان و شخص خاص (Similarity) به طور محسوسی از سایر روش‌ها بهتر عمل کند. چنین بستری فعلاً وجود ندارد.</li><li>(به عبارت دیگر، عملکرد آن‌ها روی مسائل مختلف به طور متوسط برابر است.)</li></ul></div>','completed','2025-10-26 08:22:57','2025-12-03 04:33:26',NULL,NULL,0,NULL,1,NULL),(35,5,1,'مقدمه‌ای بر رمزنگاری کلاسیک و تحلیل رمز','1404-08-03','<div style=\"max-width: 100%; overflow-x: hidden; word-wrap: break-word; padding: 1rem; box-sizing: border-box;\"><div style=\"max-width: 100%; overflow-x: hidden; word-wrap: break-word; padding: 1rem; box-sizing: border-box;\"><h1>مقدمه‌ای بر رمزنگاری و تحلیل رمز</h1><p>جلسه پیش بیشتر در مورد یک سری تعاریف و حوادث مقدماتی بود که با آنها آشنا شدیم. مثلاً اینکه در چه سالی چقدر حملات رخ داده است، و نمودار توضیع حملات که نشان می‌داد با پیشرفته‌تر شدن تجهیزات و ابزارها، دانش مورد نیاز برای هک کمتر و کمتر می‌شود. الان اپلیکیشن‌هایی هستند که رمز وای‌فای را هک می‌کنند و به دانش خاصی نیاز ندارند، اما در گذشته انجام این کارها داستان‌های زیادی پشتش بود. نمودار مهمی هم داشتیم که به صورت ضربدری بود و همین نکته را نشان می‌داد.</p><h2>مفاهیم اولیه رمزنگاری</h2><p>برای امروز، بیشتر در مورد مفاهیم رمزنگاری و رمز کلاسیک صحبت می‌کنیم. یک سری تعاریف و نیازمندی‌های رمزنگاری کلاسیک وجود دارد که آنها را بررسی خواهیم کرد. همچنین دو نوع جانشینی و جایگشتی را توضیح می‌دهیم.</p><ul><li><strong>Plaintext (متن آشکار - P یا TXT):</strong> متن اصلی و رمزنشد1ه.</li><li><strong>Ciphertext (متن رمزشده - C):</strong> متن رمزگذاری شده.</li><li><strong>Cipher (رمز):</strong> الگوریتمی برای تبدیل متن آشکار به متن رمز و برعکس.</li><li><strong>Key (کلید):</strong> مفهومی است که برای تبدیل متن آشکار به رمز و برعکس استفاده می‌شود. کلید یک کار خاصی انجام می‌دهد که متن را به رمز تبدیل می‌کند و بالعکس.</li><li><strong>Encryption (رمزگذاری):</strong> فرآیند تبدیل متن آشکار به متن رمز.</li><li><strong>Decryption (رمزگشایی):</strong> فرآیند تبدیل متن رمز به متن آشکار.</li><li><strong>Cryptography (رمزنگاری):</strong> علم اصول و روش‌های رمزگذاری.</li><li><strong>Cryptanalysis (تحلیل رمز):</strong> علم اصول و روش‌های رمزگشایی متن رمز <strong>بدون اطلاع از کلید</strong>. تحلیلگرها کلاً سعی می‌کنند راه حل یک مسئله یا رمز را پیدا کنند، بدون اینکه کلید یا جواب به آنها داده شود. این کار با استفاده از دانش قبلی و تحلیل ساختار رمز انجام می‌شود (مثلاً توزیع هر حرف چقدر است یا تست کلیدهای معروف). کار تحلیلگر شبیه یک کارآگاه است که با کنار هم گذاشتن اطلاعات مجهول به نتیجه می‌رسد.</li><li><strong>Cryptology (رمزشناسی):</strong> علم حاصل از ترکیب رمزنگاری و تحلیل رمز.</li></ul><h2>انواع رمزنگاری</h2><p>رمزنگاری‌ها به دو دسته متقارن (Symmetric) و نامتقارن (Asymmetric) تقسیم می‌شوند. ما بیشتر در مورد رمزنگاری متقارن صحبت می‌کنیم که همان رمزنگاری معمولی، کلید خصوصی یا تک‌کلیدی است. نکته: رمزنگاری کلید خصوصی در اینجا به معنای تک‌کلیدی است و با مفهوم عمومی-خصوصی (Public-Private Key) در رمزنگاری نامتقارن فرق دارد.</p><ul><li><strong>رمزنگاری متقارن (Symmetric Encryption):</strong> فرستنده و گیرنده از یک کلید مشترک استفاده می‌کنند.</li></ul><h3>چالش انتقال کلید مشترک</h3><p>یکی از چالش‌های رمزنگاری متقارن این است که چطور کلید مشترک را انتقال دهیم. قبلاً در مورد یکی از روش‌های آن صحبت کردیم: <pre style=\"white-space: pre-wrap !important; word-wrap: break-word !important; overflow-x: auto !important; max-width: 100% !important; padding: 1rem; background-color: #f5f5f5; border-radius: 4px; direction: ltr; font-family: \'Courier New\', monospace; font-size: 0.9em; line-height: 1.5; margin: 1rem 0;white-space: pre-wrap !important; word-wrap: break-word !important; overflow-x: auto !important; max-width: 100% !important; padding: 1rem; background-color: #f5f5f5; border-radius: 4px; direction: ltr; font-family: \'Courier New\', monospace; font-size: 0.9em; line-height: 1.5; margin: 1rem 0;\"><code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; display: block; overflow-x: auto; font-family: \'Courier New\', monospace;white-space: pre-wrap !important; word-wrap: break-word !important; display: block; overflow-x: auto; font-family: \'Courier New\', monospace;\">Diffie-Hellman</code></pre>در این روش، با استفاده از یک عدد طبیعی و یک عدد اول خیلی بزرگ، کارهایی انجام می‌دهیم که دو طرف به یک کلید مشترک نهایی می‌رسند. مهم نیست که اعداد واسط هر طرف چه چیزی باشد؛ مهم این است که در نهایت به یک کلید مشترک می‌رسند.</p><h2>روند رمزنگاری متقارن کلاسیک</h2><p>رمزنگاری‌های کلاسیک از نوع متقارن (تک‌کلیدی) هستند و تا قبل از دهه ۷۰ میلادی فقط رمزنگاری متقارن داشتیم. روند کار بسیار ساده است:</p><ol><li>یک متن آشکار (Plaintext) دریافت می‌کنیم.</li><li>با استفاده از کلید، عملیات رمزگذاری (Encryption) روی آن انجام می‌دهیم.</li><li>متن رمز شده (Ciphertext) را از طریق بستر اینترنت یا هر جای دیگری انتقال می‌دهیم، چون رمز شده است و نگران این نیستیم که کسی آن را بخواند.</li><li>گیرنده با استفاده از همان کلیدی که قبلاً به او رسیده (مثلاً با روش Diffie-Hellman)، متن رمز شده را رمزگشایی (Decryption) می‌کند و به متن آشکار اصلی می‌رسد.</li></ol><ul><li><strong>Plaintext (X):</strong> متن آشکار ورودی.</li><li><strong>Encryption function (E):</strong> الگوریتم رمزگذاری.</li><li><strong>Key (K):</strong> کلید مشترک.</li><li><strong>Ciphertext (Y):</strong> متن رمز شده خروجی.</li></ul><p>نمادگذاری: <pre style=\"white-space: pre-wrap !important; word-wrap: break-word !important; overflow-x: auto !important; max-width: 100% !important; padding: 1rem; background-color: #f5f5f5; border-radius: 4px; direction: ltr; font-family: \'Courier New\', monospace; font-size: 0.9em; line-height: 1.5; margin: 1rem 0;white-space: pre-wrap !important; word-wrap: break-word !important; overflow-x: auto !important; max-width: 100% !important; padding: 1rem; background-color: #f5f5f5; border-radius: 4px; direction: ltr; font-family: \'Courier New\', monospace; font-size: 0.9em; line-height: 1.5; margin: 1rem 0;\"><code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; display: block; overflow-x: auto; font-family: \'Courier New\', monospace;white-space: pre-wrap !important; word-wrap: break-word !important; display: block; overflow-x: auto; font-family: \'Courier New\', monospace;\">Y = E(K, X)</code></pre>برای رمزگشایی: <pre style=\"white-space: pre-wrap !important; word-wrap: break-word !important; overflow-x: auto !important; max-width: 100% !important; padding: 1rem; background-color: #f5f5f5; border-radius: 4px; direction: ltr; font-family: \'Courier New\', monospace; font-size: 0.9em; line-height: 1.5; margin: 1rem 0;white-space: pre-wrap !important; word-wrap: break-word !important; overflow-x: auto !important; max-width: 100% !important; padding: 1rem; background-color: #f5f5f5; border-radius: 4px; direction: ltr; font-family: \'Courier New\', monospace; font-size: 0.9em; line-height: 1.5; margin: 1rem 0;\"><code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; display: block; overflow-x: auto; font-family: \'Courier New\', monospace;white-space: pre-wrap !important; word-wrap: break-word !important; display: block; overflow-x: auto; font-family: \'Courier New\', monospace;\">X = D(K, Y)</code></pre></p><h2>نیازمندی‌های رمزنگاری</h2><p>برای اینکه یک چیز را رمز کنیم، چه چیزهایی لازم داریم؟</p><ul><li><strong>متن آشکار:</strong> همان متنی که قرار است رمز شود.</li><li><strong>الگوریتم رمزگذاری:</strong> (و الگوریتم رمزگشایی)</li><li><strong>کلید:</strong> کلیدی که فقط فرستنده و گیرنده از آن آگاه باشند.</li></ul><p>الگوریتم‌های رمزنگاری معمولاً برای همه مشخص هستند، یعنی محدود نیستند و همه از آنها باخبرند. مهم، همان کلید است که نباید کسی آن را داشته باشد. بنابراین نیاز به یک کانال امن برای توضیح (توزیع) کلید هست، که باز هم همان روش Diffie-Hellman یکی از روش‌های آن است.</p><h2>ابعاد رمزنگاری (در رمزنگاری متقارن)</h2><p>رمزنگاری متقارن (کلاسیک) به دو صورت انجام می‌شود:</p><ol><li><strong>بلوکی (Block Cipher):</strong> متن را به صورت بلوک‌به‌بلوک (مثلاً جمله به جمله) رمز می‌کند.</li><li><strong>جریانی (Stream Cipher):</strong> متن را به صورت کاراکتربه‌کاراکتر (مثلاً تک‌حرفی) رمز می‌کند.</li></ol><h2>حملات تحلیل رمزنگاری</h2><p>هدف از حمله به رمزنگاری چیست؟</p><ol><li>کلید را بفهمند چیست.</li><li>متن اصلی که رمز شده، چه بوده است.</li></ol><h3>انواع حملات بر اساس دانش مهاجم</h3><p>حمله به رمزنگاری روش‌های مختلفی دارد که مهاجم چقدر اطلاعات اولیه دارد:</p><ol><li><strong>Ciphertext-only attack (حمله فقط متن رمزشده):</strong> مهاجم فقط الگوریتم رمز و متن رمز شده را دارد. این سخت‌ترین نوع حمله است.</li><li><strong>Known-plaintext attack (حمله متن آشکار معلوم):</strong> مهاجم الگوریتم رمز و یک یا چند متن آشکار و رمز شده متناظر با آن را دارد. این به مهاجم کمک می‌کند تا الگوها را تشخیص دهد.</li><li><strong>Chosen-plaintext attack (حمله متن آشکار انتخابی):</strong> مهاجم الگوریتم رمز و متن رمز شده را دارد، اما علاوه بر آن، می‌تواند متن آشکار انتخابی خودش را برای رمزگذاری به سیستم بدهد و متن رمز شده آن را مشاهده کند. این دست تحلیلگر را برای حمله بسیار بازتر می‌کند و کار را راحت‌تر می‌کند.</li><li><strong>Chosen-ciphertext attack (حمله متن رمز انتخابی):</strong> مهاجم الگوریتم رمز و متن رمز شده را دارد، اما علاوه بر آن، می‌تواند متن رمز انتخابی خودش را برای رمزگشایی به سیستم بدهد و متن آشکار آن را مشاهده کند.</li></ol><h3>انواع حملات</h3><p>برای شکستن رمز، روش‌های زیر وجود دارد:</p><ol><li><strong>Brute-force attack (حمله جستجوی فراگیر):</strong> حمله Brute-force به این معنی است که همه حالت‌های ممکن را برای کلید امتحان کنیم. مثلاً اگر رمز یک سامانه یک عدد سه رقمی فقط شامل ارقام بدون تکرار باشد، تعداد حالت‌ها 10 * 9 * 8 = 720 حالت است. این حمله برای کلیدهای کوتاه (مانند کلید 56 بیتی DES) امکان‌پذیر است، اما برای کلیدهای طولانی‌تر (مانند 128 یا 168 بیتی در AES یا 3DES) عملاً غیرممکن است و زمان بسیار زیادی می‌برد.</li><li><strong>Frequency analysis (تحلیل فرکانسی):</strong> بررسی توزیع فراوانی حروف در متن رمز شده (در رمزنگاری جانشینی).</li><li><strong>Kasiski examination (آزمون کاسیسکی):</strong> این آزمون بر پایه مشاهده تکرار توالی سه حرف یا بیشتر در متن رمز شده است. فاصله بین این توالی‌ها معمولاً مضربی از طول کلید است و می‌تواند در شناسایی طول کلید (به ویژه در رمزنگاری‌های جانشینی چند الفبایی) کمک کند.</li></ol><h2>امنیت در رمزنگاری</h2><h3>امنیت مطلق (Unconditional Security)</h3><p>امنیت مطلق به این معنی است که رمز مستقل از قدرت محاسباتی مهاجم، قابل شکستن نباشد. یعنی حتی اگر دشمن منابع محاسباتی نامحدودی داشته باشد، باز هم نتواند رمز را بشکند. این نوع امنیت در عمل برای اغلب سیستم‌های رمزنگاری غیرممکن است.</p><h3>امنیت محاسباتی (Computational Security)</h3><p>امنیت محاسباتی به این معنی است که رمز با داشتن منابع محاسباتی محدود (از نظر زمان و دسترسی)، قابل شکستن نباشد. یعنی اگر با منابع موجود (مثلاً 20 سال زمان) نتوان رمز را شکست، آن رمز از نظر محاسباتی امن تلقی می‌شود.</p><h2>رمزنگاری کلاسیک</h2><p>رمزنگاری کلاسیک که از جنگ جهانی دوم به بعد مورد استفاده قرار گرفت و قبل از کامپیوترها به صورت دستی انجام می‌شد، عمدتاً بر دو روش اصلی استوار است:</p><ol><li><strong>Substitution Cipher (رمز جانشینی):</strong></li><ul><li>در این روش، جای هر حرف یک حرف دیگر می‌آید.</li><li><strong>تک‌الفبایی (Monoalphabetic):</strong> هر حرف همیشه با یک حرف ثابت دیگر جایگزین می‌شود (مثل رمز سزار).</li><ul><li><strong>رمز سزار (Caesar Cipher):</strong> یک نوع رمز جانشینی تک‌الفبایی است که در آن هر حرف با حرفی که به تعداد ثابت (مثلاً 3 واحد) پس از آن در الفبا قرار دارد، جایگزین می‌شود. شکستن آن با حمله جستجوی فراگیر (Brute-force) بسیار ساده است (حداکثر 25 حالت).</li><li>این نوع رمزنگاری به تحلیل فرکانسی آسیب‌پذیر است، زیرا حتی اگر حرف S با Q جایگزین شود، فراوانی Q در متن رمز شده، همان فراوانی S در متن آشکار خواهد بود و تحلیلگر می‌تواند آن را حدس بزند.</li></ul><li><strong>چندالفبایی (Polyalphabetic):</strong> از چند کلید (به صورت چرخشی) برای جایگزینی حروف استفاده می‌کند، که تحلیل فرکانسی را دشوارتر می‌کند (مثلاً رمز ویژنر).</li></ul><li><strong>Transposition Cipher (رمز جایگشتی):</strong></li><ul><li>در این روش، حروف جابجا می‌شوند و جایگاه‌شان تغییر می‌کند.</li><li>شکستن رمز جایگشتی با تحلیل فرکانسی سخت‌تر است، زیرا فراوانی حروف تغییر نمی‌کند و فقط ترتیب آن‌ها به هم می‌ریزد. برای شکستن آن، تکنیک‌هایی لازم است که بتواند موقعیت‌های اصلی حروف را حدس بزند.</li></ul></ol><h2>مطالعه تکمیلی</h2><p>برای جلسه بعد، روش <pre style=\"white-space: pre-wrap !important; word-wrap: break-word !important; overflow-x: auto !important; max-width: 100% !important; padding: 1rem; background-color: #f5f5f5; border-radius: 4px; direction: ltr; font-family: \'Courier New\', monospace; font-size: 0.9em; line-height: 1.5; margin: 1rem 0;white-space: pre-wrap !important; word-wrap: break-word !important; overflow-x: auto !important; max-width: 100% !important; padding: 1rem; background-color: #f5f5f5; border-radius: 4px; direction: ltr; font-family: \'Courier New\', monospace; font-size: 0.9em; line-height: 1.5; margin: 1rem 0;\"><code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; display: block; overflow-x: auto; font-family: \'Courier New\', monospace;white-space: pre-wrap !important; word-wrap: break-word !important; display: block; overflow-x: auto; font-family: \'Courier New\', monospace;\">Kasiski</code></pre> را مطالعه کنید و ببینید چگونه کار می‌کند و سازوکارش چیست. اگر حوصله نداشتید، اشکال ندارد، اما برای کسانی که علاقه‌مند هستند می‌تواند جذاب باشد.</p><p>یک نوع رمزنگاری دیگر نیز وجود دارد که من خودم خیلی با آن ارتباط برقرار نمی‌کنم. در این روش، فاصله تکرار یک کلمه سه حرفی را بررسی می‌کنند. مثلاً در متنی که رمز شده، یک کلمه سه حرفی را پیدا می‌کنند و می‌بینند چند بار تکرار شده و فاصله‌ی این تکرارها چقدر است. سپس ادعا می‌کنند که این فاصله به طول کلید بخش‌پذیر است. چرا بخش‌پذیر است؟ خودم خوب درک نکرده‌ام، اما این یکی از کارهایی است که برای حمله انجام می‌دهند. این روش بسیار طولانی و مفصل است.</p></div></div>',NULL,'completed','2025-10-29 03:46:50','2025-12-03 04:33:26',NULL,NULL,0,NULL,1,NULL),(36,1,1,'مفاهیم پیشرفته شی‌گرایی — حافظه Stack و Heap، Polymorphism و کلاس‌های Abstract','1404/08/11','<div style=\"max-width: 100%; overflow-x: hidden; word-wrap: break-word; padding: 1rem; box-sizing: border-box;\"><div style=\"max-width: 100%; overflow-x: hidden; word-wrap: break-word; padding: 1rem; box-sizing: border-box;\"><h1>مفاهیم پیشرفته شی‌گرایی: حافظه Stack و Heap، Polymorphism و کلاس‌های Abstract</h1><p>در این جلسه به بررسی مفاهیم پیشرفته شی‌گرایی، مدیریت حافظه در برنامه‌نویسی و نحوه کار با کلاس‌های Abstract و Interface می‌پردازیم.</p><h2>ممنوعیت ساخت شی از کلاس‌های Abstract و Interface</h2><ul><li>از کلاس‌های <b>Abstract</b> و <b>Interface</b> نمی‌توان به طور مستقیم شی (Object) ساخت.</li><li>این موضوع یکی از نکات مهمی است که باید در طراحی و پیاده‌سازی کلاس‌ها مورد توجه قرار گیرد.</li></ul><h2>مفهوم Polymorphism (چندریختی)</h2><p>Polymorphism به این معناست که در سمت راست عملیات ساخت شی (instantiation)، می‌توان از کلاس معادل یا یکی از کلاس‌های فرزند استفاده کرد. به عنوان مثال:</p><pre style=\"white-space: pre-wrap !important; word-wrap: break-word !important; overflow-x: auto !important; max-width: 100% !important; padding: 1rem; background-color: #f5f5f5; border-radius: 4px; direction: ltr; font-family: \'Courier New\', monospace; font-size: 0.9em; line-height: 1.5; margin: 1rem 0;white-space: pre-wrap !important; word-wrap: break-word !important; overflow-x: auto !important; max-width: 100% !important; padding: 1rem; background-color: #f5f5f5; border-radius: 4px; direction: ltr; font-family: \'Courier New\', monospace; font-size: 0.9em; line-height: 1.5; margin: 1rem 0;\"><code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; display: block; overflow-x: auto; font-family: \'Courier New\', monospace;white-space: pre-wrap !important; word-wrap: break-word !important; display: block; overflow-x: auto; font-family: \'Courier New\', monospace;\">Class A { ... }<br/>Class B extends A { ... }<br/><br/>A a = new A(); // صحیح<br/>B b = new B(); // صحیح<br/>A obj = new B(); // صحیح (Polymorphism)</code></pre><p>هر آنچه که در سمت راست قرار می‌گیرد، یا باید برابر با نوع سمت چپ باشد یا فرزند آن نوع باشد.</p><h2>تفاوت حافظه Stack و Heap</h2><p>یکی از مباحث مهم در برنامه‌نویسی، نحوه ذخیره‌سازی داده‌ها در حافظه است. دو نوع اصلی حافظه مورد استفاده شامل Stack و Heap است:</p><ul><li><b>سمت چپ (Reference):</b> در هنگام تعریف یک متغیر یا شی، سمت چپ به عنوان یک مرجع (Reference) در حافظه Stack قرار می‌گیرد.</li><li><b>سمت راست (Object Creation/Value):</b> سمت راست مسئول ساخت شی یا ذخیره مقدار واقعی است.</li></ul><h3>مقایسه Stack و Heap</h3><p>برخی از تفاوت‌های کلیدی بین Stack و Heap عبارتند از:</p><ul><li><h4>Stack</h4><ul><li><b>نوع حافظه:</b> استاتیک (Static)</li><li><b>مدیریت:</b> خودکار (Automatic)، مدیریت آنی (instantaneous)</li><li><b>سرعت:</b> سریع‌تر</li><li><b>ماندگاری:</b> کمتر (اطلاعات با پایان یافتن Scope حذف می‌شوند)</li><li><b>محتوا:</b> معمولا مقادیر مستقیم (برای Value Types) یا آدرس (Reference) به فضای Heap (برای Reference Types) را ذخیره می‌کند.</li><li><b>دسترسی:</b> LIFO (Last-In, First-Out) - آخرین داده وارد شده، اولین داده خارج شده است.</li><li><b>هدف:</b> برای ردیابی توابع (Function Calls) استفاده می‌شود.</li></ul></li><li><h4>Heap</h4><ul><li><b>نوع حافظه:</b> پویا (Dynamic)</li><li><b>مدیریت:</b> قابل کنترل‌تر توسط برنامه‌نویس یا توسط Garbage Collector (GC)</li><li><b>سرعت:</b> کندتر</li><li><b>ماندگاری:</b> بیشتر (اطلاعات تا زمانی که به آن‌ها ارجاعی وجود دارد باقی می‌مانند)</li><li><b>محتوا:</b> داده‌های واقعی اشیاء (Object Data) را ذخیره می‌کند.</li><li><b>دسترسی:</b> دسترسی غیر ترتیبی (Random Access)</li></ul></li></ul><h3>ذخیره‌سازی Value Types و Reference Types</h3><ul><li><h4>Value Types</h4><ul><li>مانند `int`، `boolean`، `char` و غیره.</li><li>این مقادیر مستقیماً در حافظه Stack ذخیره می‌شوند.</li><li>مثال: `int a = 5;` مقدار `5` مستقیماً در Stack ذخیره می‌شود.</li></ul></li><li><h4>Reference Types</h4><ul><li>مانند اشیاء (Objects) از کلاس‌ها.</li><li>این اشیاء به صورت \'جعبه\'هایی از داده‌ها (Properties و Method Names) در حافظه Heap ذخیره می‌شوند.</li><li>یک آدرس (Reference) از محل ذخیره شی در Heap، در حافظه Stack ذخیره می‌شود.</li><li>دسترسی به شی در Heap از طریق این آدرس در Stack انجام می‌شود.</li><li>این فرآیند ذخیره‌سازی دو مرحله‌ای است: <ul><li>آدرس در Stack</li><li>داده‌های واقعی شی در Heap</li></ul></li></ul></li></ul><h2>مدیریت حافظه (Garbage Collector)</h2><p>در زبان‌هایی مانند Java، مدیریت حافظه Heap توسط Garbage Collector (GC) انجام می‌شود.</p><ul><li><b>وظیفه GC:</b> GC اشیائی را که دیگر در Heap به آن‌ها ارجاعی وجود ندارد (یا به اصطلاح \"زباله\" شده‌اند) شناسایی کرده و حافظه آن‌ها را آزاد می‌کند.</li><li><b>اهمیت:</b> GC یک ویژگی مهم در زبان‌های مدرن است که نیاز به مدیریت دستی حافظه را از بین می‌برد. در زبان‌هایی که GC ندارند (مانان C++), برنامه‌نویس باید با دستوراتی مانند `delete` حافظه را به صورت دستی مدیریت کند.</li><li><b>مضرات:</b> ساخت تعداد زیادی شیء غیرضروری می‌تواند حافظه Heap را اشغال کرده و عملکرد برنامه را تحت تأثیر قرار دهد، زیرا حافظه Heap گران‌تر است و دسترسی به آن کندتر.</li></ul><h2>نحوه کار با Abstract Class و Interface</h2><h3>کلاس‌های Abstract</h3><p>یک کلاس Abstract کلاسی است که می‌تواند شامل متدهای Abstract (بدون پیاده‌سازی) و متدهای Concrete (با پیاده‌سازی کامل) باشد.</p><ul><li><b>تعریف:</b> برای تعریف یک کلاس Abstract، از کلمه کلیدی `abstract` استفاده می‌شود.</li><li><b>متد Abstract:</b> اگر یک متد در کلاس Abstract بدون بدنه باشد، باید با کلمه کلیدی `abstract` تعریف شود و کلاس نیز باید Abstract باشد.</li><li><b>ایجاد شی:</b> نمی‌توان مستقیماً از یک کلاس Abstract شی ساخت. تلاش برای `new AbstractClass()` منجر به خطا می‌شود.</li><li><b>ارث‌بری:</b> برای استفاده از یک کلاس Abstract، باید یک کلاس Concrete از آن ارث‌بری (extends) کند.</li><li><b>پیاده‌سازی:</b> کلاس فرزند Concrete <b>باید</b> تمامی متدهای Abstract کلاس پدر را پیاده‌سازی (override) کند. در غیر این صورت، کلاس فرزند نیز باید Abstract شود.</li><li><b>رفرنس:</b> می‌توان از یک کلاس Abstract رفرنس تعریف کرد (مثال: `AbstractClass obj;` بدون خطا است). این رفرنس می‌تواند به یک شی از کلاس فرزند Concrete اشاره کند.</li></ul><h3>مثال عملی با Abstract Class</h3><pre style=\"white-space: pre-wrap !important; word-wrap: break-word !important; overflow-x: auto !important; max-width: 100% !important; padding: 1rem; background-color: #f5f5f5; border-radius: 4px; direction: ltr; font-family: \'Courier New\', monospace; font-size: 0.9em; line-height: 1.5; margin: 1rem 0;white-space: pre-wrap !important; word-wrap: break-word !important; overflow-x: auto !important; max-width: 100% !important; padding: 1rem; background-color: #f5f5f5; border-radius: 4px; direction: ltr; font-family: \'Courier New\', monospace; font-size: 0.9em; line-height: 1.5; margin: 1rem 0;\"><code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; display: block; overflow-x: auto; font-family: \'Courier New\', monospace;white-space: pre-wrap !important; word-wrap: break-word !important; display: block; overflow-x: auto; font-family: \'Courier New\', monospace;\">// Abstract Class<br/>abstract class A {<br/>    public abstract void show(); // Abstract method<br/>    public void go() { // Concrete method<br/>        System.out.println(\"Going...\");<br/>    }<br/>}<br/><br/>// Concrete Class inheriting from A<br/>class B extends A {<br/>    @Override<br/>    public void show() { // Implementation of abstract method<br/>        System.out.println(\"Showing from B\");<br/>    }<br/>}<br/><br/>// Main Method<br/>public class Main {<br/>    public static void main(String[] args) {<br/>        // A obj = new A(); // ERROR: Cannot instantiate abstract class A<br/>        A obj; // Correct: Declaring a reference of type A<br/>        <br/>        B b = new B(); // Correct: Instantiating concrete class B<br/>        b.show(); // Output: Showing from B<br/>        b.go(); // Output: Going...<br/>        <br/>        obj = b; // Polymorphism: Reference of A pointing to object of B<br/>        obj.show(); // Output: Showing from B<br/>    }<br/>}</code></pre><h3>نکات تکمیلی</h3><ul><li><b>Constructor در Abstract Class:</b> کلاس‌های Abstract می‌توانند Constructor داشته باشند، اما این Constructor فقط توسط کلاس‌های فرزند هنگام ساخت شیء قابل فراخوانی است (و نه مستقیماً برای خود کلاس Abstract).</li><li><b>تفاوت با Interface:</b> تفاوت اصلی کلاس‌های Abstract با Interface در این است که کلاس‌های Abstract می‌توانند متدهای Concrete (با پیاده‌سازی) داشته باشند، در حالی که Interfaceها در نسخه‌های قدیمی‌تر زبان‌ها فقط متدهای Abstract داشتند (بدون پیاده‌سازی) و در نسخه‌های جدیدتر امکان داشتن متدهای default و static را نیز پیدا کرده‌اند.</li></ul>\",\n  \"keywords\": [\n    \"Abstract Classes\",\n    \"Interfaces\",\n    \"Polymorphism\",\n    \"Stack Memory\",\n    \"Heap Memory\",\n    \"Garbage Collector\",\n    \"Value Types\",\n    \"Reference Types</div></div>','<h1>مفاهیم پیشرفته شی‌گرایی: حافظه Stack و Heap، Polymorphism و کلاس‌های Abstract</h1><p>در این جلسه به بررسی مفاهیم پیشرفته شی‌گرایی، مدیریت حافظه در برنامه‌نویسی و نحوه کار با کلاس‌های Abstract و Interface می‌پردازیم.</p><h2>ممنوعیت ساخت شی از کلاس‌های Abstract و Interface</h2><ul><li>از کلاس‌های <strong>Abstract</strong> و <strong>Interface</strong> نمی‌توان به طور مستقیم شی (Object) ساخت.</li><li>این موضوع یکی از نکات مهمی است که باید در طراحی و پیاده‌سازی کلاس‌ها مورد توجه قرار گیرد.</li></ul><h2>مفهوم Polymorphism (چندریختی)</h2><p>Polymorphism به این معناست که در سمت راست عملیات ساخت شی (instantiation)، می‌توان از کلاس معادل یا یکی از کلاس‌های فرزند استفاده کرد. به عنوان مثال:</p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">Class A { ... }\nClass B extends A { ... }\n\nA a = new A(); // صحیح\nB b = new B(); // صحیح\nA obj = new B(); // صحیح (Polymorphism)\n</pre><p>هر آنچه که در سمت راست قرار می‌گیرد، یا باید برابر با نوع سمت چپ باشد یا فرزند آن نوع باشد.</p><h2>تفاوت حافظه Stack و Heap</h2><p>یکی از مباحث مهم در برنامه‌نویسی، نحوه ذخیره‌سازی داده‌ها در حافظه است. دو نوع اصلی حافظه مورد استفاده شامل Stack و Heap است:</p><ul><li><strong>سمت چپ (Reference):</strong> در هنگام تعریف یک متغیر یا شی، سمت چپ به عنوان یک مرجع (Reference) در حافظه Stack قرار می‌گیرد.</li><li><strong>سمت راست (Object Creation/Value):</strong> سمت راست مسئول ساخت شی یا ذخیره مقدار واقعی است.</li></ul><h3>مقایسه Stack و Heap</h3><p>برخی از تفاوت‌های کلیدی بین Stack و Heap عبارتند از:</p><h4>Stack</h4><ul><li class=\"ql-indent-1\"><strong>نوع حافظه:</strong> استاتیک (Static)</li><li class=\"ql-indent-1\"><strong>مدیریت:</strong> خودکار (Automatic)، مدیریت آنی (instantaneous)</li><li class=\"ql-indent-1\"><strong>سرعت:</strong> سریع‌تر</li><li class=\"ql-indent-1\"><strong>ماندگاری:</strong> کمتر (اطلاعات با پایان یافتن Scope حذف می‌شوند)</li><li class=\"ql-indent-1\"><strong>محتوا:</strong> معمولا مقادیر مستقیم (برای Value Types) یا آدرس (Reference) به فضای Heap (برای Reference Types) را ذخیره می‌کند.</li><li class=\"ql-indent-1\"><strong>دسترسی:</strong> LIFO (Last-In, First-Out) - آخرین داده وارد شده، اولین داده خارج شده است.</li><li class=\"ql-indent-1\"><strong>هدف:</strong> برای ردیابی توابع (Function Calls) استفاده می‌شود.</li></ul><h4>Heap</h4><ul><li class=\"ql-indent-1\"><strong>نوع حافظه:</strong> پویا (Dynamic)</li><li class=\"ql-indent-1\"><strong>مدیریت:</strong> قابل کنترل‌تر توسط برنامه‌نویس یا توسط Garbage Collector (GC)</li><li class=\"ql-indent-1\"><strong>سرعت:</strong> کندتر</li><li class=\"ql-indent-1\"><strong>ماندگاری:</strong> بیشتر (اطلاعات تا زمانی که به آن‌ها ارجاعی وجود دارد باقی می‌مانند)</li><li class=\"ql-indent-1\"><strong>محتوا:</strong> داده‌های واقعی اشیاء (Object Data) را ذخیره می‌کند.</li><li class=\"ql-indent-1\"><strong>دسترسی:</strong> دسترسی غیر ترتیبی (Random Access)</li></ul><h3>ذخیره‌سازی Value Types و Reference Types</h3><h4>Value Types</h4><ul><li class=\"ql-indent-1\">مانند `int`، `boolean`، `char` و غیره.</li><li class=\"ql-indent-1\">این مقادیر مستقیماً در حافظه Stack ذخیره می‌شوند.</li><li class=\"ql-indent-1\">مثال: `int a = 5;` مقدار `5` مستقیماً در Stack ذخیره می‌شود.</li></ul><h4>Reference Types</h4><ul><li class=\"ql-indent-1\">مانند اشیاء (Objects) از کلاس‌ها.</li><li class=\"ql-indent-1\">این اشیاء به صورت \'جعبه\'هایی از داده‌ها (Properties و Method Names) در حافظه Heap ذخیره می‌شوند.</li><li class=\"ql-indent-1\">یک آدرس (Reference) از محل ذخیره شی در Heap، در حافظه Stack ذخیره می‌شود.</li><li class=\"ql-indent-1\">دسترسی به شی در Heap از طریق این آدرس در Stack انجام می‌شود.</li><li>این فرآیند ذخیره‌سازی دو مرحله‌ای است:</li><li class=\"ql-indent-2\">آدرس در Stack</li><li class=\"ql-indent-1\">داده‌های واقعی شی در Heap</li></ul><h2>مدیریت حافظه (Garbage Collector)</h2><p>در زبان‌هایی مانند Java، مدیریت حافظه Heap توسط Garbage Collector (GC) انجام می‌شود.</p><ul><li><strong>وظیفه GC:</strong> GC اشیائی را که دیگر در Heap به آن‌ها ارجاعی وجود ندارد (یا به اصطلاح \"زباله\" شده‌اند) شناسایی کرده و حافظه آن‌ها را آزاد می‌کند.</li><li><strong>اهمیت:</strong> GC یک ویژگی مهم در زبان‌های مدرن است که نیاز به مدیریت دستی حافظه را از بین می‌برد. در زبان‌هایی که GC ندارند (مانان C++), برنامه‌نویس باید با دستوراتی مانند `delete` حافظه را به صورت دستی مدیریت کند.</li><li><strong>مضرات:</strong> ساخت تعداد زیادی شیء غیرضروری می‌تواند حافظه Heap را اشغال کرده و عملکرد برنامه را تحت تأثیر قرار دهد، زیرا حافظه Heap گران‌تر است و دسترسی به آن کندتر.</li></ul><h2>نحوه کار با Abstract Class و Interface</h2><h3>کلاس‌های Abstract</h3><p>یک کلاس Abstract کلاسی است که می‌تواند شامل متدهای Abstract (بدون پیاده‌سازی) و متدهای Concrete (با پیاده‌سازی کامل) باشد.</p><ul><li><strong>تعریف:</strong> برای تعریف یک کلاس Abstract، از کلمه کلیدی `abstract` استفاده می‌شود.</li><li><strong>متد Abstract:</strong> اگر یک متد در کلاس Abstract بدون بدنه باشد، باید با کلمه کلیدی `abstract` تعریف شود و کلاس نیز باید Abstract باشد.</li><li><strong>ایجاد شی:</strong> نمی‌توان مستقیماً از یک کلاس Abstract شی ساخت. تلاش برای `new AbstractClass()` منجر به خطا می‌شود.</li><li><strong>ارث‌بری:</strong> برای استفاده از یک کلاس Abstract، باید یک کلاس Concrete از آن ارث‌بری (extends) کند.</li><li><strong>پیاده‌سازی:</strong> کلاس فرزند Concrete <strong>باید</strong> تمامی متدهای Abstract کلاس پدر را پیاده‌سازی (override) کند. در غیر این صورت، کلاس فرزند نیز باید Abstract شود.</li><li><strong>رفرنس:</strong> می‌توان از یک کلاس Abstract رفرنس تعریف کرد (مثال: `AbstractClass obj;` بدون خطا است). این رفرنس می‌تواند به یک شی از کلاس فرزند Concrete اشاره کند.</li></ul><h3>مثال عملی با Abstract Class</h3><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">// Abstract Class\nabstract class A {\n    public abstract void show(); // Abstract method\n    public void go() { // Concrete method\n        System.out.println(\"Going...\");\n    }\n}\n\n// Concrete Class inheriting from A\nclass B extends A {\n    @Override\n    public void show() { // Implementation of abstract method\n        System.out.println(\"Showing from B\");\n    }\n}\n\n// Main Method\npublic class Main {\n    public static void main(String[] args) {\n        // A obj = new A(); // ERROR: Cannot instantiate abstract class A\n        A obj; // Correct: Declaring a reference of type A\n        \n        B b = new B(); // Correct: Instantiating concrete class B\n        b.show(); // Output: Showing from B\n        b.go(); // Output: Going...\n        \n        obj = b; // Polymorphism: Reference of A pointing to object of B\n        obj.show(); // Output: Showing from B\n    }\n}\n</pre><h3>نکات تکمیلی</h3><ul><li><strong>Constructor در Abstract Class:</strong> کلاس‌های Abstract می‌توانند Constructor داشته باشند، اما این Constructor فقط توسط کلاس‌های فرزند هنگام ساخت شیء قابل فراخوانی است (و نه مستقیماً برای خود کلاس Abstract).</li><li><strong>تفاوت با Interface:</strong> تفاوت اصلی کلاس‌های Abstract با Interface در این است که کلاس‌های Abstract می‌توانند متدهای Concrete (با پیاده‌سازی) داشته باشند، در حالی که Interfaceها در نسخه‌های قدیمی‌تر زبان‌ها فقط متدهای Abstract داشتند (بدون پیاده‌سازی) و در نسخه‌های جدیدتر امکان داشتن متدهای default و static را نیز پیدا کرده‌اند.</li></ul><p>\", \"keywords\": [ \"Abstract Classes\", \"Interfaces\", \"Polymorphism\", \"Stack Memory\", \"Heap Memory\", \"Garbage Collector\", \"Value Types\", \"Reference Types</p>','completed','2025-11-04 08:51:20','2025-12-06 19:31:39',NULL,NULL,0,NULL,1,NULL),(37,5,1,'روش‌های رمزنگاری کلاسیک','2025-11-07','<div style=\"max-width: 100%; overflow-x: hidden; word-wrap: break-word; padding: 1rem; box-sizing: border-box;\"><div style=\"max-width: 100%; overflow-x: hidden; word-wrap: break-word; padding: 1rem; box-sizing: border-box;\"><h1>مقدمه‌ای بر روش‌های رمزنگاری</h1><h2>رمزنگاری تک الفبایی (Monoalphabetic Cipher)</h2><p>این روش یک حرف را با یک حرف دیگر جایگزین می‌کند. به عنوان مثال، در یک رمزنگاری شیفت، هر حرف به اندازه مشخصی (مثلاً ۵ حرف) در الفبا جابجا می‌شود. اگر حرف ‘الف’ به ‘د’ تبدیل شود، در کل متن هر ‘الف’ به ‘د’ تبدیل خواهد شد.</p><h2>رمزنگاری چند الفبایی (Polyalphabetic Cipher)</h2><p>در این روش، به جای یک شیفت ثابت، از یک دنباله از شیفت‌ها استفاده می‌شود. این دنباله به صورت چرخشی تکرار می‌شود.</p><h3>مثال: رمزنگاری با کلید ۲-۱-۳</h3><ul><li>حرف اول: ۲ واحد به جلو</li><li>حرف دوم: ۱ واحد به جلو</li><li>حرف سوم: ۳ واحد به جلو</li><li>حرف چهارم: ۲ واحد به جلو (تکرار دنباله)</li></ul><p>برای مثال، اگر بخواهیم کلمه‌ای را با کلید رمز ۲-۱-۳ رمز کنیم:</p><ul><li>حرف ‘S’ را دو واحد به جلو ببریم، می‌شود ‘U’.</li><li>حرف بعدی (N) را سه واحد به جلو ببریم (طبق الگوی ۲-۱-۳، بعد از ۲ و ۱، نوبت ۳ است)، می‌شود ‘Q’.</li><li>این الگو (۲، ۱، ۳) برای حروف بعدی تکرار می‌شود.</li></ul><p><b>نکته:</b> در اکثر روش‌های رمزنگاری، فاصله‌ها (اسپیس‌ها) لحاظ نمی‌شوند و یا مانند حروف دیگر شیفت پیدا می‌کنند. این موضوع در تحلیل رمزنگاری مهم است.</p><h2>رمز ویژنر (Vigenere Cipher)</h2><p>رمز ویژنر نیز یک نوع رمزنگاری چند الفبایی است که با یک ماتریس ۲۶ در ۲۶ انجام می‌شود.</p><h3>ساختار ماتریس ویژنر</h3><p>ماتریس ویژنر از ۲۶ سطر و ۲۶ ستون تشکیل شده است. سطر اول حروف A تا Z را نشان می‌دهد. سطر دوم با B شروع شده و تا A ادامه می‌یابد و به همین ترتیب برای هر سطر، حروف الفبا یک واحد به جلو شیفت پیدا می‌کنند.</p><h3>نحوه کار</h3><p>برای رمزنگاری، یک کلید (کلمه یا رشته‌ای از حروف) در نظر گرفته می‌شود. حرف اول متن اصلی با حرف اول کلید رمز می‌شود. حرف دوم متن اصلی با حرف دوم کلید و الی آخر. اگر طول کلید کمتر از متن اصلی باشد، کلید تکرار می‌شود.</p><ul><li>حرف متن اصلی (از سطر اول ماتریس) را انتخاب می‌کنیم.</li><li>حرف کلید (از ستون اول ماتریس) را انتخاب می‌کنیم.</li><li>تقاطع سطر حرف کلید و ستون حرف متن اصلی، حرف رمز شده را مشخص می‌کند.</li></ul><h3>مثال: رمزنگاری با کلمه \"SHAYAN\" و کلید \"H\"</h3><p>برای رمز کردن حرف \'S\' (متن اصلی) با حرف \'H\' (کلید)، در ماتریس ویژنر، از سطر \'H\' و ستون \'S\' استفاده می‌شود که نتیجه آن حرف \'Z\' خواهد بود.</p><h3>مقاومت در برابر تحلیل فرکانسی</h3><p>رمز ویژنر در برابر تحلیل فرکانسی (Frequency Analysis) مقاوم‌تر است. در روش‌های تک الفبایی، یک حرف ثابت (مثلاً \'A\') همیشه به یک حرف ثابت (مثلاً \'X\') رمز می‌شود که امکان شناسایی الگوهای تکرار را می‌دهد. اما در ویژنر، یک حرف (مثلاً \'A\') می‌تواند با توجه به حروف مختلف کلید، به حروف مختلفی رمز شود (مثلاً \'A\' با کلید \'B\' به \'B\' و \'A\' با کلید \'C\' به \'C\' تبدیل می‌شود). این موضوع توزیع فرکانس حروف را مختل کرده و تحلیل فرکانسی را دشوار می‌کند.</p><h2>رمز وان تایم پد (One-Time Pad)</h2><p>این روش از یک ترفند ریاضی به نام XOR (Exclusive OR) استفاده می‌کند.</p><h3>نحوه کار</h3><ul><li>ابتدا تمامی حروف و اعداد متن اصلی (plaintext) به کد باینری (صفر و یک) تبدیل می‌شوند.</li><li>یک کلید (key) نیز که به صورت تصادفی تولید شده و طول آن برابر با طول متن اصلی باینری است، به باینری تبدیل می‌شود.</li><li>عملیات XOR بین بیت‌های متن اصلی و کلید انجام می‌شود:</li></ul><pre style=\"white-space: pre-wrap !important; word-wrap: break-word !important; overflow-x: auto !important; max-width: 100% !important; padding: 1rem; background-color: #f5f5f5; border-radius: 4px; direction: ltr; font-family: \'Courier New\', monospace; font-size: 0.9em; line-height: 1.5; margin: 1rem 0;white-space: pre-wrap !important; word-wrap: break-word !important; overflow-x: auto !important; max-width: 100% !important; padding: 1rem; background-color: #f5f5f5; border-radius: 4px; direction: ltr; font-family: \'Courier New\', monospace; font-size: 0.9em; line-height: 1.5; margin: 1rem 0;\"><code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; display: block; overflow-x: auto; font-family: \'Courier New\', monospace;white-space: pre-wrap !important; word-wrap: break-word !important; display: block; overflow-x: auto; font-family: \'Courier New\', monospace;\">0 XOR 0 = 0\n0 XOR 1 = 1\n1 XOR 0 = 1\n1 XOR 1 = 0\n</code></pre><ul><li>متن رمز شده (ciphertext) حاصل عملیات XOR خواهد بود.</li></ul><h3>رمزگشایی</h3><p>برای رمزگشایی، کافی است عملیات XOR را مجدداً بین متن رمز شده و همان کلید انجام دهیم: `Ciphertext XOR Key = Plaintext`</p><h3>ویژگی‌ها و امنیت</h3><ul><li>کلید باید کاملاً تصادفی باشد.</li><li>طول کلید باید حداقل برابر با طول متن اصلی باشد.</li><li>کلید فقط یک بار (one-time) باید استفاده شود.</li></ul><p>اگر این سه شرط رعایت شوند، One-Time Pad از نظر تئوری امن‌ترین روش رمزنگاری است و شکستن آن غیرممکن است، زیرا هر بیت از متن رمز شده با احتمال برابر می‌تواند ۰ یا ۱ باشد و هیچ اطلاعاتی در مورد متن اصلی افشا نمی‌کند.</p><h2>ماشین انیگما (Enigma Machine)</h2><p>انیگما یک ماشین رمزنگاری الکترومکانیکی بود که در جنگ جهانی دوم مورد استفاده قرار گرفت.</p><h3>نحوه کار</h3><ul><li>انیگما با استفاده از چندین \"روتور\" (چرخ‌دنده) و سیم‌کشی‌های داخلی، رمزنگاری را انجام می‌داد.</li><li>هنگام فشردن هر کلید، روتورها می‌چرخیدند و الگوی جایگزینی حروف را تغییر می‌دادند.</li><li>این ماشین یک حرف را به حرف دیگری تبدیل می‌کرد، اما این تبدیل با هر بار فشردن کلید تغییر می‌کرد.</li><li>\"کلید\" روزانه شامل تنظیمات اولیه روتورها و ترتیب آن‌ها بود.</li></ul><h3>امنیت و شکستن انیگما</h3><ul><li>انیگما برای مدت‌ها غیرقابل نفوذ تلقی می‌شد.</li><li>این ماشین توسط لهستانی‌ها و بعدها توسط متفقین (با کمک آلن تورینگ و ماشین‌های \"بمب\") شکسته شد.</li><li>متفقین از نقاط ضعف عملیاتی (مانند استفاده از عبارات استاندارد مانند \"Heil Hitler\" یا گزارش‌های هواشناسی در ابتدای پیام‌ها) بهره‌برداری کردند تا بخشی از تنظیمات کلید روزانه را حدس بزنند.</li><li>آن‌ها با استفاده از ماشین‌های محاسباتی اولیه به نام \"بمب\"، تنظیمات روتورها را به سرعت آزمایش می‌کردند.</li><li>عنصر انسانی و جاسوسی (مانلاً یک آشپز در یک رستوران که اطلاعاتی درباره نحوه کار ماشین و روال‌های عملیاتی روزانه ارائه کرد) نقش مهمی در شکستن انیگما داشت.</li></ul><h2>رمزنگاری جایگشتی (Permutation Cipher)</h2><p>این روش ترتیب حروف را در متن اصلی تغییر می‌دهد.</p><h3>نحوه کار</h3><p>در رمزنگاری جایگشتی، به جای جایگزینی حروف، موقعیت آن‌ها در متن اصلی عوض می‌شود. برای رمزگشایی، باید قانون جایگشت را دانست. این روش می‌تواند با روش‌های جایگزینی ترکیب شود تا امنیت بیشتری فراهم کند.</p><h2>رمزنگاری نردبانی (Rail Fence Cipher)</h2><p>یک روش جایگشتی است که متن را به صورت زیگزاگ روی چندین \"نردبان\" می‌نویسد و سپس به صورت سطری خوانده می‌شود.</p><h3>نحوه کار</h3><ul><li>تعداد نردبان‌ها (سطرها) را مشخص می‌کنید (این عدد کلید رمز است).</li><li>متن اصلی را به صورت زیگزاگ روی نردبان‌ها می‌نویسید.</li><li>سپس، حروف را به ترتیب از هر سطر و از چپ به راست می‌خوانید تا متن رمز شده به دست آید.</li></ul><h3>مثال: رمزنگاری \"Salam Khoobi</h3></div></div>',NULL,'completed','2025-11-04 08:57:02','2025-12-03 04:33:26',NULL,NULL,0,NULL,1,NULL),(38,5,1,'رمزنگاری کلاسیک: جایگشتی و مبانی رمزنگاری مدرن','2025-11-14','<div style=\"max-width: 100%; overflow-x: hidden; word-wrap: break-word; padding: 1rem; box-sizing: border-box;\"><div style=\"max-width: 100%; overflow-x: hidden; word-wrap: break-word; padding: 1rem; box-sizing: border-box;\"><h1>رمزنگاری کلاسیک</h1><p>ابتدا به مرور رمزنگاری جایگشتی ستونی می‌پردازیم.</p><h2>رمزنگاری جایگشتی ستونی</h2><p>فرض کنید می‌خواهیم متنی را با کلید سه رمزبندی کنیم. ابتدا سه خط، یعنی سه سطر می‌گذاریم. تعداد ستون‌ها را مشخص می‌کنیم که این تعداد برابر با تعداد حباب‌هاست (تعداد حروف در هر سطر). پس متن را به صورت سطری می‌خوانیم و کنار هم می‌گذاریم که رمز می‌شود.</p><p>چگونه می‌توانیم این جدول را پر کنیم تا وقتی سطری خوانده می‌شود، برابر متن رمز شده شود؟ حرف اول باید \'اس\' باشد، حرف بعدی \'بی\' باشد، و الی آخر.</p><h3>کلید اصلی</h3><p>نکته اصلی این است که بدانیم چه تعداد ستون قرار دهیم تا برابر تعداد حروف متن اصلی باشد.</p><h3>نحوه رمزگذاری</h3><ul><li>متن را به صورت سطری می‌نویسیم.</li><li>فاصله (طول) هر سطر ما محدود است.</li><li>این تعداد ستون، همان کلید ماست.</li></ul><p><b>مثال:</b> اگر تعداد ستون‌ها پنج باشد، کلمه‌ای که قرار است کد شود (مثلاً \"send another set\") را به صورت سطری می‌نویسیم:</p><pre style=\"white-space: pre-wrap !important; word-wrap: break-word !important; overflow-x: auto !important; max-width: 100% !important; padding: 1rem; background-color: #f5f5f5; border-radius: 4px; direction: ltr; font-family: \'Courier New\', monospace; font-size: 0.9em; line-height: 1.5; margin: 1rem 0;white-space: pre-wrap !important; word-wrap: break-word !important; overflow-x: auto !important; max-width: 100% !important; padding: 1rem; background-color: #f5f5f5; border-radius: 4px; direction: ltr; font-family: \'Courier New\', monospace; font-size: 0.9em; line-height: 1.5; margin: 1rem 0;\"><code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; display: block; overflow-x: auto; font-family: \'Courier New\', monospace;white-space: pre-wrap !important; word-wrap: break-word !important; display: block; overflow-x: auto; font-family: \'Courier New\', monospace;\">S E N D A\nN O T H E\nR S E T _</code></pre><p>سپس به صورت ستونی می‌خوانیم (از بالا به پایین). نتیجه می‌شود: SNEO... .</p><h3>نکات مهم</h3><ol><li>در اینجا **اسپیس‌ها مهم هستند** و جای آن‌ها ستاره (*) قرار می‌گیرد.</li><li>کلید می‌تواند علاوه بر تعداد ستون‌ها، **جایگشت ستون‌ها** هم باشد. یعنی بعد از اینکه متن را به صورت سطری نوشتید، دیگر از چپ به ترتیب نخوانید. یک اولویت‌بندی یا مرتب‌سازی برای خواندن ستون‌ها انجام می‌شود.</li></ol><p><b>مثال با جایگشت:</b> اول ستون اول را بخوانید (N O S R ...)، سپس ستون بعدی (D T S ...)، و به همین ترتیب. اگر تعداد حروف بر تعداد ستون‌ها بخش‌پذیر نباشد، در انتهای ستون‌ها ستاره (*) قرار می‌دهیم.</p><h3>رمزگشایی</h3><p>اگر کلید (تعداد ستون‌ها و ترتیب خواندن) را داشته باشیم، رمزگشایی امکان‌پذیر است. در غیر این صورت، این یک سؤال قشنگ است که چطور برگردیم؟ چون نمی‌دانیم ستون اولیه کدام بوده و ترتیب آن‌ها چه بود.</p><p>اگر تنها حالت ساده را در نظر بگیریم (بدون جایگشت ستون‌ها)، برای رمزگشایی متن رمز شده را به صورت ستونی می‌نویسیم (به تعداد ستون‌های مشخص شده در کلید). سپس متن را به صورت سطری می‌خوانیم.</p><p>نکته‌ای که وجود دارد این است که چون اسپیس‌ها مهم هستند و در آخر سطرها با ستاره پر می‌شوند، تعداد سطرها مشخص می‌شود. با داشتن کلید و دانستن اینکه اسپیس‌ها را چگونه پر کرده‌ایم، می‌توانیم رمزگشایی کنیم.</p><p>همان‌طور که در جلسه پیش صحبت کردیم، رمزنگاری متقارن به دو روش انجام می‌شود:</p><ul><li><b>رمزنگاری قطعه‌ای (Block Cipher):</b> متن به بلوک‌هایی (معمولاً 64، 128 یا 256 بیتی) تقسیم می‌شود. هر بلوک وارد الگوریتم رمزگذاری شده، یک کلید می‌گیرد و یک خروجی می‌دهد. از طرف دیگر، برای رمزگشایی، متن رمز شده و کلید وارد الگوریتم رمزگشایی می‌شوند و متن اصلی را برمی‌گردانند.</li><li><b>رمزنگاری جریانی (Stream Cipher):</b> بیت به بیت عمل می‌کند. هر بیت از متن اصلی با یک کلید \"XOR\" می‌شود و یک سایفرتکست (متن رمز شده) می‌دهد. برای رمزگشایی نیز سایفرتکست با همان کلید \"XOR\" می‌شود و متن اصلی را تولید می‌کند.</li></ul><h2>رمزنگاری مدرن</h2><p>روش‌های رمزنگاری کلاسیک (جایگشتی و جایگزینی) معمولاً یک بار عمل رمزنگاری را انجام می‌دادند. اما در رمزنگاری مدرن، علاوه بر این دو عمل، از عمل XOR نیز استفاده می‌کنند که پیچیدگی را افزایش می‌دهد. همچنین، این عملیات طی روال‌های مختلفی چندین بار روی یک متن تکرار می‌شود و رمز را به ما می‌دهد.</p><h3>الهام از ماشین‌های روتور</h3><p>این تکنیک‌ها از ماشین‌های روتور الهام گرفته شده‌اند. ماشین‌های روتور چگونه عمل می‌کردند؟ وقتی یک حرف از متن را به یک چیزی در سیلندر اول تبدیل می‌کرد، باز همان را به سیلندر دوم می‌داد و باز به چیز دیگری تبدیل می‌شد، و همین‌طور ادامه پیدا می‌کرد. این عمل تکرار چندین باره رمزگذاری، الهام‌بخش رمزگذاری‌های مدرن بود.</p><p>رمزنگاری مدرن از ترکیب همه این روش‌ها (جایگشت، جایگزینی، XOR) استفاده می‌کند و کل این پکیج چندین بار انجام می‌شود، نه فقط یک بار.</p><h2>ویژگی‌های رمزنگاری ایده‌آل</h2><p>هدف یک الگوریتم رمز این است که از بین تمام نگاشت‌های موجود، به صورت تصادفی انتخاب شود.</p><p>تعداد نگاشت‌های برگشت‌پذیر از B بیت به B بیت برابر با <pre style=\"white-space: pre-wrap !important; word-wrap: break-word !important; overflow-x: auto !important; max-width: 100% !important; padding: 1rem; background-color: #f5f5f5; border-radius: 4px; direction: ltr; font-family: \'Courier New\', monospace; font-size: 0.9em; line-height: 1.5; margin: 1rem 0;white-space: pre-wrap !important; word-wrap: break-word !important; overflow-x: auto !important; max-width: 100% !important; padding: 1rem; background-color: #f5f5f5; border-radius: 4px; direction: ltr; font-family: \'Courier New\', monospace; font-size: 0.9em; line-height: 1.5; margin: 1rem 0;\"><code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; display: block; overflow-x: auto; font-family: \'Courier New\', monospace;white-space: pre-wrap !important; word-wrap: break-word !important; display: block; overflow-x: auto; font-family: \'Courier New\', monospace;\">2^B!</code></pre> است.</p><p>به عبارت دیگر، اگر یک بلوک B بیتی داشته باشیم، <pre style=\"white-space: pre-wrap !important; word-wrap: break-word !important; overflow-x: auto !important; max-width: 100% !important; padding: 1rem; background-color: #f5f5f5; border-radius: 4px; direction: ltr; font-family: \'Courier New\', monospace; font-size: 0.9em; line-height: 1.5; margin: 1rem 0;white-space: pre-wrap !important; word-wrap: break-word !important; overflow-x: auto !important; max-width: 100% !important; padding: 1rem; background-color: #f5f5f5; border-radius: 4px; direction: ltr; font-family: \'Courier New\', monospace; font-size: 0.9em; line-height: 1.5; margin: 1rem 0;\"><code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; display: block; overflow-x: auto; font-family: \'Courier New\', monospace;white-space: pre-wrap !important; word-wrap: break-word !important; display: block; overflow-x: auto; font-family: \'Courier New\', monospace;\">2^B</code></pre> حالت مختلف رمز شده وجود دارد. برای اینکه تابع برگشت‌پذیر باشد و یک به یک باشد (یعنی هر چیز به یک چیز نگاشته شود و از هر چیزی یک چیز نگاشته شود)، باید تعداد نگاشت‌های ممکن را حساب کنیم.</p><h3>توضیح فرمول</h3><p>فرض کنید ما یک بلوک B بیتی داریم. این بلوک <pre style=\"white-space: pre-wrap !important; word-wrap: break-word !important; overflow-x: auto !important; max-width: 100% !important; padding: 1rem; background-color: #f5f5f5; border-radius: 4px; direction: ltr; font-family: \'Courier New\', monospace; font-size: 0.9em; line-height: 1.5; margin: 1rem 0;white-space: pre-wrap !important; word-wrap: break-word !important; overflow-x: auto !important; max-width: 100% !important; padding: 1rem; background-color: #f5f5f5; border-radius: 4px; direction: ltr; font-family: \'Courier New\', monospace; font-size: 0.9em; line-height: 1.5; margin: 1rem 0;\"><code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; display: block; overflow-x: auto; font-family: \'Courier New\', monospace;white-space: pre-wrap !important; word-wrap: break-word !important; display: block; overflow-x: auto; font-family: \'Courier New\', monospace;\">2^B</code></pre> حالت ممکن دارد (از <pre style=\"white-space: pre-wrap !important; word-wrap: break-word !important; overflow-x: auto !important; max-width: 100% !important; padding: 1rem; background-color: #f5f5f5; border-radius: 4px; direction: ltr; font-family: \'Courier New\', monospace; font-size: 0.9em; line-height: 1.5; margin: 1rem 0;white-space: pre-wrap !important; word-wrap: break-word !important; overflow-x: auto !important; max-width: 100% !important; padding: 1rem; background-color: #f5f5f5; border-radius: 4px; direction: ltr; font-family: \'Courier New\', monospace; font-size: 0.9em; line-height: 1.5; margin: 1rem 0;\"><code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; display: block; overflow-x: auto; font-family: \'Courier New\', monospace;white-space: pre-wrap !important; word-wrap: break-word !important; display: block; overflow-x: auto; font-family: \'Courier New\', monospace;\">00...0</code></pre> تا <pre style=\"white-space: pre-wrap !important; word-wrap: break-word !important; overflow-x: auto !important; max-width: 100% !important; padding: 1rem; background-color: #f5f5f5; border-radius: 4px; direction: ltr; font-family: \'Courier New\', monospace; font-size: 0.9em; line-height: 1.5; margin: 1rem 0;white-space: pre-wrap !important; word-wrap: break-word !important; overflow-x: auto !important; max-width: 100% !important; padding: 1rem; background-color: #f5f5f5; border-radius: 4px; direction: ltr; font-family: \'Courier New\', monospace; font-size: 0.9em; line-height: 1.5; margin: 1rem 0;\"><code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; display: block; overflow-x: auto; font-family: \'Courier New\', monospace;white-space: pre-wrap !important; word-wrap: break-word !important; display: block; overflow-x: auto; font-family: \'Courier New\', monospace;\">11...1</code></pre>). برای اینکه یک نگاشت (تبدیل) یک به یک و برگشت‌پذیر از این حالت‌ها به همان تعداد حالت‌ها ایجاد کنیم، به ازای اولین حالت، <pre style=\"white-space: pre-wrap !important; word-wrap: break-word !important; overflow-x: auto !important; max-width: 100% !important; padding: 1rem; background-color: #f5f5f5; border-radius: 4px; direction: ltr; font-family: \'Courier New\', monospace; font-size: 0.9em; line-height: 1.5; margin: 1rem 0;white-space: pre-wrap !important; word-wrap: break-word !important; overflow-x: auto !important; max-width: 100% !important; padding: 1rem; background-color: #f5f5f5; border-radius: 4px; direction: ltr; font-family: \'Courier New\', monospace; font-size: 0.9em; line-height: 1.5; margin: 1rem 0;\"><code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; display: block; overflow-x: auto; font-family: \'Courier New\', monospace;white-space: pre-wrap !important; word-wrap: break-word !important; display: block; overflow-x: auto; font-family: \'Courier New\', monospace;\">2^B</code></pre> انتخاب داریم. برای حالت دوم، <pre style=\"white-space: pre-wrap !important; word-wrap: break-word !important; overflow-x: auto !important; max-width: 100% !important; padding: 1rem; background-color: #f5f5f5; border-radius: 4px; direction: ltr; font-family: \'Courier New\', monospace; font-size: 0.9em; line-height: 1.5; margin: 1rem 0;white-space: pre-wrap !important; word-wrap: break-word !important; overflow-x: auto !important; max-width: 100% !important; padding: 1rem; background-color: #f5f5f5; border-radius: 4px; direction: ltr; font-family: \'Courier New\', monospace; font-size: 0.9em; line-height: 1.5; margin: 1rem 0;\"><code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; display: block; overflow-x: auto; font-family: \'Courier New\', monospace;white-space: pre-wrap !important; word-wrap: break-word !important; display: block; overflow-x: auto; font-family: \'Courier New\', monospace;\">2^B-1</code></pre> انتخاب (زیرا یکی قبلاً انتخاب شده و نباید تکرار شود). برای حالت سوم، <pre style=\"white-space: pre-wrap !important; word-wrap: break-word !important; overflow-x: auto !important; max-width: 100% !important; padding: 1rem; background-color: #f5f5f5; border-radius: 4px; direction: ltr; font-family: \'Courier New\', monospace; font-size: 0.9em; line-height: 1.5; margin: 1rem 0;white-space: pre-wrap !important; word-wrap: break-word !important; overflow-x: auto !important; max-width: 100% !important; padding: 1rem; background-color: #f5f5f5; border-radius: 4px; direction: ltr; font-family: \'Courier New\', monospace; font-size: 0.9em; line-height: 1.5; margin: 1rem 0;\"><code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; display: block; overflow-x: auto; font-family: \'Courier New\', monospace;white-space: pre-wrap !important; word-wrap: break-word !important; display: block; overflow-x: auto; font-family: \'Courier New\', monospace;\">2^B-2</code></pre> انتخاب و الی آخر تا آخرین حالت که یک انتخاب خواهیم داشت. حاصل ضرب این اعداد همان فاکتوریل است.</p><p>پس تعداد نگاشت‌های یک به یک و پوشا برابر است با فاکتوریل <pre style=\"white-space: pre-wrap !important; word-wrap: break-word !important; overflow-x: auto !important; max-width: 100% !important; padding: 1rem; background-color: #f5f5f5; border-radius: 4px; direction: ltr; font-family: \'Courier New\', monospace; font-size: 0.9em; line-height: 1.5; margin: 1rem 0;white-space: pre-wrap !important; word-wrap: break-word !important; overflow-x: auto !important; max-width: 100% !important; padding: 1rem; background-color: #f5f5f5; border-radius: 4px; direction: ltr; font-family: \'Courier New\', monospace; font-size: 0.9em; line-height: 1.5; margin: 1rem 0;\"><code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; display: block; overflow-x: auto; font-family: \'Courier New\', monospace;white-space: pre-wrap !important; word-wrap: break-word !important; display: block; overflow-x: auto; font-family: \'Courier New\', monospace;\">2^B</code></pre>.</p><pre style=\"white-space: pre-wrap !important; word-wrap: break-word !important; overflow-x: auto !important; max-width: 100% !important; padding: 1rem; background-color: #f5f5f5; border-radius: 4px; direction: ltr; font-family: \'Courier New\', monospace; font-size: 0.9em; line-height: 1.5; margin: 1rem 0;white-space: pre-wrap !important; word-wrap: break-word !important; overflow-x: auto !important; max-width: 100% !important; padding: 1rem; background-color: #f5f5f5; border-radius: 4px; direction: ltr; font-family: \'Courier New\', monospace; font-size: 0.9em; line-height: 1.5; margin: 1rem 0;\"><code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; display: block; overflow-x: auto; font-family: \'Courier New\', monospace;white-space: pre-wrap !important; word-wrap: break-word !important; display: block; overflow-x: auto; font-family: \'Courier New\', monospace;\">(2^B)!</code></pre><p>این به ازای هر بلوک B بیتی، تعداد نگاشت‌های ممکن یک به یک و پوشا را نشان می‌دهد.</p><h2>مشارکت و روش تدریس</h2><p>من دو رویکرد برای تدریس دارم:</p><ol><li>اسلایدها را سریع می‌خوانم و رد می‌شوم که در این صورت حجم درس زیاد می‌شود (مثلاً ۲۰ فصل و ۲۰۰۰ اسلاید) و شما مجبورید حفظ کنید.</li><li>کمتر درس می‌دهم (مثلاً ۳ فصل)، اما متوجه می‌شوید چه اتفاقی می‌افتد. از هر اسلاید ساده نگذرید، متوجه شوید.</li></ol><p>رویکرد دوم مستلزم مشارکت شماست. اگر مشارکت کنید، من سعی می‌کنم طوری پیش بروم که همه بفهمیم، حجم درس کمتر شود، کاربردی‌تر یاد بگیریم و سؤالات بیشتری یادتان بماند. اما اگر تعاملی نداشته باشید، مجبورم روش اول را پیش بگیرم که هم حجم درس زیاد می‌شود و هم یادگیری کمتری خواهید داشت.</p><p>اسلایدها تا آخر امشب در دسترس شما خواهند بود. لطفاً برای جلسه بعد، مبحث \"(2^B)!\" را مطالعه کنید تا مفهوم آن به طور کامل درک شود.</p></div></div>',NULL,'completed','2025-11-09 05:42:17','2025-12-03 04:33:26',NULL,NULL,0,NULL,1,NULL),(43,4,1,'هوش مصنوعی مولد (Generative AI) و معماری ترانسفورمر','1404/08/05','<div style=\"max-width: 100%; overflow-x: hidden; word-wrap: break-word; padding: 1rem; box-sizing: border-box;\"><div style=\"max-width: 100%; overflow-x: hidden; word-wrap: break-word; padding: 1rem; box-sizing: border-box;\"><h1>مقدمه به هوش مصنوعی مولد (Generative AI)</h1><p>این جلسه قصد داریم هوش مصنوعی مولد (Generative AI) را بررسی کنیم تا بسیاری از سؤالات و ابهامات درباره ابزارهایی که استفاده می‌کنید، برطرف شود. هدف این است که کلیت پشت این ابزارها را درک کنیم، نه جزئیات و فرمول‌های سطح کارشناسی.</p><h2>تفاوت هوش مصنوعی تشخیص‌دهنده و مولد</h2><p>در جلسات گذشته، گفتیم که هوش مصنوعی (AI) در حوزه انجام وظایف دو دسته‌ی کلی از تسک‌ها را انجام می‌دهد: تشخیص (Discrimination) و تولید (Generation).</p><ul><li><b>تشخیص (Discrimination):</b> به معنای طبقه‌بندی یا شناسایی الگوهاست. در جلسات گذشته، شبکه‌های عصبی، درخت‌ها و دیگر روش‌ها را بررسی کردیم که با چند سؤال، قادر به تشخیص بودند.</li><li><b>تولید (Generation):</b> به معنای خلق داده‌های جدید است.</li></ul><p>این جلسه به هوش مصنوعی مولد می‌پردازیم. هوش مصنوعی مولد نه تنها داده تولید می‌کند بلکه مفهوم «خلاقیت» نیز در آن وجود دارد. داده‌های جدید می‌توانند شامل تصویر، صدا، ویدئو، کدهای برنامه، سیگنال و هر چیز دیگری باشند.</p><h3>مفهوم هوش مصنوعی مولد</h3><p>برای درک هوش مصنوعی مولد، به یادگیری ماشین (Machine Learning) برمی‌گردیم که الگوهای کلی و مشترک را از داده‌ها یاد می‌گرفت. به عنوان مثال، چهره انسان‌ها (همه انسان‌های دنیا) یک تمپلیت کلی و مشترک دارد. این الگوهای کلی و مشترک را می‌توانیم جزئیاتشان را یک کمی کم و زیاد کنیم و بر اساس آن، آدم‌های مختلفی تولید کنیم؛ یعنی عکس‌های جدید و چهره‌های جدیدی که خیلی واقعی به نظر می‌رسند ولی وجود خارجی ندارند.</p><p>در واقع، هوش مصنوعی مولد به دنبال تولید تصاویر و بعدتر، تولید متن است که به کمک آن بسیاری از ابهامات برطرف خواهد شد.</p><h2>معماری ترانسفورمر (Transformer Architecture)</h2><p>در هوش مصنوعی، به این الگوریتم‌ها که کارهای مشخصی انجام می‌دهند، <b>مدل (Model)</b> می‌گوییم. هر مدل می‌تواند از یک یا چند <b>معماری (Architecture)</b> استفاده کند. معماری ترانسفورمر (Transformer) یک «بیگ جامپ» بزرگ در این حوزه بوده است. شرکت‌های بزرگ این معماری را استفاده می‌کنند چون سرمایه‌گذاری زیادی می‌طلبد. معماری ترانسفورمر به ما کمک کرده تا الگوهای کلی و مشترکی که قبلاً کشف می‌کردیم را بهتر کشف کنیم و کمی هم تغییرشان دهیم تا داده‌های جدیدی تولید شوند.</p><h3>نقش ترانسفورمر در انقلاب هوش مصنوعی مولد</h3><p>ظهور معماری ترانسفورمر باعث شد تا مدل‌های زبانی بزرگ (LLMs) و حتی مدل‌های بصری پدید آیند. انفجار این حوزه را می‌توان از طریق مدل GPT (Generative Pre-trained Transformer) مشاهده کرد که یک شبکه عصبی عمیق با معماری خاص است.</p><p>ترانسفورمرها جزو خانواده شبکه‌های عصبی بازگشتی (RNNs) مانند LSTM هستند، اما با معماری خاص خود، توانستند الگوها را بهتر یاد بگیرند. این معماری پایه‌ای برای تولید مدل‌هایی مانند GPT-3 و GPT-4 است. بسیاری از ابزارهای اپن‌سورس از ترانسفورمرهای پیش‌آموزش‌دیده استفاده می‌کنند، مانند ResNet که روی ImageNet آموزش دیده است.</p><h2>منطق پشت هوش مصنوعی مولد: انکودر و دکودر</h2><p>منطق پشت این مدل‌ها، هرچند از لحاظ ریاضی پیچیده است، اما به زبانی ساده قابل توضیح است.</p><h3>۱. انکودر (Encoder)</h3><p>ما یک دیتاست از تصاویر داریم. یک <b>انکودر</b> داریم (بهتر است بگوییم Autoencoder). این انکودر یاد می‌گیرد که چگونه الگوهای کلی و مشترک از این دیتاست را استخراج کند و یک Representation یا بازنمایی عددی از آن‌ها ارائه دهد. کار انکودر این است که حداکثر الگوها را استخراج کند. این الگوها در واقع اعدادی هستند که به خودی خود برای ما معنایی ندارند.</p><h3>۲. افزودن نویز (Noise)</h3><p>بعد از اینکه انکودر الگوها را یاد گرفت (به صورت اعداد)، ما به آن‌ها <b>نویز</b> (اعداد تصادفی کوچک) اضافه می‌کنیم. مثلاً اگر عددی 2.73 باشد، آن را به 2.75 تغییر می‌دهیم. این تغییر کوچک به صورت تصادفی انجام می‌شود، اما نه در حدی که ماهیت الگو را از بین ببرد.</p><h3>۳. دکودر (Decoder)</h3><p>سپس، این الگوهای تغییریافته را به یک <b>دکودر (Decoder)</b> می‌دهیم که کارش عکس انکودر است. اگر بدون نویز، فقط انکودر و دکودر را داشته باشیم، همان ورودی را بازتولید می‌کند. اما وقتی نویز اضافه می‌شود، دکودر الگوهای جدیدی تولید می‌کند که هنوز هم ماهیت الگوهای اصلی را حفظ کرده‌اند. به عنوان مثال، اگر الگوها مربوط به چهره انسان باشند، دکودر چهره‌های جدیدی را تولید می‌کند که واقعی به نظر می‌رسند ولی در دیتای اصلی وجود نداشتند.</p><p>مشکل این بود که مدل‌های قبلی کنترلی روی این نویز و تغییرات نداشتند و اغلب تصاویر تولیدی مطلوب نبودند. این محدودیت با مکانیسم <b>توجه (Attention)</b> حل شد.</p><h2>بازنمایی کلمات (Word Embeddings)</h2><p>برای اینکه کامپیوترها بتوانند با زبان انسانی کار کنند، نیاز داریم کلمات را به صورت عددی نمایش دهیم تا ماشین‌های یادگیری بتوانند آن‌ها را پردازش کنند. ما به دنبال بازنمایی‌ای از کلمات و جملات هستیم که همان معنایی که ما درک می‌کنیم را برای کامپیوتر نیز داشته باشد.</p><h3>۱. Bag of Words (کیسه کلمات)</h3><p>اولین تلاش‌ها برای این کار، مدل <b>Bag of Words (BoW)</b> بود. در این مدل، کلمات جایگاه و ترتیب خاصی ندارند (مهم نیست که کدام فعل، کدام اسم، کدام فاعل است). تنها چیزی که مهم است، تعداد تکرار کلمات است.</p><h4>مثال Bag of Words:</h4><p>فرض کنید دو جمله داریم:</p><ol><li><b>متن اول:</b> گربه مادر خوابید.</li><li><b>متن دوم:</b> بچه گربه روی پتو خوابید.</li></ol><p>ابتدا کلمات را به توکن (Token) تقسیم می‌کنیم. توکن کوچک‌ترین واحد معنایی یک جمله است، که معمولاً کلمات هستند (گاهی نیز کاراکترها). سپس تعداد تکرار هر کلمه را می‌شماریم. مثلاً در متن اول:</p><ul><li>گربه: ۱ بار</li><li>مادر: ۱ بار</li><li>خوابید: ۱ بار</li></ul><p>این اعداد (مثلاً [1,1,1]) هیچ معنای خاصی برای انسان ندارند. اما به طرز شگفت‌آوری، زمانی که این اعداد وارد دنیای ریاضیات می‌شوند، تقریباً همین معانی را منتقل می‌کنند. این یعنی پشت زبان ما انسان‌ها، یک منطق ریاضی پنهان است.</p><h3>۲. روابط ریاضی در بازنمایی کلمات</h3><p>این منطق ریاضی به ما امکان می‌دهد روابطی مانند:</p><pre style=\"white-space: pre-wrap !important; word-wrap: break-word !important; overflow-x: auto !important; max-width: 100% !important; padding: 1rem; background-color: #f5f5f5; border-radius: 4px; direction: ltr; font-family: \'Courier New\', monospace; font-size: 0.9em; line-height: 1.5; margin: 1rem 0;white-space: pre-wrap !important; word-wrap: break-word !important; overflow-x: auto !important; max-width: 100% !important; padding: 1rem; background-color: #f5f5f5; border-radius: 4px; direction: ltr; font-family: \'Courier New\', monospace; font-size: 0.9em; line-height: 1.5; margin: 1rem 0;\"><code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; display: block; overflow-x: auto; font-family: \'Courier New\', monospace;white-space: pre-wrap !important; word-wrap: break-word !important; display: block; overflow-x: auto; font-family: \'Courier New\', monospace;\">ملکه = زن + مرد - پادشاه</code></pre><p>را برقرار کنیم. این روابط نشان می‌دهد که می‌توانیم با بردارهای عددی، معنای کلمات و روابط بین آن‌ها را کشف کنیم. برای مثال، فاصله بردار \"پریدن\" تا \"پرید\" دقیقاً برابر با فاصله \"خوابیدن\" تا \"خوابید\" است. یا فاصله \"گربه مادر\" تا \"بچه گربه\" با فاصله \"مرغ\" تا \"جوجه\" برابر است. این نشان می‌دهد که روابط معنایی (مثل رابطه مادری) را می‌توانیم از طریق اعداد به دست آوریم.</p><h2>مکانیسم توجه (Attention Mechanism)</h2><p>مکانیسم توجه، یکی از مهم‌ترین اجزای ترانسفورمر است. این مکانیسم به مدل اجازه می‌دهد تا روی بخش‌های خاصی از ورودی تمرکز کند.</p><h3>عملکرد Attention:</h3><p>فرض کنید یک بردار (مثلاً بردار یک کلمه) داریم. یک بردار توجه (Attention Vector) دیگر نیز داریم که هم‌اندازه آن است. اگر بخواهیم فقط روی کلمه \"گربه\" تمرکز کنیم، مقدار مربوط به \"گربه\" در بردار توجه برابر با ۱ و بقیه صفر می‌شود. سپس این دو بردار را در هم ضرب می‌کنیم. نتیجه این ضرب، تمرکز مدل را فقط روی کلمه \"گربه</p></div></div>','<h1>مقدمه به هوش مصنوعی مولد (Generative AI)</h1><p>این جلسه قصد داریم هوش مصنوعی مولد (Generative AI) را بررسی کنیم تا بسیاری از سؤالات و ابهامات درباره ابزارهایی که استفاده می‌کنید، برطرف شود. هدف این است که کلیت پشت این ابزارها را درک کنیم، نه جزئیات و فرمول‌های سطح کارشناسی.</p><h2>تفاوت هوش مصنوعی تشخیص‌دهنده و مولد</h2><p>در جلسات گذشته، گفتیم که هوش مصنوعی (AI) در حوزه انجام وظایف دو دسته‌ی کلی از تسک‌ها را انجام می‌دهد: تشخیص (Discrimination) و تولید (Generation).</p><ul><li><strong>تشخیص (Discrimination):</strong> به معنای طبقه‌بندی یا شناسایی الگوهاست. در جلسات گذشته، شبکه‌های عصبی، درخت‌ها و دیگر روش‌ها را بررسی کردیم که با چند سؤال، قادر به تشخیص بودند.</li><li><strong>تولید (Generation):</strong> به معنای خلق داده‌های جدید است.</li></ul><p>این جلسه به هوش مصنوعی مولد می‌پردازیم. هوش مصنوعی مولد نه تنها داده تولید می‌کند بلکه مفهوم «خلاقیت» نیز در آن وجود دارد. داده‌های جدید می‌توانند شامل تصویر، صدا، ویدئو، کدهای برنامه، سیگنال و هر چیز دیگری باشند.</p><h3>مفهوم هوش مصنوعی مولد</h3><p>برای درک هوش مصنوعی مولد، به یادگیری ماشین (Machine Learning) برمی‌گردیم که الگوهای کلی و مشترک را از داده‌ها یاد می‌گرفت. به عنوان مثال، چهره انسان‌ها (همه انسان‌های دنیا) یک تمپلیت کلی و مشترک دارد. این الگوهای کلی و مشترک را می‌توانیم جزئیاتشان را یک کمی کم و زیاد کنیم و بر اساس آن، آدم‌های مختلفی تولید کنیم؛ یعنی عکس‌های جدید و چهره‌های جدیدی که خیلی واقعی به نظر می‌رسند ولی وجود خارجی ندارند.</p><p>در واقع، هوش مصنوعی مولد به دنبال تولید تصاویر و بعدتر، تولید متن است که به کمک آن بسیاری از ابهامات برطرف خواهد شد.</p><h2>معماری ترانسفورمر (Transformer Architecture)</h2><p>در هوش مصنوعی، به این الگوریتم‌ها که کارهای مشخصی انجام می‌دهند، <strong>مدل (Model)</strong> می‌گوییم. هر مدل می‌تواند از یک یا چند <strong>معماری (Architecture)</strong> استفاده کند. معماری ترانسفورمر (Transformer) یک «بیگ جامپ» بزرگ در این حوزه بوده است. شرکت‌های بزرگ این معماری را استفاده می‌کنند چون سرمایه‌گذاری زیادی می‌طلبد. معماری ترانسفورمر به ما کمک کرده تا الگوهای کلی و مشترکی که قبلاً کشف می‌کردیم را بهتر کشف کنیم و کمی هم تغییرشان دهیم تا داده‌های جدیدی تولید شوند.</p><h3>نقش ترانسفورمر در انقلاب هوش مصنوعی مولد</h3><p>ظهور معماری ترانسفورمر باعث شد تا مدل‌های زبانی بزرگ (LLMs) و حتی مدل‌های بصری پدید آیند. انفجار این حوزه را می‌توان از طریق مدل GPT (Generative Pre-trained Transformer) مشاهده کرد که یک شبکه عصبی عمیق با معماری خاص است.</p><p>ترانسفورمرها جزو خانواده شبکه‌های عصبی بازگشتی (RNNs) مانند LSTM هستند، اما با معماری خاص خود، توانستند الگوها را بهتر یاد بگیرند. این معماری پایه‌ای برای تولید مدل‌هایی مانند GPT-3 و GPT-4 است. بسیاری از ابزارهای اپن‌سورس از ترانسفورمرهای پیش‌آموزش‌دیده استفاده می‌کنند، مانند ResNet که روی ImageNet آموزش دیده است.</p><h2>منطق پشت هوش مصنوعی مولد: انکودر و دکودر</h2><p>منطق پشت این مدل‌ها، هرچند از لحاظ ریاضی پیچیده است، اما به زبانی ساده قابل توضیح است.</p><h3>۱. انکودر (Encoder)</h3><p>ما یک دیتاست از تصاویر داریم. یک <strong>انکودر</strong> داریم (بهتر است بگوییم Autoencoder). این انکودر یاد می‌گیرد که چگونه الگوهای کلی و مشترک از این دیتاست را استخراج کند و یک Representation یا بازنمایی عددی از آن‌ها ارائه دهد. کار انکودر این است که حداکثر الگوها را استخراج کند. این الگوها در واقع اعدادی هستند که به خودی خود برای ما معنایی ندارند.</p><h3>۲. افزودن نویز (Noise)</h3><p>بعد از اینکه انکودر الگوها را یاد گرفت (به صورت اعداد)، ما به آن‌ها <strong>نویز</strong> (اعداد تصادفی کوچک) اضافه می‌کنیم. مثلاً اگر عددی 2.73 باشد، آن را به 2.75 تغییر می‌دهیم. این تغییر کوچک به صورت تصادفی انجام می‌شود، اما نه در حدی که ماهیت الگو را از بین ببرد.</p><h3>۳. دکودر (Decoder)</h3><p>سپس، این الگوهای تغییریافته را به یک <strong>دکودر (Decoder)</strong> می‌دهیم که کارش عکس انکودر است. اگر بدون نویز، فقط انکودر و دکودر را داشته باشیم، همان ورودی را بازتولید می‌کند. اما وقتی نویز اضافه می‌شود، دکودر الگوهای جدیدی تولید می‌کند که هنوز هم ماهیت الگوهای اصلی را حفظ کرده‌اند. به عنوان مثال، اگر الگوها مربوط به چهره انسان باشند، دکودر چهره‌های جدیدی را تولید می‌کند که واقعی به نظر می‌رسند ولی در دیتای اصلی وجود نداشتند.</p><p>مشکل این بود که مدل‌های قبلی کنترلی روی این نویز و تغییرات نداشتند و اغلب تصاویر تولیدی مطلوب نبودند. این محدودیت با مکانیسم <strong>توجه (Attention)</strong> حل شد.</p><h2>بازنمایی کلمات (Word Embeddings)</h2><p>برای اینکه کامپیوترها بتوانند با زبان انسانی کار کنند، نیاز داریم کلمات را به صورت عددی نمایش دهیم تا ماشین‌های یادگیری بتوانند آن‌ها را پردازش کنند. ما به دنبال بازنمایی‌ای از کلمات و جملات هستیم که همان معنایی که ما درک می‌کنیم را برای کامپیوتر نیز داشته باشد.</p><h3>۱. Bag of Words (کیسه کلمات)</h3><p>اولین تلاش‌ها برای این کار، مدل <strong>Bag of Words (BoW)</strong> بود. در این مدل، کلمات جایگاه و ترتیب خاصی ندارند (مهم نیست که کدام فعل، کدام اسم، کدام فاعل است). تنها چیزی که مهم است، تعداد تکرار کلمات است.</p><h4>مثال Bag of Words:</h4><p>فرض کنید دو جمله داریم:</p><ol><li><strong>متن اول:</strong> گربه مادر خوابید.</li><li><strong>متن دوم:</strong> بچه گربه روی پتو خوابید.</li></ol><p>ابتدا کلمات را به توکن (Token) تقسیم می‌کنیم. توکن کوچک‌ترین واحد معنایی یک جمله است، که معمولاً کلمات هستند (گاهی نیز کاراکترها). سپس تعداد تکرار هر کلمه را می‌شماریم. مثلاً در متن اول:</p><ul><li>گربه: ۱ بار</li><li>مادر: ۱ بار</li><li>خوابید: ۱ بار</li></ul><p>این اعداد (مثلاً [1,1,1]) هیچ معنای خاصی برای انسان ندارند. اما به طرز شگفت‌آوری، زمانی که این اعداد وارد دنیای ریاضیات می‌شوند، تقریباً همین معانی را منتقل می‌کنند. این یعنی پشت زبان ما انسان‌ها، یک منطق ریاضی پنهان است.</p><h3>۲. روابط ریاضی در بازنمایی کلمات</h3><p>این منطق ریاضی به ما امکان می‌دهد روابطی مانند:</p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">ملکه = زن + مرد - پادشاه\n</pre><p>را برقرار کنیم. این روابط نشان می‌دهد که می‌توانیم با بردارهای عددی، معنای کلمات و روابط بین آن‌ها را کشف کنیم. برای مثال، فاصله بردار \"پریدن\" تا \"پرید\" دقیقاً برابر با فاصله \"خوابیدن\" تا \"خوابید\" است. یا فاصله \"گربه مادر\" تا \"بچه گربه\" با فاصله \"مرغ\" تا \"جوجه\" برابر است. این نشان می‌دهد که روابط معنایی (مثل رابطه مادری) را می‌توانیم از طریق اعداد به دست آوریم.</p><h2>مکانیسم توجه (Attention Mechanism)</h2><p>مکانیسم توجه، یکی از مهم‌ترین اجزای ترانسفورمر است. این مکانیسم به مدل اجازه می‌دهد تا روی بخش‌های خاصی از ورودی تمرکز کند.</p><h3>عملکرد Attention:</h3><p>فرض کنید یک بردار (مثلاً بردار یک کلمه) داریم. یک بردار توجه (Attention Vector) دیگر نیز داریم که هم‌اندازه آن است. اگر بخواهیم فقط روی کلمه \"گربه\" تمرکز کنیم، مقدار مربوط به \"گربه\" در بردار توجه برابر با ۱ و بقیه صفر می‌شود. سپس این دو بردار را در هم ضرب می‌کنیم. نتیجه این ضرب، تمرکز مدل را فقط روی کلمه \"گربه</p>','completed','2025-11-09 06:30:35','2025-12-03 04:33:26',NULL,NULL,0,NULL,1,NULL),(44,4,1,'مقدمه‌ای بر مسائل پیچیدگی و الگوریتم‌های جستجو در هوش مصنوعی','1404/07/27','<div style=\"max-width: 100%; overflow-x: hidden; word-wrap: break-word; padding: 1rem; box-sizing: border-box;\"><div style=\"max-width: 100%; overflow-x: hidden; word-wrap: break-word; padding: 1rem; box-sizing: border-box;\"><h1>مسائل NP و هوش مصنوعی</h1><p>مسائل NP دسته‌ای از مسائل نیستند که بتوانیم تمام راه‌حل‌های آن‌ها را تست کنیم و این کار را در زمان معمول انجام دهیم. مشکل مسائل NP این است که مشکل زمان‌بر هستند. ما نمی‌توانیم همه جواب‌ها را در زمان معقول پیدا کنیم. حتی با وجود سیستم‌های پردازشی قوی فعلی، مانند پردازش دیجیتال فعلی یا حتی پردازش کوانتومی، باز هم زمان زیادی برای حل این مسائل نیاز است. برای مثال، برای یک مسئله خاص مانند \"مضرب اعداد فرد\" که پایه و اساس اینترنت فعلی و ارتباطات ما است، فکر می‌کنم برای ۳۰۰ کاراکترش، حدود ۲۰۰ میلیون سال زمان نیاز است تا پنهان‌سازی (هَش) خودش را پیدا کنیم. این یعنی حتی کامپیوترهای کوانتومی هم برای مسائل خاصی فوق‌العاده هستند، اما مسائل ساده‌تر را اصلاً نمی‌فهمند.</p><p>ما همین چالش‌ها را در حوزه هوش مصنوعی (AI) هم داریم. یک سری مسائل هستند که الگوریتم‌های AI فعلی هم با مشکلات و چالش‌های زمان‌بر مواجه هستند.</p><h2>مفهوم AGI (هوش مصنوعی عمومی)</h2><p>جالب است بدانید که ما برای حل کردن یک مسئله AI کامل (AI-complete) به حداقل هوشی نیاز داریم که به آن <a href=\"https://en.wikipedia.org/wiki/Artificial_general_intelligence\">AGI (Artificial General Intelligence)</a> یا هوش مصنوعی عمومی می‌گویند. این حداقل هوش دقیقاً به معنای هوشی در حد یک انسان است. مثلاً برای تشبیه قلم اگر بخواهم به شما بگویم، حداقل هوش در اندازه انیشتین است.</p><p>البته این یک مقایسه غلط است و خیلی‌ها استدلال می‌کنند که یک کودک سه ساله که می‌تواند صحبت کند، AGI دارد، یا اینکه دلفین‌ها AGI دارند. این‌ها مباحث فلسفی و گفت‌وگوهایی هستند که اگر علاقه داشته باشید، زیاد هستند. یک کنفرانس هم درباره AGI داریم.</p><h3>AI-Complete و AI-Hard</h3><p>صحبت کردن و مکالمه خیلی ساده به نظر می‌رسد، اما این هم یک فرایند AI-complete است و نیاز به AGI دارد. یعنی هر انسانی که می‌تواند صحبت کند، حداقل AGI است. فرق AI-complete و AI-hard چیست؟ AI-completeها مسائل خیلی خاصی هستند. AI-completeها می‌توانند چیزهای کلی و حداقل هوش را داشته باشند، اما نمی‌توانند AI-hardها را حل کنند. AI-hardها مسائل سختی هستند که حل‌نشده در تاریخ ریاضیات و کامپیوتر باقی مانده‌اند، مثل اثبات فرضیه ریمان.</p><p>این‌ها مباحث عمیقی هستند، اما قرار نیست برای این‌ها مقاله بنویسیم. این ایده‌ها فقط برای این است که بدانید چه شکلی هستند. AI-hard این است و AI-complete هم همین‌طور. ما درباره مسائل AI اینجوری چیزی را گفتیم که مبحث AI-complete و AI-hard چیست.</p><h2>مراحل حل مسئله در AI: جستجو و استراتژی‌ها</h2><p>حالا می‌رسیم به قسمت‌های قبل هوش مصنوعی (ماشینی). هوش مصنوعی خود را تصحیح می‌کند. این‌ها ربطی به هوش مصنوعی ندارند. سؤال پرسیدند که در کتاب مرجع چی هم این‌ها هست؟ بله، این‌ها دقیقاً در آن کتاب هم هست. البته بعضی مسائل آنجا هست که اینجا نیست.</p><p>وقتی شما می‌خواهید جستجو کنید، باید از یک داده‌ساختار، از یک دیتا استراکچر استفاده کنید که خب در دسته درخت‌ها و گراف‌ها هستند. این درخت‌ها و این گراف‌ها یک فضای حالت (state space) را ایجاد می‌کنند. هر کدام از گره‌ها همان موقعیت‌های ما هستند در هر مسئله‌ای. این‌ها یک تشکیلات کلی دارند.</p><p>و حالا یک سری روش‌ها هست که از این فضای جواب، فضای فرضیه، فضای حالت (اصطلاحات مختلف) می‌آید و این‌ها را استخراج می‌کند. این‌ها اولین گام‌ها بودند به سمت پیدا کردن جواب.</p><p>پس ما با این کار می‌گوییم که فرض می‌کنیم وریفای کردن جواب، توی زمان پولی‌نومیال انجام می‌شود و با آن کاری نداریم. تمرکز ما روی یک چیز است: تسک اولیه الگوریتم، یعنی جستجو و پیدا کردن. بحث ما از کجا آمد؟ از الگوریتم‌ها. الگوریتم‌ها یک سری کارهای پشت سر هم هستند که همه‌شان دو تا تسک پشت سر هم دارند: پیدا کردن جواب و وریفای کردن.</p><p>فرض می‌کنیم الگوریتم‌هایی که ما داریم بررسی می‌کنیم، همه‌شان NP-complete هستند و بقیه هم که ندارند. فرض می‌کنیم که وریفای کردنش زمان چند ثانیه و حتی صد سال طول می‌کشد. با آن کاری نداریم. تمرکزمان را می‌گذاریم روی تسک اولیه: جستجو کردن.</p><h3>الگوریتم‌های جستجوی کورکورانه (Blind Search)</h3><p>حالا برای اینکه جستجو کنیم، این درخت فضای حالت را می‌بریم روی یک درخت یا گراف و حالا می‌آییم برای پیدا کردن این‌ها، چند تا الگوریتم را با هم بررسی می‌کنیم. اولینشان الگوریتم‌های کورکورانه هستند که این‌ها را در درس داده‌ساختارها (ساختمان داده) خوانده‌اید: BFS و DFS. این‌ها جزو مباحث پیشرفته هستند و به این مثال‌ها می‌رسیم.</p><h4>BFS (جستجوی سطح اول) و DFS (جستجوی عمق اول)</h4><p>درخت چیست؟ درخت شکلی دارد که توضیح داده شد: ریشه دارد، و هر کدام از نودها تفاوتشان با گراف این است که سایکل (چرخه) ندارد. می‌تواند جهت‌دار باشد، می‌تواند بی‌جهت هم باشد.</p><p>اگر مفهوم درخت را بسطش بدهید، همان گراف است. به این‌ها می‌گوییم نود و به این‌ها می‌گوییم یال.</p><p>حالا می‌رسیم به استراتژی‌های جستجو. ما برای تسک سرچ (پیدا کردن) دو تا استراتژی داشتیم: یکی استراتژی کورکورانه (بدون اطلاعات، uninformed) و یکی آگاهانه (informed) که تعدادشان زیاد است ولی این‌ها کلاسیک‌ها هستند.</p><p>چرا این‌ها را می‌گوییم؟ چون پله پله است. اول کورکورانه می‌گشتیم دنبال راه‌حل‌ها. بعدش هیوریستیک (heuristic) وارد کردیم، یک کمی خطا و ساختار مسئله را وارد کردیم. یک کمی ابتکاری به خرج دادیم. بعد این‌ها زیاد به درد نمی‌خورند. پنج شش تا مسئله را می‌توانند کار کنند، جنرال (عمومی) نیستند. بعد سیستم‌های خبره آمدند در دهه ۸۰ و ۷۰ میلادی. سیستم‌های خبره یک انقلاب بزرگی در جهان شد که ژاپنی‌ها و انگلیسی‌ها پیشگام بودند و میلیاردها هزینه کردند. دنیا تکانی خورد، مثل کاری که ChatGPT کرد و همه را مجبور کرد به هوش مصنوعی بازگردند. درس‌های دانشگاهی و رشته‌ها همه هوش مصنوعی شدند.</p><p>ولی خب این تا سال ۲۰۰۰ یا ۲۰۱۰ بود. بعداً این‌ها خیلی کار نمی‌کنند، به دردمان نمی‌خورند، مثل فروشگاه و کارهای خاص و جنرال. یک کمی کلی‌تر شد.</p><p>بعد یک دفعه تا ۲۰۱۰ در هوش مصنوعی چیزی به نام \"خواب زمستانی\" داشتیم. هوش مصنوعی اوایل که شروع شد هی بزرگ می‌شد، هایپ ایجاد می‌کرد و بعد می‌رفت در خواب زمستانی. اوایل، هایپ‌ها و خواب‌های زمستانی ۱۰-۱۵ سال طول می‌کشید. الان همه چیز برعکس شده. هرچه به الان نزدیک‌تر می‌شویم، هایپ بیشتر می‌شود و خواب زمستانی کوتاه‌تر می‌شود. الان می‌توانیم بگوییم که خواب زمستانی دیگر نداریم. اینقدر تکنولوژی و پردازشگرها عجیب غریب شده‌اند که الان هایپ است. برای همین هایپ هم بعد از یک مدتی از بین می‌رود و محو می‌شود. AI effect، خب هایپ بالاخره از بین می‌رود. برای خود ما، مثلاً خود من، خیلی پیگیر چیزهای جدید و مدل‌های جدید بودیم. همه‌اش فیچر بود و فلان چی بود.</p><p>ولی الان می‌گوییم نه، الان هایپ خوابیده. کلی پادکست گوش می‌کردیم، گوگل فلان امکانات را می‌گفت و بنچ‌مارک‌ها را می‌گفت، ولی الان نیست که کم‌تر شده. اون هایپ، AI effect نرمالیزه می‌شود. هایپ هم دارد انگار فروکش می‌کند. برای شما که خیلی مهم است، یک سری ChatGPT مثلاً آمده، یک مدل دیگر آمده (مثلاً Cohere) که در دسته ChatGPTها است. ولی این‌ها مسائل دو سال پیش بود، و پارسال، اوایل پارسال، یک اتفاق خیلی بزرگی بود که همه درباره‌اش صحبت می‌کردیم، مباحث شروع شده بود، استایل نمایش که بنچ‌مارک‌ها را می‌گفتیم.</p><p>اینجا قلم‌های اولیه‌ای است که فهمیدیم که چیزی هم هوش مصنوعی هست و می‌خواهیم به سمتش حرکت کنیم. منظور از بنچ‌مارک در هوش مصنوعی چیست؟ یک سری دیتاست هست، مثلاً ChatGPT می‌گوید مال من بهتر است، Cohere می‌گوید مال من بهتر است، گوگل می‌گوید مال من بهتر است. از کجا قضاوت کنیم؟ می‌آییم یک بنچ‌مارک می‌گذاریم: یک سری دیتاست و می‌گوییم که ChatGPT، تو هم برو روی این بنچ‌مارک جهانی (دست هیچ‌کس نیست). برو روی این تست کن. عدد دقتی که به دست می‌آوری، سؤال و جواب‌هایش را می‌شمارد و درصد می‌دهد. مثلاً ۷۰ درصد. یک دانه نیست، زیاد است. مثلاً سؤال‌های کنکور، تخصص پزشکی، المپیاد ریاضی، سؤال و جواب ساده، مسائل خیلی ساده. مثلاً اگر یک AI به یک معما بدهی، چطور حل می‌کند. این جور چیزها، بنچ‌مارک است.</p><p>عدد و ارقامی که تولید می‌کنند را توی یک وب‌سایت اینجا ثبت می‌کنند. اکانت دارند و ثبت می‌کنند. مثلاً می‌گوید که ... بیشتر به آزمون تورینگ و قابل اندازه‌گیری. سخت‌افزار هم بالاخره یک توانی دارد، قابل اندازه‌گیری است. اینجا هم اندازه‌گیری. یک سری سؤال و جواب است، می‌رود سؤالش را می‌دهد به AI، جواب‌هایی که تولید می‌کند را با جواب‌های درستی که در اختیار داریم مقایسه می‌کند و درصد می‌دهد. مثلاً ۱۰۰ هزار تا جواب، ۹۵ هزار تا از آن‌ها درست است. پس عددش می‌شود ۹۵ درصد. این‌ها را با هم مقایسه می‌کنند. دعوا سر هزارم‌های درصد است، نه، صدم‌های درصد. صدم درصد، یعنی مقیاس‌ها خیلی دقیق و وحشتناک هستند.</p><h3>جستجوهای کورکورانه (Uninformed Search)</h3><p>خب، حالا می‌آییم و وارد این‌ها می‌شویم. این‌ها جستجوهای کورکورانه بودند. فقط توی آن گراف، بر اساس ساختار گراف، اگر راهی بود می‌رفت، اگر یالی بود می‌رفت. اگر نبود، نمی‌دانست. هیچ استراتژی دیگری نداشت، کورکورانه بود. فقط حالتی که می‌شد امتحان کرد، امتحانش می‌کرد. بر اساس اول عمق (DFS) یا بر اساس اول سطح (BFS).</p><p>DFS (Depth-First Search): اگر بخواهیم پیمایش کنیم، یک سؤال می‌دهند، من به شما یک گراف می‌دهم و می‌گویم DFS این را بنویسید (یا حروف یا اعداد). فقط صفر، یک، دو، سه، چهار، پنج، شش. روش پیمایشش کورکورانه است. صرفاً اینکه راه داشته باشند، نودها به هم اتصال داشته باشند. در DFS اول جواب شماره صفر را می‌گرفتیم. چرا نمی‌گرفتیم؟ هیچ ایده‌ای نداریم چون ریشه بود. بعدش یک را گرفتیم، چرا سه را نگرفتیم؟ چون جواب، جواب ما نیست، این بود که بهتر با یک حرکت می‌رسیدیم. هیچ ایده‌ای چون نداشتیم. این‌ها را برای همین جستجوهای کورکورانه می‌گوییم (Uninformed Search).</p><h2>استراتژی‌های جستجوی آگاهانه (Informed Search)</h2><p>خب، گفتیم که چکار کنیم؟ یک کمی بهتر کنیم. استراتژی جستجویمان را چکار کنیم؟ می‌آییم به خود جواب‌ها وزن می‌دهیم. یعنی به خود این نودها یک وزن، یک عددی اختصاص می‌دهیم، یک کیفیتی. می‌گوییم به یک متخصص، به یک پزشک، به یک رادیولوژیست، فرض کن مثلاً این جواب‌ها را بر اساس احتمال، بر اساس هر چیزی که خودش ای‌بی‌سی‌دی می‌داند، یک وزنی بدهد.</p><p>خب، چکار می‌کنیم؟ این سورس ما هست، این هم مثلاً هدف ما است. می‌خواهیم برسیم به هدفمان. گل ما هست.</p><h3>جستجوی حریصانه (Greedy Search)</h3><p>حریصانه است. یعنی دو تا قدم بعدی را نمی‌بیند، صد تا قدم بعدی را نمی‌بیند. فقط گام بعدی‌اش را می‌بیند. حریص است. هی می‌گوید من مثلاً طلا بخرم، نمی‌داند فردا طلا ریزشی شود. می‌گوید بیت‌کوین بخرم، نمی‌داند فردا بیت‌کوین ریزشی شود. حریص. فقط امروز را نگاه می‌کند. آقا بیت‌کوین چون امروز سود کرده، بخرم. نمی‌داند اخلاق و ... حریص است. فقط قدم‌های کوتاه یا قدم بعدی را می‌بیند.</p><p>خب، قدم بعدی کدام باید باشد؟ این وزنش ۹ است، این وزنش ۵ است. آنی که کمتر است دیگر. می‌خواهیم با هزینه کمتر برسیم. پس این را می‌گیریم. دوباره این به این راه دارد، به این راه دارد. کدام را انتخاب می‌کند؟ این را. انتخاب می‌کند و از این می‌رود. برای همین ممکن است توی یک گراف، جواب درست نباشد. استراتژی‌اش این است: بهترین قدم بعدی. شما وقتی می‌خواهید شطرنج بازی کنید، این استراتژی اصلاً درست است؟ نه، شما معمولاً دو تا سه تا قدم بعدی را می‌بینید دیگر. این استراتژی درست نیست.</p><h3>الگوریتم A* (A-Star Algorithm)</h3><p>یک کمی بهترش کردیم. جستجوی A* را گفتیم. علاوه بر اینکه کیفیت راه‌حل‌ها را چی کند؟ نحوه حرکت بین این راه‌حل‌ها را هم در نظر بگیرد. یعنی شما فرض کنید که مثال بزنم، شاید برایتان هر مثالی می‌تواند باشد. فرض کنید از یک شهری می‌خواهید بروید به یک شهر دیگر، یک فاصله بین شهرها است، یک ترافیک داخل شهرها است. فرض کنید حالا هر مسئله‌ای.</p><p>گفت چکار کنیم مثلاً؟ بیاییم مسئله را بشکنیم به دو تا زیرمسئله: هزینه حرکتمان از نقطه شروع به این نقطه، به اضافه هزینه‌ای که این تا مقصد ما است. کاری نداریم. این‌ها را قبلاً حساب کردنش را گفتیم. پس دو تا آیتم را در نظر گرفتیم. این هم در نظر گرفتیم.</p><p>خیلی ساده. از سورس شروع می‌کند، به کجاها راه دارد؟ به A و B. مثال: از S به A می‌شود ۳+۸ و از S به B می‌شود ۲+۵، یعنی ۷. می‌آییم توی B. B می‌تواند به C برود، می‌تواند به E برود. چکار می‌کند؟ از B می‌گوید: من تا اینجا هرچیزی که آمدم به اضافه این عدد و این هم به اضافه این. این را در نظر نمی‌گیرد. می‌گوید ۲+۴+۳ و ۲+۱+۴. خب، این‌ها را جمع می‌کند. پس ۹ و ۷. ۷ کمتر است و این.</p><p>این‌ها را تا آخر ادامه می‌دهد دیگر. این B و این را محاسبه می‌کند. یعنی هر مرحله، وقتی از اینجا رد شد، دیگر این‌ها را در نظر نمی‌گیرد. این هم یک استراتژی جستجو است.</p><h2>انتقال به الگوریتم‌های بازی و یادگیری</h2><p>خب، پس ما فهمیدیم که هیوریستیک‌ها، ابتکارها یا اکتشاف‌ها (هر تلفظی که بهش می‌دهم، ابتکار به نظر من قشنگ‌ترین معادل فارسیش است) مؤثر واقع شدند. این اولین گام بود، اولین جرقه‌هایی بود که به سمت هوش مصنوعی رفت. فهمیدیم که اگر ما کامپیوترها، مکانیک‌ها، یعنی پردازش مکانیکی این‌ها را بتوانیم با وارد کردن یک سری هیوریستیک چکار کنیم؟ بهترشان کنیم.</p><p>خب، برای ۵۰ سال پیش که کامپیوتر اختراع شده بود و نشده بود، کامپیوتر امروزی، این یک چیز خیلی عجیب و غریب بود.</p><p>آمدیم یک کم جلوتر، این تئوری گیم (نظریه بازی‌ها) این‌ها آمد. این‌ها را آشنا شدید باهاش. بعد دوباره خیلی کلی شد و بازی‌هایی که در آن رقابت هست. یعنی بازی‌هایی هست که برد یک نفر معادل باخت نفر دیگر است. بهش می‌گویند استراتژی‌های minimax. برد یک نفر معادل باخت یک نفر دیگر است.</p><p>مثلاً شطرنج، Go. این‌ها بازی‌های کلاسیک هستند. چرا این‌ها معروف شدند؟ چون شرکت‌های بزرگ آمدند برای این‌ها مسابقات جهانی گذاشتند. مثلاً Deep Blue، کاسپاروف را شکست داد. با یک روش حلی، Deep Blue (با A* یا با همین minimax) کاسپاروف را شکست داد و این خیلی معروف شد. یا در ۲۰۱۳ یا ۲۰۱۶ بود که بازی Go بود (AlphaGo).</p><p>AlphaGo در کره‌جنوبی بود و شکست داد. DeepMind که مستندش هم هست (در پس‌زمینه آن را حتماً ببینید). کلاً استراتژی‌اش خیلی ساده است: می‌گوید تو همیشه یک حرکت را انتخاب کن، یک به اصطلاح مسیری را برو که حداکثر امتیاز را برای خودت داشته باشی و وقتی حداکثر امتیاز را برای خودت داشتی، خودبه‌خود حداقل امتیاز برای طرف مقابلت خواهد بود. مثلاً بازی دوز که شبیه دوز ما است ولی واقعاً دوز نیست. این فرق با دوز ما دارد. توی دوز ما سه تایی را جابجا می‌کنیم، ولی این جابجایی پیشرفته است. کل حالت‌هایش چقدر است؟ ۲۵۵ هزار تا حالت. با اینکه ۲۵۵ هزار حالت برای ما زیاد است، ولی یک عدد کوچک محسوب می‌شود و محدود است. کران دارد، مشخص است. از این ۲۵۵ هزار حالت خارج نیست.</p><p>جالب است، توی بازی‌ها همیشه سعی کنید حرکت اول را شما انجام بدهید. چرا؟ به خاطر اینکه احتمال اینکه شما برنده بشوید، دو برابر می‌شود. ۳۱ هزار برابر به ۷۷ هزار. تقریباً دو برابر می‌شود. پس حرکت اول شما احتمال برنده شدنتان را دو برابر می‌کند. البته احتمال کمی هم برای مساوی شدن هست.</p><p>یک مثال زده. می‌گوید توی این بازی، اگر X برنده شود، مثبت ۱۰ امتیاز (یعنی X توی یک ستون یا یک سطر یا یک قطر قرار بگیرد) و اگر O چکار کند؟ منفی ۱۰ امتیاز و مساوی هم برابر است با صفر. خب، فرض کنیم که نوبت X هست الان. می‌تواند یکی از این سه جا را انتخاب کند. اگر بگذارد اینجا، خب، من فقط بگویم: می‌تواند اینجا بگذارد، می‌تواند وسط بگذارد، می‌تواند بغل. اگر بغل بگذارد که مثبت ۱۰ امتیاز و بازی تمام می‌شود. می‌ماند این دو تا. اگر اینجا بگذارد، گام بعدی‌اش چیست؟ نگاه کنید، ما می‌توانیم در minimax چند تا گام بعدی را داشته باشیم. در شطرنج می‌توانیم ۱۰۰ هزار گام بعدی را محاسبه کنیم.</p><p>اینجا خب محدود است، ۲۵۵ هزار است. اگر اینجا بگذارد، بعدش نوبت کیست؟ نوبت O. O می‌تواند اینجا بگذارد یا اینجا بگذارد. که اگر مثلاً اینجا بگذارد، بازی می‌شود مساوی و اگر اینجا بگذارد، O برنده شده و بازی تمام می‌شود. یک سوال: توی گام دومی، که نود سمت راست پایین باشد، چرا وسط X شد؟ احتمالاً اشتباه شده. خب، در واقع. آره، اشتباه است.</p><p>فهمیدید ماجرا چیست؟ یعنی این حالت‌ها را هر دفعه حساب می‌کند. یعنی این را توی حلقه for می‌گذارد، توی همه این حالت‌ها را حساب می‌کند. شما یک برنامه نویسید که دوز بازی کند، شطرنج بازی کند. همه حالت‌ها را، مثلاً تا ۵ قدم بعدی، مثلاً در یک بازی شطرنج، می‌شود ۲۰۰ هزار حالت. خب، شما ۲۰۰ هزار حالت را همه حالت‌هایش را محاسبه می‌کنید و برای هر حالت امتیازش را به دست می‌آورید.</p><p>این استراتژی minimax است. هدفم چی بود قضیه؟ این که فهمیدید که هنوز یک گام دیگر می‌توانیم یک هیوریستیک بهتری اضافه کنیم. ما از الگوریتم‌های خام و کورکورانه شروع کردیم، داریم می‌آییم جلو، ولی همه این‌ها هوش مصنوعی نیست. نمی‌تواند صحبت کند. فقط برای بازی. حتی برای کارهای ساده دیگر هم به درد نمی‌خورد. مثلاً یک مسئله ریاضی را نمی‌فهمد. خاص هستند، جنرال (عمومی) نیستند.</p><h3>الگوریتم‌های بهینه‌سازی الهام گرفته از طبیعت (Nature-Inspired Optimization Algorithms)</h3><p>در استراتژی minimax چیزی را فهمیدیم: ما می‌توانیم یک جستجوی محلی، مثلاً ۵ قدم بعدی، ۱۰ قدم بعدی، ۲۰ قدم بعدی، بسته به کامپیوتری که داریم و قدرت پردازش، انجام بدهیم. بعد دوباره کشف می‌کنیم بر اساس هیوریستیکی که داشتیم. ولی برای یک بازی خیلی بزرگ مثل چکرز که ۱۵۰ میلیارد میلیارد حالت دارد، این که شما چقدر می‌توانید جستجوی محلی هم انجام بدهید، خیلی بزرگ نیست.</p><p>این مسائل که اینجوری هستند، مربوط به زمان معقولی نیستند، جزو NP-hardها هستند. این هیوریستیک‌ها حالا با هم تغییر کردند (تعداد گام‌ها). جستجوی محلی بود، هیوریستیک باید عوض شود. دوباره که فهمیدیم هیوریستیک بهتری است، آمدیم یک الگوریتم دیگر درست کردیم به نام الگوریتم \"کوهنوردی\" (Hill Climbing) یا صعود به تپه (Slope of the Hill). هر اصطلاحی که فکر می‌کنید به فارسیش نزدیک باشد.</p><p>مسائل ما معمولاً یک جواب بهتری داریم، یک جواب بهینه و بهترین. ولی چند تا جواب محلی بهینه‌تر هم داریم. معمولاً مسائل قبلی‌ها، حالا اینجا معمولاً نمی‌رسند. این استراتژی جستجوی ما، این الگوریتم، یا این‌ها هم همین شکلی‌اند. شما اگر جستجو کنید، کلی اسم عجیب و غریب دارند. مثلاً الگوریتم مورچه داریم، الگوریتم زنبور عسل داریم، الگوریتم نمی‌دانم پروانه داریم، الگوریتم برگ فلان داریم، الگوریتم خاکستری داریم. کلاً یعنی ایده‌های طبیعت را می‌گیرند، این‌ها را مدل می‌کنند به زبان ریاضی و می‌دهند به کامپیوتر. فقط جواب می‌دهد.</p><p>یکی از این اولین تلاش‌ها این الگوریتم کوهنوردی است. می‌گوید ما هرچه که اول یک نقطه رندوم را انتخاب می‌کنیم توی این مسیر، فضای جواب‌ها (مثل آن درخت و گراف این‌ها نبود که حتماً ریشه شروع کنیم). یک دانه را انتخاب می‌کند. می‌گوید یک دانه بالا، یک دانه به سمت مثلاً جلو برود، یک دانه به سمت عقب برگردد (هر جایی که هست). فرض کنید فقط به دو طرف می‌رود. آنی که جواب بهتری می‌دهد را انتخاب می‌کند. درسته؟ یعنی چی؟ یعنی می‌گوید که اینجا که هستی، یک دانه به پایین برو، یک دانه به بالا. از کجا می‌فهمد بالا پایین را؟ از شیب خط. شیب خط یعنی چی؟ شیب خط یعنی مشتق مرتبه اول. مشتق مرتبه دوم. مشتق مرتبه دوم. یک دانه عقب، یک دانه جلو. اگر مثبت بود، برو بالا، اگر منفی بود، بیا پایین.</p><p>این پس الگوریتم، این استراتژی جستجو می‌گوید آقا برو بالا. می‌آید اینجا، ولی می‌خواهد حرکت کند، ای من دارم می‌روم پایین. اینجا بالا نیست. این را به عنوان جواب برمی‌گرداند. اما این بهترین جواب است؟ نه. بهترین جواب این است که اگر به جای اینکه می‌رفت بالا، می‌آمد عقب، اینجا بهتر بود. بهتر بود که آنجا می‌آمد و شروع می‌کرد، بلکه به جواب بهینه‌تری می‌رسید. پس این استراتژی هنوز کامل نیست. ولی خب اولین تلاش ما است.</p><p>نگاه کنید، اینجا ما هنوز هیوریستیکیم. اصلاً یادگیری نداریم. ما داریم با حل می‌کنیم. علاوه بر اینکه ما چند نوع دیگر کردن داشتیم توی مسئله: یکی اینکه این حالت شانه‌ای بوده. یعنی شاید پایین، مسطح و بعدش برود بالا. اینجا گیر می‌کردیم. این الان مسطح است. نه دونه به عقب داریم، نه جلو. یک گام می‌رود به عقب، می‌بیند تغییری ندارد. یک گام می‌رود به جلو، می‌بیند تغییری ندارد. وایمیستد اینجا، گیر می‌کند. دوباره همین‌طور، اینجا هم مسطح است. یک قله مسطح. می‌رود جلو، می‌رود عقب، می‌بیند آنجا گیر می‌کند. می‌گوید به هر حال چه جلو بروم، چه عقب بروم، تغییری ندارم.</p><p>پس این ایرادات اینجوری داشت. ولی خب خیلی ساده بود، یعنی objective function شما هرچیزی می‌تواند باشد: دقت، سود، خطا، هرچیزی. بسته به مسئله. متوجه شدید؟ الگوریتمش هم خیلی ساده است. یک خط توضیح داده شد. می‌گوید یک حالت اولیه را به صورت رندوم انتخاب می‌کند و بر اساس آن تابع، objective شما، تابع هزینه شما، هر دفعه موقعیت فعلی‌اش را با موقعیت بعدی و قبلی‌اش محاسبه می‌کند. بعد بهترین همسایه‌اش را انتخاب می‌کند و می‌رود به آن سمت. حالا اگر بهتر بود، دوباره این گام را تکرار می‌کند. در غیر این صورت، بالاخره توی یک موقعیت مسطح یا توی یک ماکسیمم، بهترین جواب (چه لوکال، چه گلوبال) گیر کرده است و این شرط توقف الگوریتم است. حالا اگر خوش‌شانس باشید، می‌رود به گلوبال، اگر بدشانس باشید (که اغلب این‌طوری هست) توی لوکال گیر می‌کند. برای همین گفتیم که باز تحقیقات ادامه پیدا کرد.</p><p>یک الگوریتم دیگر. حالا مزایایش را هم گفته است. ساده است و... معایبش هم که مشخص است. یک الگوریتم دیگر به نام الگوریتم \"خنک کردن شبیه‌سازی‌شده\" یا Simulated Annealing. این را هم با هم بررسی می‌کنیم. خیلی ساده است. الان واقعاً... یک فلز خاصی می‌خواهید یک شکل خاصی بگیرد، دو حالت دارد: اینکه شما بگذارید و یک دفعه درش بیاورید توی آب بگذارید. درجا سرد می‌شود. مثلاً چاقو و این‌ها را دیدید این کار را می‌کنند، تیز بشود و یک حالت سختی داشته باشد. ولی خیلی جاها هست که نه، شما نیاز دارید که آن سطح صاف و حالت ... واقعاً این را می‌دانید. می‌گذارند دمای کوره را پله پله، فرکانس خاصی کم می‌کنند. یک دفعه سردش نمی‌کنند. این در مورد فلزات است.</p><p>حالا برای هر فلزی، یک رفتار خنک‌کردن دارد. اگر بخواهیم این ایده را بیاورم توی چی؟ اینجا خب اصطلاحاتش فرق می‌کند. از انرژی استفاده کردند، تابع هدفش همان است. می‌گوید اولی که از چیز درمی‌آید، اولی که انتخاب می‌کنیم، اینجا مسئله ما بهینه‌سازی است. کمینه‌سازی. اغلب ما در دنیا بیشتر مسائل بهینه‌سازی را به عنوان مینیمم کردن، به عنوان مینیمم کردن چی؟ خطا. اغلب کاربردهای روزمره هوش مصنوعی، شما یک ریباند گرفته مثال زده و... هر چیزی که فکر می‌کنید، شما دنبال این هستید که خطایتان را کم کنید. پس برای همین شما می‌خواهید... یه مقداری کمتر... بیشتر دنبال کمتر کردن هزینه. بله، مسئله شما اینجوری است: کمتر کردن هزینه. نه کمتر کردن خطا. نوعش است که کمترش می‌کند. کاملاً درست است. ما دنبال نوع مسئله هستیم. شما یک مسئله بهینه‌سازی دارید که می‌خواهید بهترینش را پیدا کنید. بهترینش حداکثری است یا کمترین؟ مثلاً می‌گویم از نظر ما این‌ها کاربردی‌ترین مسائل وقتی داریم بهینه‌سازی می‌کنیم، یعنی کمتر کردن هزینه.</p></div></div>','<div style=\"max-width: 100%; overflow-x: hidden; word-wrap: break-word; padding: 1rem; box-sizing: border-box;\"><h1>مسائل NP و هوش مصنوعی</h1><p>مسائل NP دسته‌ای از مسائل نیستند که بتوانیم تمام راه‌حل‌های آن‌ها را تست کنیم و این کار را در زمان معمول انجام دهیم. مشکل مسائل NP این است که مشکل زمان‌بر هستند. ما نمی‌توانیم همه جواب‌ها را در زمان معقول پیدا کنیم. حتی با وجود سیستم‌های پردازشی قوی فعلی، مانند پردازش دیجیتال فعلی یا حتی پردازش کوانتومی، باز هم زمان زیادی برای حل این مسائل نیاز است. برای مثال، برای یک مسئله خاص مانند \"مضرب اعداد فرد\" که پایه و اساس اینترنت فعلی و ارتباطات ما است، فکر می‌کنم برای ۳۰۰ کاراکترش، حدود ۲۰۰ میلیون سال زمان نیاز است تا پنهان‌سازی (هَش) خودش را پیدا کنیم. این یعنی حتی کامپیوترهای کوانتومی هم برای مسائل خاصی فوق‌العاده هستند، اما مسائل ساده‌تر را اصلاً نمی‌فهمند.</p><p>ما همین چالش‌ها را در حوزه هوش مصنوعی (AI) هم داریم. یک سری مسائل هستند که الگوریتم‌های AI فعلی هم با مشکلات و چالش‌های زمان‌بر مواجه هستند.</p><h2>مفهوم AGI (هوش مصنوعی عمومی)</h2><p>جالب است بدانید که ما برای حل کردن یک مسئله AI کامل (AI-complete) به حداقل هوشی نیاز داریم که به آن <a href=\"https://en.wikipedia.org/wiki/Artificial_general_intelligence\">AGI (Artificial General Intelligence)</a> یا هوش مصنوعی عمومی می‌گویند. این حداقل هوش دقیقاً به معنای هوشی در حد یک انسان است. مثلاً برای تشبیه قلم اگر بخواهم به شما بگویم، حداقل هوش در اندازه انیشتین است.</p><p>البته این یک مقایسه غلط است و خیلی‌ها استدلال می‌کنند که یک کودک سه ساله که می‌تواند صحبت کند، AGI دارد، یا اینکه دلفین‌ها AGI دارند. این‌ها مباحث فلسفی و گفت‌وگوهایی هستند که اگر علاقه داشته باشید، زیاد هستند. یک کنفرانس هم درباره AGI داریم.</p><h3>AI-Complete و AI-Hard</h3><p>صحبت کردن و مکالمه خیلی ساده به نظر می‌رسد، اما این هم یک فرایند AI-complete است و نیاز به AGI دارد. یعنی هر انسانی که می‌تواند صحبت کند، حداقل AGI است. فرق AI-complete و AI-hard چیست؟ AI-completeها مسائل خیلی خاصی هستند. AI-completeها می‌توانند چیزهای کلی و حداقل هوش را داشته باشند، اما نمی‌توانند AI-hardها را حل کنند. AI-hardها مسائل سختی هستند که حل‌نشده در تاریخ ریاضیات و کامپیوتر باقی مانده‌اند، مثل اثبات فرضیه ریمان.</p><p>این‌ها مباحث عمیقی هستند، اما قرار نیست برای این‌ها مقاله بنویسیم. این ایده‌ها فقط برای این است که بدانید چه شکلی هستند. AI-hard این است و AI-complete هم همین‌طور. ما درباره مسائل AI اینجوری چیزی را گفتیم که مبحث AI-complete و AI-hard چیست.</p><h2>مراحل حل مسئله در AI: جستجو و استراتژی‌ها</h2><p>حالا می‌رسیم به قسمت‌های قبل هوش مصنوعی (ماشینی). هوش مصنوعی خود را تصحیح می‌کند. این‌ها ربطی به هوش مصنوعی ندارند. سؤال پرسیدند که در کتاب مرجع چی هم این‌ها هست؟ بله، این‌ها دقیقاً در آن کتاب هم هست. البته بعضی مسائل آنجا هست که اینجا نیست.</p><p>وقتی شما می‌خواهید جستجو کنید، باید از یک داده‌ساختار، از یک دیتا استراکچر استفاده کنید که خب در دسته درخت‌ها و گراف‌ها هستند. این درخت‌ها و این گراف‌ها یک فضای حالت (state space) را ایجاد می‌کنند. هر کدام از گره‌ها همان موقعیت‌های ما هستند در هر مسئله‌ای. این‌ها یک تشکیلات کلی دارند.</p><p>و حالا یک سری روش‌ها هست که از این فضای جواب، فضای فرضیه، فضای حالت (اصطلاحات مختلف) می‌آید و این‌ها را استخراج می‌کند. این‌ها اولین گام‌ها بودند به سمت پیدا کردن جواب.</p><p>پس ما با این کار می‌گوییم که فرض می‌کنیم وریفای کردن جواب، توی زمان پولی‌نومیال انجام می‌شود و با آن کاری نداریم. تمرکز ما روی یک چیز است: تسک اولیه الگوریتم، یعنی جستجو و پیدا کردن. بحث ما از کجا آمد؟ از الگوریتم‌ها. الگوریتم‌ها یک سری کارهای پشت سر هم هستند که همه‌شان دو تا تسک پشت سر هم دارند: پیدا کردن جواب و وریفای کردن.</p><p>فرض می‌کنیم الگوریتم‌هایی که ما داریم بررسی می‌کنیم، همه‌شان NP-complete هستند و بقیه هم که ندارند. فرض می‌کنیم که وریفای کردنش زمان چند ثانیه و حتی صد سال طول می‌کشد. با آن کاری نداریم. تمرکزمان را می‌گذاریم روی تسک اولیه: جستجو کردن.</p><h3>الگوریتم‌های جستجوی کورکورانه (Blind Search)</h3><p>حالا برای اینکه جستجو کنیم، این درخت فضای حالت را می‌بریم روی یک درخت یا گراف و حالا می‌آییم برای پیدا کردن این‌ها، چند تا الگوریتم را با هم بررسی می‌کنیم. اولینشان الگوریتم‌های کورکورانه هستند که این‌ها را در درس داده‌ساختارها (ساختمان داده) خوانده‌اید: BFS و DFS. این‌ها جزو مباحث پیشرفته هستند و به این مثال‌ها می‌رسیم.</p><h4>BFS (جستجوی سطح اول) و DFS (جستجوی عمق اول)</h4><p>درخت چیست؟ درخت شکلی دارد که توضیح داده شد: ریشه دارد، و هر کدام از نودها تفاوتشان با گراف این است که سایکل (چرخه) ندارد. می‌تواند جهت‌دار باشد، می‌تواند بی‌جهت هم باشد.</p><p>اگر مفهوم درخت را بسطش بدهید، همان گراف است. به این‌ها می‌گوییم نود و به این‌ها می‌گوییم یال.</p><p>حالا می‌رسیم به استراتژی‌های جستجو. ما برای تسک سرچ (پیدا کردن) دو تا استراتژی داشتیم: یکی استراتژی کورکورانه (بدون اطلاعات، uninformed) و یکی آگاهانه (informed) که تعدادشان زیاد است ولی این‌ها کلاسیک‌ها هستند.</p><p>چرا این‌ها را می‌گوییم؟ چون پله پله است. اول کورکورانه می‌گشتیم دنبال راه‌حل‌ها. بعدش هیوریستیک (heuristic) وارد کردیم، یک کمی خطا و ساختار مسئله را وارد کردیم. یک کمی ابتکاری به خرج دادیم. بعد این‌ها زیاد به درد نمی‌خورند. پنج شش تا مسئله را می‌توانند کار کنند، جنرال (عمومی) نیستند. بعد سیستم‌های خبره آمدند در دهه ۸۰ و ۷۰ میلادی. سیستم‌های خبره یک انقلاب بزرگی در جهان شد که ژاپنی‌ها و انگلیسی‌ها پیشگام بودند و میلیاردها هزینه کردند. دنیا تکانی خورد، مثل کاری که ChatGPT کرد و همه را مجبور کرد به هوش مصنوعی بازگردند. درس‌های دانشگاهی و رشته‌ها همه هوش مصنوعی شدند.</p><p>ولی خب این تا سال ۲۰۰۰ یا ۲۰۱۰ بود. بعداً این‌ها خیلی کار نمی‌کنند، به دردمان نمی‌خورند، مثل فروشگاه و کارهای خاص و جنرال. یک کمی کلی‌تر شد.</p><p>بعد یک دفعه تا ۲۰۱۰ در هوش مصنوعی چیزی به نام \"خواب زمستانی\" داشتیم. هوش مصنوعی اوایل که شروع شد هی بزرگ می‌شد، هایپ ایجاد می‌کرد و بعد می‌رفت در خواب زمستانی. اوایل، هایپ‌ها و خواب‌های زمستانی ۱۰-۱۵ سال طول می‌کشید. الان همه چیز برعکس شده. هرچه به الان نزدیک‌تر می‌شویم، هایپ بیشتر می‌شود و خواب زمستانی کوتاه‌تر می‌شود. الان می‌توانیم بگوییم که خواب زمستانی دیگر نداریم. اینقدر تکنولوژی و پردازشگرها عجیب غریب شده‌اند که الان هایپ است. برای همین هایپ هم بعد از یک مدتی از بین می‌رود و محو می‌شود. AI effect، خب هایپ بالاخره از بین می‌رود. برای خود ما، مثلاً خود من، خیلی پیگیر چیزهای جدید و مدل‌های جدید بودیم. همه‌اش فیچر بود و فلان چی بود.</p><p>ولی الان می‌گوییم نه، الان هایپ خوابیده. کلی پادکست گوش می‌کردیم، گوگل فلان امکانات را می‌گفت و بنچ‌مارک‌ها را می‌گفت، ولی الان نیست که کم‌تر شده. اون هایپ، AI effect نرمالیزه می‌شود. هایپ هم دارد انگار فروکش می‌کند. برای شما که خیلی مهم است، یک سری ChatGPT مثلاً آمده، یک مدل دیگر آمده (مثلاً Cohere) که در دسته ChatGPTها است. ولی این‌ها مسائل دو سال پیش بود، و پارسال، اوایل پارسال، یک اتفاق خیلی بزرگی بود که همه درباره‌اش صحبت می‌کردیم، مباحث شروع شده بود، استایل نمایش که بنچ‌مارک‌ها را می‌گفتیم.</p><p>اینجا قلم‌های اولیه‌ای است که فهمیدیم که چیزی هم هوش مصنوعی هست و می‌خواهیم به سمتش حرکت کنیم. منظور از بنچ‌مارک در هوش مصنوعی چیست؟ یک سری دیتاست هست، مثلاً ChatGPT می‌گوید مال من بهتر است، Cohere می‌گوید مال من بهتر است، گوگل می‌گوید مال من بهتر است. از کجا قضاوت کنیم؟ می‌آییم یک بنچ‌مارک می‌گذاریم: یک سری دیتاست و می‌گوییم که ChatGPT، تو هم برو روی این بنچ‌مارک جهانی (دست هیچ‌کس نیست). برو روی این تست کن. عدد دقتی که به دست می‌آوری، سؤال و جواب‌هایش را می‌شمارد و درصد می‌دهد. مثلاً ۷۰ درصد. یک دانه نیست، زیاد است. مثلاً سؤال‌های کنکور، تخصص پزشکی، المپیاد ریاضی، سؤال و جواب ساده، مسائل خیلی ساده. مثلاً اگر یک AI به یک معما بدهی، چطور حل می‌کند. این جور چیزها، بنچ‌مارک است.</p><p>عدد و ارقامی که تولید می‌کنند را توی یک وب‌سایت اینجا ثبت می‌کنند. اکانت دارند و ثبت می‌کنند. مثلاً می‌گوید که ... بیشتر به آزمون تورینگ و قابل اندازه‌گیری. سخت‌افزار هم بالاخره یک توانی دارد، قابل اندازه‌گیری است. اینجا هم اندازه‌گیری. یک سری سؤال و جواب است، می‌رود سؤالش را می‌دهد به AI، جواب‌هایی که تولید می‌کند را با جواب‌های درستی که در اختیار داریم مقایسه می‌کند و درصد می‌دهد. مثلاً ۱۰۰ هزار تا جواب، ۹۵ هزار تا از آن‌ها درست است. پس عددش می‌شود ۹۵ درصد. این‌ها را با هم مقایسه می‌کنند. دعوا سر هزارم‌های درصد است، نه، صدم‌های درصد. صدم درصد، یعنی مقیاس‌ها خیلی دقیق و وحشتناک هستند.</p><h3>جستجوهای کورکورانه (Uninformed Search)</h3><p>خب، حالا می‌آییم و وارد این‌ها می‌شویم. این‌ها جستجوهای کورکورانه بودند. فقط توی آن گراف، بر اساس ساختار گراف، اگر راهی بود می‌رفت، اگر یالی بود می‌رفت. اگر نبود، نمی‌دانست. هیچ استراتژی دیگری نداشت، کورکورانه بود. فقط حالتی که می‌شد امتحان کرد، امتحانش می‌کرد. بر اساس اول عمق (DFS) یا بر اساس اول سطح (BFS).</p><p>DFS (Depth-First Search): اگر بخواهیم پیمایش کنیم، یک سؤال می‌دهند، من به شما یک گراف می‌دهم و می‌گویم DFS این را بنویسید (یا حروف یا اعداد). فقط صفر، یک، دو، سه، چهار، پنج، شش. روش پیمایشش کورکورانه است. صرفاً اینکه راه داشته باشند، نودها به هم اتصال داشته باشند. در DFS اول جواب شماره صفر را می‌گرفتیم. چرا نمی‌گرفتیم؟ هیچ ایده‌ای نداریم چون ریشه بود. بعدش یک را گرفتیم، چرا سه را نگرفتیم؟ چون جواب، جواب ما نیست، این بود که بهتر با یک حرکت می‌رسیدیم. هیچ ایده‌ای چون نداشتیم. این‌ها را برای همین جستجوهای کورکورانه می‌گوییم (Uninformed Search).</p><h2>استراتژی‌های جستجوی آگاهانه (Informed Search)</h2><p>خب، گفتیم که چکار کنیم؟ یک کمی بهتر کنیم. استراتژی جستجویمان را چکار کنیم؟ می‌آییم به خود جواب‌ها وزن می‌دهیم. یعنی به خود این نودها یک وزن، یک عددی اختصاص می‌دهیم، یک کیفیتی. می‌گوییم به یک متخصص، به یک پزشک، به یک رادیولوژیست، فرض کن مثلاً این جواب‌ها را بر اساس احتمال، بر اساس هر چیزی که خودش ای‌بی‌سی‌دی می‌داند، یک وزنی بدهد.</p><p>خب، چکار می‌کنیم؟ این سورس ما هست، این هم مثلاً هدف ما است. می‌خواهیم برسیم به هدفمان. گل ما هست.</p><h3>جستجوی حریصانه (Greedy Search)</h3><p>حریصانه است. یعنی دو تا قدم بعدی را نمی‌بیند، صد تا قدم بعدی را نمی‌بیند. فقط گام بعدی‌اش را می‌بیند. حریص است. هی می‌گوید من مثلاً طلا بخرم، نمی‌داند فردا طلا ریزشی شود. می‌گوید بیت‌کوین بخرم، نمی‌داند فردا بیت‌کوین ریزشی شود. حریص. فقط امروز را نگاه می‌کند. آقا بیت‌کوین چون امروز سود کرده، بخرم. نمی‌داند اخلاق و ... حریص است. فقط قدم‌های کوتاه یا قدم بعدی را می‌بیند.</p><p>خب، قدم بعدی کدام باید باشد؟ این وزنش ۹ است، این وزنش ۵ است. آنی که کمتر است دیگر. می‌خواهیم با هزینه کمتر برسیم. پس این را می‌گیریم. دوباره این به این راه دارد، به این راه دارد. کدام را انتخاب می‌کند؟ این را. انتخاب می‌کند و از این می‌رود. برای همین ممکن است توی یک گراف، جواب درست نباشد. استراتژی‌اش این است: بهترین قدم بعدی. شما وقتی می‌خواهید شطرنج بازی کنید، این استراتژی اصلاً درست است؟ نه، شما معمولاً دو تا سه تا قدم بعدی را می‌بینید دیگر. این استراتژی درست نیست.</p><h3>الگوریتم A* (A-Star Algorithm)</h3><p>یک کمی بهترش کردیم. جستجوی A* را گفتیم. علاوه بر اینکه کیفیت راه‌حل‌ها را چی کند؟ نحوه حرکت بین این راه‌حل‌ها را هم در نظر بگیرد. یعنی شما فرض کنید که مثال بزنم، شاید برایتان هر مثالی می‌تواند باشد. فرض کنید از یک شهری می‌خواهید بروید به یک شهر دیگر، یک فاصله بین شهرها است، یک ترافیک داخل شهرها است. فرض کنید حالا هر مسئله‌ای.</p><p>گفت چکار کنیم مثلاً؟ بیاییم مسئله را بشکنیم به دو تا زیرمسئله: هزینه حرکتمان از نقطه شروع به این نقطه، به اضافه هزینه‌ای که این تا مقصد ما است. کاری نداریم. این‌ها را قبلاً حساب کردنش را گفتیم. پس دو تا آیتم را در نظر گرفتیم. این هم در نظر گرفتیم.</p><p>خیلی ساده. از سورس شروع می‌کند، به کجاها راه دارد؟ به A و B. مثال: از S به A می‌شود ۳+۸ و از S به B می‌شود ۲+۵، یعنی ۷. می‌آییم توی B. B می‌تواند به C برود، می‌تواند به E برود. چکار می‌کند؟ از B می‌گوید: من تا اینجا هرچیزی که آمدم به اضافه این عدد و این هم به اضافه این. این را در نظر نمی‌گیرد. می‌گوید ۲+۴+۳ و ۲+۱+۴. خب، این‌ها را جمع می‌کند. پس ۹ و ۷. ۷ کمتر است و این.</p><p>این‌ها را تا آخر ادامه می‌دهد دیگر. این B و این را محاسبه می‌کند. یعنی هر مرحله، وقتی از اینجا رد شد، دیگر این‌ها را در نظر نمی‌گیرد. این هم یک استراتژی جستجو است.</p><h2>انتقال به الگوریتم‌های بازی و یادگیری</h2><p>خب، پس ما فهمیدیم که هیوریستیک‌ها، ابتکارها یا اکتشاف‌ها (هر تلفظی که بهش می‌دهم، ابتکار به نظر من قشنگ‌ترین معادل فارسیش است) مؤثر واقع شدند. این اولین گام بود، اولین جرقه‌هایی بود که به سمت هوش مصنوعی رفت. فهمیدیم که اگر ما کامپیوترها، مکانیک‌ها، یعنی پردازش مکانیکی این‌ها را بتوانیم با وارد کردن یک سری هیوریستیک چکار کنیم؟ بهترشان کنیم.</p><p>خب، برای ۵۰ سال پیش که کامپیوتر اختراع شده بود و نشده بود، کامپیوتر امروزی، این یک چیز خیلی عجیب و غریب بود.</p><p>آمدیم یک کم جلوتر، این تئوری گیم (نظریه بازی‌ها) این‌ها آمد. این‌ها را آشنا شدید باهاش. بعد دوباره خیلی کلی شد و بازی‌هایی که در آن رقابت هست. یعنی بازی‌هایی هست که برد یک نفر معادل باخت نفر دیگر است. بهش می‌گویند استراتژی‌های minimax. برد یک نفر معادل باخت یک نفر دیگر است.</p><p>مثلاً شطرنج، Go. این‌ها بازی‌های کلاسیک هستند. چرا این‌ها معروف شدند؟ چون شرکت‌های بزرگ آمدند برای این‌ها مسابقات جهانی گذاشتند. مثلاً Deep Blue، کاسپاروف را شکست داد. با یک روش حلی، Deep Blue (با A* یا با همین minimax) کاسپاروف را شکست داد و این خیلی معروف شد. یا در ۲۰۱۳ یا ۲۰۱۶ بود که بازی Go بود (AlphaGo).</p><p>AlphaGo در کره‌جنوبی بود و شکست داد. DeepMind که مستندش هم هست (در پس‌زمینه آن را حتماً ببینید). کلاً استراتژی‌اش خیلی ساده است: می‌گوید تو همیشه یک حرکت را انتخاب کن، یک به اصطلاح مسیری را برو که حداکثر امتیاز را برای خودت داشته باشی و وقتی حداکثر امتیاز را برای خودت داشتی، خودبه‌خود حداقل امتیاز برای طرف مقابلت خواهد بود. مثلاً بازی دوز که شبیه دوز ما است ولی واقعاً دوز نیست. این فرق با دوز ما دارد. توی دوز ما سه تایی را جابجا می‌کنیم، ولی این جابجایی پیشرفته است. کل حالت‌هایش چقدر است؟ ۲۵۵ هزار تا حالت. با اینکه ۲۵۵ هزار حالت برای ما زیاد است، ولی یک عدد کوچک محسوب می‌شود و محدود است. کران دارد، مشخص است. از این ۲۵۵ هزار حالت خارج نیست.</p><p>جالب است، توی بازی‌ها همیشه سعی کنید حرکت اول را شما انجام بدهید. چرا؟ به خاطر اینکه احتمال اینکه شما برنده بشوید، دو برابر می‌شود. ۳۱ هزار برابر به ۷۷ هزار. تقریباً دو برابر می‌شود. پس حرکت اول شما احتمال برنده شدنتان را دو برابر می‌کند. البته احتمال کمی هم برای مساوی شدن هست.</p><p>یک مثال زده. می‌گوید توی این بازی، اگر X برنده شود، مثبت ۱۰ امتیاز (یعنی X توی یک ستون یا یک سطر یا یک قطر قرار بگیرد) و اگر O چکار کند؟ منفی ۱۰ امتیاز و مساوی هم برابر است با صفر. خب، فرض کنیم که نوبت X هست الان. می‌تواند یکی از این سه جا را انتخاب کند. اگر بگذارد اینجا، خب، من فقط بگویم: می‌تواند اینجا بگذارد، می‌تواند وسط بگذارد، می‌تواند بغل. اگر بغل بگذارد که مثبت ۱۰ امتیاز و بازی تمام می‌شود. می‌ماند این دو تا. اگر اینجا بگذارد، گام بعدی‌اش چیست؟ نگاه کنید، ما می‌توانیم در minimax چند تا گام بعدی را داشته باشیم. در شطرنج می‌توانیم ۱۰۰ هزار گام بعدی را محاسبه کنیم.</p><p>اینجا خب محدود است، ۲۵۵ هزار است. اگر اینجا بگذارد، بعدش نوبت کیست؟ نوبت O. O می‌تواند اینجا بگذارد یا اینجا بگذارد. که اگر مثلاً اینجا بگذارد، بازی می‌شود مساوی و اگر اینجا بگذارد، O برنده شده و بازی تمام می‌شود. یک سوال: توی گام دومی، که نود سمت راست پایین باشد، چرا وسط X شد؟ احتمالاً اشتباه شده. خب، در واقع. آره، اشتباه است.</p><p>فهمیدید ماجرا چیست؟ یعنی این حالت‌ها را هر دفعه حساب می‌کند. یعنی این را توی حلقه for می‌گذارد، توی همه این حالت‌ها را حساب می‌کند. شما یک برنامه نویسید که دوز بازی کند، شطرنج بازی کند. همه حالت‌ها را، مثلاً تا ۵ قدم بعدی، مثلاً در یک بازی شطرنج، می‌شود ۲۰۰ هزار حالت. خب، شما ۲۰۰ هزار حالت را همه حالت‌هایش را محاسبه می‌کنید و برای هر حالت امتیازش را به دست می‌آورید.</p><p>این استراتژی minimax است. هدفم چی بود قضیه؟ این که فهمیدید که هنوز یک گام دیگر می‌توانیم یک هیوریستیک بهتری اضافه کنیم. ما از الگوریتم‌های خام و کورکورانه شروع کردیم، داریم می‌آییم جلو، ولی همه این‌ها هوش مصنوعی نیست. نمی‌تواند صحبت کند. فقط برای بازی. حتی برای کارهای ساده دیگر هم به درد نمی‌خورد. مثلاً یک مسئله ریاضی را نمی‌فهمد. خاص هستند، جنرال (عمومی) نیستند.</p><h3>الگوریتم‌های بهینه‌سازی الهام گرفته از طبیعت (Nature-Inspired Optimization Algorithms)</h3><p>در استراتژی minimax چیزی را فهمیدیم: ما می‌توانیم یک جستجوی محلی، مثلاً ۵ قدم بعدی، ۱۰ قدم بعدی، ۲۰ قدم بعدی، بسته به کامپیوتری که داریم و قدرت پردازش، انجام بدهیم. بعد دوباره کشف می‌کنیم بر اساس هیوریستیکی که داشتیم. ولی برای یک بازی خیلی بزرگ مثل چکرز که ۱۵۰ میلیارد میلیارد حالت دارد، این که شما چقدر می‌توانید جستجوی محلی هم انجام بدهید، خیلی بزرگ نیست.</p><p>این مسائل که اینجوری هستند، مربوط به زمان معقولی نیستند، جزو NP-hardها هستند. این هیوریستیک‌ها حالا با هم تغییر کردند (تعداد گام‌ها). جستجوی محلی بود، هیوریستیک باید عوض شود. دوباره که فهمیدیم هیوریستیک بهتری است، آمدیم یک الگوریتم دیگر درست کردیم به نام الگوریتم \"کوهنوردی\" (Hill Climbing) یا صعود به تپه (Slope of the Hill). هر اصطلاحی که فکر می‌کنید به فارسیش نزدیک باشد.</p><p>مسائل ما معمولاً یک جواب بهتری داریم، یک جواب بهینه و بهترین. ولی چند تا جواب محلی بهینه‌تر هم داریم. معمولاً مسائل قبلی‌ها، حالا اینجا معمولاً نمی‌رسند. این استراتژی جستجوی ما، این الگوریتم، یا این‌ها هم همین شکلی‌اند. شما اگر جستجو کنید، کلی اسم عجیب و غریب دارند. مثلاً الگوریتم مورچه داریم، الگوریتم زنبور عسل داریم، الگوریتم نمی‌دانم پروانه داریم، الگوریتم برگ فلان داریم، الگوریتم خاکستری داریم. کلاً یعنی ایده‌های طبیعت را می‌گیرند، این‌ها را مدل می‌کنند به زبان ریاضی و می‌دهند به کامپیوتر. فقط جواب می‌دهد.</p><p>یکی از این اولین تلاش‌ها این الگوریتم کوهنوردی است. می‌گوید ما هرچه که اول یک نقطه رندوم را انتخاب می‌کنیم توی این مسیر، فضای جواب‌ها (مثل آن درخت و گراف این‌ها نبود که حتماً ریشه شروع کنیم). یک دانه را انتخاب می‌کند. می‌گوید یک دانه بالا، یک دانه به سمت مثلاً جلو برود، یک دانه به سمت عقب برگردد (هر جایی که هست). فرض کنید فقط به دو طرف می‌رود. آنی که جواب بهتری می‌دهد را انتخاب می‌کند. درسته؟ یعنی چی؟ یعنی می‌گوید که اینجا که هستی، یک دانه به پایین برو، یک دانه به بالا. از کجا می‌فهمد بالا پایین را؟ از شیب خط. شیب خط یعنی چی؟ شیب خط یعنی مشتق مرتبه اول. مشتق مرتبه دوم. مشتق مرتبه دوم. یک دانه عقب، یک دانه جلو. اگر مثبت بود، برو بالا، اگر منفی بود، بیا پایین.</p><p>این پس الگوریتم، این استراتژی جستجو می‌گوید آقا برو بالا. می‌آید اینجا، ولی می‌خواهد حرکت کند، ای من دارم می‌روم پایین. اینجا بالا نیست. این را به عنوان جواب برمی‌گرداند. اما این بهترین جواب است؟ نه. بهترین جواب این است که اگر به جای اینکه می‌رفت بالا، می‌آمد عقب، اینجا بهتر بود. بهتر بود که آنجا می‌آمد و شروع می‌کرد، بلکه به جواب بهینه‌تری می‌رسید. پس این استراتژی هنوز کامل نیست. ولی خب اولین تلاش ما است.</p><p>نگاه کنید، اینجا ما هنوز هیوریستیکیم. اصلاً یادگیری نداریم. ما داریم با حل می‌کنیم. علاوه بر اینکه ما چند نوع دیگر کردن داشتیم توی مسئله: یکی اینکه این حالت شانه‌ای بوده. یعنی شاید پایین، مسطح و بعدش برود بالا. اینجا گیر می‌کردیم. این الان مسطح است. نه دونه به عقب داریم، نه جلو. یک گام می‌رود به عقب، می‌بیند تغییری ندارد. یک گام می‌رود به جلو، می‌بیند تغییری ندارد. وایمیستد اینجا، گیر می‌کند. دوباره همین‌طور، اینجا هم مسطح است. یک قله مسطح. می‌رود جلو، می‌رود عقب، می‌بیند آنجا گیر می‌کند. می‌گوید به هر حال چه جلو بروم، چه عقب بروم، تغییری ندارم.</p><p>پس این ایرادات اینجوری داشت. ولی خب خیلی ساده بود، یعنی objective function شما هرچیزی می‌تواند باشد: دقت، سود، خطا، هرچیزی. بسته به مسئله. متوجه شدید؟ الگوریتمش هم خیلی ساده است. یک خط توضیح داده شد. می‌گوید یک حالت اولیه را به صورت رندوم انتخاب می‌کند و بر اساس آن تابع، objective شما، تابع هزینه شما، هر دفعه موقعیت فعلی‌اش را با موقعیت بعدی و قبلی‌اش محاسبه می‌کند. بعد بهترین همسایه‌اش را انتخاب می‌کند و می‌رود به آن سمت. حالا اگر بهتر بود، دوباره این گام را تکرار می‌کند. در غیر این صورت، بالاخره توی یک موقعیت مسطح یا توی یک ماکسیمم، بهترین جواب (چه لوکال، چه گلوبال) گیر کرده است و این شرط توقف الگوریتم است. حالا اگر خوش‌شانس باشید، می‌رود به گلوبال، اگر بدشانس باشید (که اغلب این‌طوری هست) توی لوکال گیر می‌کند. برای همین گفتیم که باز تحقیقات ادامه پیدا کرد.</p><p>یک الگوریتم دیگر. حالا مزایایش را هم گفته است. ساده است و... معایبش هم که مشخص است. یک الگوریتم دیگر به نام الگوریتم \"خنک کردن شبیه‌سازی‌شده\" یا Simulated Annealing. این را هم با هم بررسی می‌کنیم. خیلی ساده است. الان واقعاً... یک فلز خاصی می‌خواهید یک شکل خاصی بگیرد، دو حالت دارد: اینکه شما بگذارید و یک دفعه درش بیاورید توی آب بگذارید. درجا سرد می‌شود. مثلاً چاقو و این‌ها را دیدید این کار را می‌کنند، تیز بشود و یک حالت سختی داشته باشد. ولی خیلی جاها هست که نه، شما نیاز دارید که آن سطح صاف و حالت ... واقعاً این را می‌دانید. می‌گذارند دمای کوره را پله پله، فرکانس خاصی کم می‌کنند. یک دفعه سردش نمی‌کنند. این در مورد فلزات است.</p><p>حالا برای هر فلزی، یک رفتار خنک‌کردن دارد. اگر بخواهیم این ایده را بیاورم توی چی؟ اینجا خب اصطلاحاتش فرق می‌کند. از انرژی استفاده کردند، تابع هدفش همان است. می‌گوید اولی که از چیز درمی‌آید، اولی که انتخاب می‌کنیم، اینجا مسئله ما بهینه‌سازی است. کمینه‌سازی. اغلب ما در دنیا بیشتر مسائل بهینه‌سازی را به عنوان مینیمم کردن، به عنوان مینیمم کردن چی؟ خطا. اغلب کاربردهای روزمره هوش مصنوعی، شما یک ریباند گرفته مثال زده و... هر چیزی که فکر می‌کنید، شما دنبال این هستید که خطایتان را کم کنید. پس برای همین شما می‌خواهید... یه مقداری کمتر... بیشتر دنبال کمتر کردن هزینه. بله، مسئله شما اینجوری است: کمتر کردن هزینه. نه کمتر کردن خطا. نوعش است که کمترش می‌کند. کاملاً درست است. ما دنبال نوع مسئله هستیم. شما یک مسئله بهینه‌سازی دارید که می‌خواهید بهترینش را پیدا کنید. بهترینش حداکثری است یا کمترین؟ مثلاً می‌گویم از نظر ما این‌ها کاربردی‌ترین مسائل وقتی داریم بهینه‌سازی می‌کنیم، یعنی کمتر کردن هزینه.</p></div>','completed','2025-11-09 06:38:14','2025-12-03 04:33:26',NULL,NULL,0,NULL,1,NULL),(50,4,1,'هوش مصنوعی و داده (جلسه اول)','1404/07/07','<div style=\"max-width: 100%; overflow-x: hidden; word-wrap: break-word; padding: 1rem; box-sizing: border-box;\"><div style=\"max-width: 100%; overflow-x: hidden; word-wrap: break-word; padding: 1rem; box-sizing: border-box;\"><h1>مقدمه و نکات اداری</h1><p>در ابتدای جلسه، نکات اداری و آموزشی مهمی مطرح شد:</p><ul><li>امتحان میان‌ترم در تاریخ ۱۹ آبان برگزار خواهد شد. این جلسه زوج است و تنها دو ساعت زمان برای تدریس باقی مانده است.</li><li>این درس بیشتر جنبه حفظی و جغرافیایی دارد و محاسبات زیادی ندارد، فقط چند الگوریتم کلیدی وجود دارد.</li><li>برای مطالعه، هر اسلاید یا لکچر معمولاً شامل ۲ تا ۴ فصل کوتاه است.</li><li>هر فصل دارای اهداف مشخصی است. برای درک بهتر مطالب هر لکچر، کافی است اهداف فصل را بررسی کرده و سعی کنید به سوالات مربوط به آن‌ها پاسخ تشریحی دهید. پاسخ‌های کوتاه کافی نیستند و باید کامل و جامع باشند.</li><li>در طول کلاس، مشارکت فعال داشته باشید و سوالات خود را بپرسید.</li><li>پیشنهاد شد که برای درک بهتر مطالب، هر آنچه به ذهنتان می‌رسد را کامل بنویسید، حتی اگر فکر می‌کنید اشتباه است.</li></ul><h2>هوش مصنوعی (AI)</h2><p>در جلسه گذشته درباره زیرساخت‌های ذهنی هوش مصنوعی صحبت شد و به این نتیجه رسیدیم که هوش مصنوعی فعلاً تعریف خاص و دقیقی ندارد.</p><ul><li>**مصنوعی بودن:** مشخص است که هوش مصنوعی ارگانیک یا طبیعی نیست.</li><li>**هوش:** بحث هوش هنوز هم برای موجودات ذی‌شعور (انسان) تعریف دقیقی ندارد، چه رسد به کامپیوترها و ریاضیات.</li></ul><h3>تعریف ما از هوش مصنوعی</h3><p>با توجه به عدم وجود تعریف دقیق، ما خودمان را ملاک قرار دادیم و هوش مصنوعی را اینگونه تعریف کردیم:</p><blockquote>یک نرم‌افزاری که بتواند تفکر (فکر کردن) و مهم‌تر از آن، عمل کردن (تصمیم‌گیری) انسان‌ها را شبیه‌سازی کند.</blockquote><h3>انقلاب هوش مصنوعی</h3><p>انقلابی که باعث شد هوش مصنوعی وارد همه حوزه‌ها و رشته‌ها (از زن‌شناسی و زیست‌شناسی تا پزشکی، پرستاری، نانوایی، شیمی، اتومبیل و غیره) شود، توانایی ماشین‌ها در درک زبان طبیعی ماست.</p><ul><li>روبات‌ها سال‌هاست اختراع شده‌اند، اما توانایی درک زبان طبیعی انسان باعث شده است که بتوانند با ما ارتباط برقرار کنند و وارد زندگی ما شوند.</li><li>پردازش زبان طبیعی (NLP) بسیار پیشرفت کرده است و دیگر نیازی نیست که ما زبان موجود غیرارگانیک (کامپیوتر) را بدانیم؛ آن‌ها زبان ما را می‌فهمند.</li></ul><h2>داده (Data)</h2><p>فصل دوم به بحث داده اختصاص دارد.</p><ul><li>**اهمیت داده:** داده (دیتا) همان چیزی است که هوش مصنوعی امروز را هوش مصنوعی کرده است، نه قدرت الگوریتم‌ها. الگوریتم‌های هوش مصنوعی هنوز در مراحل اولیه هستند و ریاضیات پشت آن‌ها بسیار ساده است (مانند y = ax + b).</li><li>**هدف درس:** این درس در مقطع کارشناسی بیشتر به دنبال ایجاد یک تعریف و آماده‌سازی ذهن شما برای مقاطع بالاتر است.</li></ul><h3>داده خام و دانش</h3><p>اگر پنج عدد (مثلاً ۲، ۷، ۴.۵، ۱۲، ۱۹.۵) را بدون هیچ توضیحی داشته باشیم، این‌ها \"دیتای خام\" هستند. زمانی که کنار هر عدد، اسم یک درس را بنویسیم (مثلاً نمره یک درس)، این دیتا معنی پیدا کرده و به \"دانش\" تبدیل می‌شود.</p><ul><li>**اینسایت (Insight):** کاری که در هوش مصنوعی انجام می‌شود، استخراج اینسایت یا دانش از دیتاست.</li><li>**دیتا ساینس (Data Science):** اگر دانش خاصی از دیتا استخراج شود، به آن دیتا ساینس می‌گویند.</li><li>**دیتا ماینینگ (Data Mining):** دیتا ماینینگ بیشتر بر روش‌های استخراج داده تمرکز دارد، در حالی که دیتا ساینس بر خود دانش استخراج شده تمرکز می‌کند.</li><li>**منسوخ شدن:** بسیاری از مشاغل مرتبط با دیتا ساینس و دیتا ماینینگ به دلیل ظهور مدل‌های زبان بزرگ (LLMs) در حال منسوخ شدن هستند، زیرا LLMs می‌توانند این کارها را به صورت خودکار و با دقت بالا انجام دهند.</li></ul><h3>بیگ دیتا (Big Data)</h3><p>بیگ دیتا یا کلان‌داده، گرایشی در مهندسی نرم‌افزار است که به تولید داده در مقیاس فوق‌العاده بزرگ (مثلاً ۱۰ به توان ۳۰ یا کوینتیلیون) می‌پردازد.</p><ul><li>**مقیاس داده:** روزانه تا سه کوینتیلیون داده تولید می‌شود.</li><li>**اینترنت سرفیس و دارک:** تنها ۲ تا ۳ درصد اینترنت، اینترنت سرفیس (قابل مشاهده) است و ۹۷ درصد آن اینترنت دارک (غیرقابل مشاهده) است. اطلاعات اینترنت دارک شامل داده‌های شخصی در گوشی‌ها، کامپیوترهای خانگی، سازمان‌ها و ادارات است که به صورت عمومی به اشتراک گذاشته نمی‌شوند.</li><li>**حجم داده:** حجم داده‌های تولید شده بسیار عظیم است و اعداد فعلی ما در برابر آن ناچیز به نظر می‌رسند.</li><li>**مصرف انرژی AI:** هوش مصنوعی به دلیل پردازش و ذخیره‌سازی حجم عظیمی از داده‌ها، مصرف انرژی بسیار بالایی دارد. به عنوان مثال، ۱۰ درصد برق آمریکا توسط دیتاسنترهای هوش مصنوعی مصرف می‌شود که چندین برابر کل مصرف برق ایران است.</li></ul><h3>ویژگی‌های بیگ دیتا (۵V)</h3><p>بیگ دیتا دارای ۵ ویژگی (V) است که هر کدام یک مفهوم بزرگ را شامل می‌شوند:</p><ol><li>**Volume (حجم):** حجم عظیم داده‌های تولید شده.</li><li>**Variety (تنوع):** داده‌ها می‌توانند ساختاریافته یا غیرساختاریافته باشند.</li><h4>داده‌های ساختاریافته و غیرساختاریافته</h4><ul><li>**قبل از ۲۰۰۰:** بیشتر داده‌ها ساختاریافته بودند (مانند جداول اکسل یا فایل‌های CSV). الگوریتم‌های آن زمان فقط می‌توانستند داده‌های ساختاریافته را درک کنند. شرکت‌ها و دولت‌ها اطلاعات را ساختارمند می‌کردند.</li><li>**امروزه:** بیشتر داده‌ها (حدود ۹۹ درصد) غیرساختاریافته هستند (مانند ویدیو، عکس، کامنت‌های شبکه‌های اجتماعی). الگوریتم‌های هوش مصنوعی پیشرفت کرده‌اند و می‌توانند از داده‌های غیرساختاریافته نیز دانش استخراج کنند.</li><li>**کرونا:** همه‌گیری کرونا نیز با ایجاد زیرساخت‌های غیرحضوری، به انفجار اطلاعات و تولید داده‌های غیرساختاریافته کمک کرد.</li></ul><h3>رابطه داده و هوش</h3><p>هرچه داده بیشتر باشد، هوش (پرفورمنس الگوریتم‌های هوش مصنوعی) نیز بیشتر می‌شود. البته این رابطه تا حدی ثابت شده و پس از آن، شیب افزایش پرفورمنس بسیار کم می‌شود. هدف ما ایجاد یک انقلاب جدید در ریاضیات و یادگیری ماشین است تا این شیب دوباره افزایش یابد.</p><h3>اورفیتینگ (Overfitting)</h3><p>اورفیتینگ به معنای بیش‌برازش است؛ یعنی الگوریتم بیش از حد به داده‌های آموزشی خود فیت شده و توانایی تعمیم (Generalization) به داده‌های جدید را از دست می‌دهد.</p><ul><li>**مثال:** خودروی خودران تسلا که در کارخانه یا شهر خاصی آموزش دیده، ممکن است در تهران با اتفاقات جدیدی مواجه شود که قبلاً ندیده است.</li><li>**مدیریت اورفیتینگ:** روش‌های استانداردی برای مدیریت و کاهش اورفیتینگ وجود دارد (مانند میتیگیت کردن اثر آن)، اما نمی‌توان آن را به طور کامل حذف کرد.</li><li>**جنرالایز کردن:** برای جلوگیری از اورفیتینگ، باید الگوریتم را طوری آموزش داد که بتواند جنرالایز شود و الگوهای کلی و مشترک را از داده‌ها یاد بگیرد، نه فقط الگوهای خاص داده‌های آموزشی.</li></ul><h3>منبع داده</h3><p>قبلاً موجودات ارگانیک (انسان، حیوانات، گیاهان) تولیدکننده اصلی داده بودند، اما امروزه بیشتر داده‌ها توسط موجودات غیرارگانیک تولید می‌شوند. در آینده، داده‌های ارگانیک ارزش بسیار بالایی پیدا خواهند کرد و ممکن است برای خرید آن‌ها پول زیادی پرداخت شود.</p><h3>قابل اعتماد بودن و پیش‌بینی‌پذیری (Trustworthiness &amp; Predictability)</h3><ul><li>**قابل اعتماد بودن:** دیتای قابل اعتماد، دیتایی است که در محدوده منطقی و مورد انتظار عمل کند. مثلاً نمرات بین ۰ تا ۲۰ باشند.</li><li>**پیش‌بینی‌پذیری (اینسایت جدید):** دیتای مفید، علاوه بر قابل اعتماد بودن، باید اینسایت‌های جدید و غیرمنتظره‌ای را ارائه دهد که ما قبلاً نمی‌توانستیم آن‌ها را حدس بزنیم.</li></ul><h3>انسان و داده</h3><p>ما انسان‌ها ذاتاً مستعد خطا هستیم و اطلاعات کمی درباره خودمان داریم. بسیاری از کارهای ما عقلانی نیستند. باهوش‌ترین موجود زنده روی زمین مورچه است که ۲۴۰ میلیون سال عمر دارد، در حالی که انسان امروزی (هوموساپینس) حدود ۱ میلیون سال عمر دارد.</p><ul><li>**تهاجمی بودن انسان:** انسان‌ها به شدت تهاجمی هستند و همه موجودات را از بین می‌برند.</li><li>**نقش زنان در بقا:** بقای گونه انسان به دلیل نرخ باروری زنان است.</li><li>**اخلاق و فلسفه:** این مباحث جنبه‌های فلسفی و اخلاقی زیادی دارند و می‌توانند به کشفیات جدید منجر شوند.</li></ul><h3>مدیریت و پاکسازی داده</h3><ul><li>**نظارت بر ورودی‌ها:** ورودی‌های انسانی باید نظارت و کنترل شوند (مثلاً از طریق فرم‌ها در اپلیکیشن‌ها و وب‌سایت‌ها) تا از ورود داده‌های نامعتبر جلوگیری شود.</li><li>**فشرده‌سازی:** داده‌ها، به خصوص متن، می‌توانند تا حد زیادی فشرده شوند (مثلاً به یک صدم حجم اصلی).</li><li>**عدم حذف داده:** در سیستم‌های بیگ دیتا، چیزی به نام حذف (Delete) داده وجود ندارد. اطلاعات حتی پس از حذف توسط کاربر، در سرورها ذخیره می‌شوند.</li></ul><h3>اطلاعات شناسایی‌پذیر شخصی (PII)</h3><p>PII شامل اطلاعاتی مانند چهره، کد ملی، شماره پلاک و هر اطلاعاتی است که بتواند یک فرد را شناسایی کند.</p><ul><li>**پاکسازی PII:** هر اطلاعاتی از نوع PII باید پاکسازی شود (مثلاً بلور کردن چهره‌ها در نقشه‌های گوگل).</li><li>**عدم سوءاستفاده:** نباید از اطلاعات برای حدس زدن PII استفاده کرد.</li><li>**نقض حریم خصوصی:** دولت‌ها اغلب اطلاعات آماری از مناطق جمع‌آوری می‌کنند و سپس با استفاده از آن، افراد را شناسایی می‌کنند.</li><li>**دقت بالا:** اپلیکیشن‌های تشخیص چهره چینی با دقت ۹۹.۹۹ درصد افراد را شناسایی می‌کنند.</li></ul><h3>یادگیری عمیق (Deep Learning)</h3><p>یادگیری عمیق، اساس هوش مصنوعی امروزی است. در یادگیری عمیق، الگوریتم خودش می‌فهمد که چه ویژگی‌هایی را برای تشخیص بررسی کند، برخلاف روش‌های قدیمی که مهندسان باید ویژگی‌ها را به صورت دستی تعریف می‌کردند.</p><ul><li>**مزایا:** یادگیری عمیق خطای کمتری دارد و می‌تواند با موانعی مانند ماسک، عینک یا ریش نیز افراد را شناسایی کند.</li><li>**مدل‌های متن‌باز:** مدل‌های متن‌باز مانند YOLO برای تشخیص چهره و اشیا وجود دارند.</li><li>**ترینینگ مدل:** این مدل‌ها باید روی دیتاست‌های خاص هر کاربرد، دوباره ترین شوند.</li></ul><h3>مانیپولیت (Manipulate) و منیپولیت (Manicure)</h3><ul><li>**منیپولیت (Manicure):** به معنای مرتب کردن و سازماندهی داده‌هاست، بدون تغییر ذات آن‌ها.</li><li>**مانیپولیت (Manipulate):** به معنای دستکاری و تغییر ذات داده‌هاست.</li><li>**قاعده:** به عنوان یک متخصص، شما حق دارید داده‌ها را منیپولیت کنید، اما حق ندارید آن‌ها را مانیپولیت کنید. مانیپولیت کردن داده‌ها باعث اورفیتینگ مدل می‌شود.</li><li>**دیتای خام:** دیتای خام باید تا حد امکان دست‌نخورده و نزدیک به واقعیت باقی بماند.</li></ul><h3>دیتای گمشده (Missing Data)</h3><p>سه نوع دیتای گمشده وجود دارد که نحوه برخورد با آن‌ها متفاوت است:</p><ol><li>**دیتای حیاتی:** اگر فیلدهای حیاتی (مانند کد ملی) گم شده باشند، آن رکورد به درد نمی‌خورد و باید حذف شود.</li><li>**دیتای غیرحیاتی جزئی:** اگر فیلدهای غیرحیاتی (مانند ۲۰ درصد از یک ستون) گم شده باشند، می‌توان با میانگین یا میانه، جای خالی را پر کرد.</li><li>**دیتای غیرحیاتی عمده:** اگر بیشتر یک ستون (مثلاً ۸۰ درصد) گم شده باشد، نمی‌توان با میانگین‌گیری آن را پر کرد و باید از شرکت درخواست دیتای سالم‌تر کرد.</li></ol><h3>ناترازی داده (Data Imbalance)</h3><p>ناترازی داده زمانی رخ می‌دهد که داده‌ها از نظر منطقی یکدیگر را نقض کنند (مثلاً مدل شما آقایان را باحجاب تشخیص دهد).</p><h3>اخلاق (Ethics) و سوگیری (Bias)</h3><p>اخلاق و سوگیری در هوش مصنوعی بسیار مهم هستند و متأسفانه امروزه به شدت در حال افزایش‌اند.</p><ul><li>**سانسورشیپ (Censorship):** بسیاری از LLMs دارای سانسورشیپ هستند و اطلاعات مذهبی، سیاسی یا هر اطلاعاتی که آسیب‌رسان تلقی شود را حذف می‌کنند.</li><li>**سوگیری ذاتی:** داده‌های ارگانیک ذاتاً سوگیرانه هستند، زیرا هر فردی بر اساس منافع خود صحبت می‌کند. این سوگیری در مقیاس بزرگ در اینترنت وجود دارد.</li><li>**مثال:** اگر از هوش مصنوعی بپرسید که پرستار مرد است یا زن، ممکن است به دلیل سوگیری در داده‌های آموزشی، پاسخ دهد که زن است، در حالی که بسیاری از پرستاران مرد هستند.</li><li>**قوانین:** قانون‌گذاران در سطح دولت‌ها هنوز قوانین مشخصی برای مقابله با سوگیری هوش مصنوعی ندارند.</li></ul><h3>عدم شهود واقعی (Lack of True Intuition)</h3><p>هوش مصنوعی نمی‌تواند شهود واقعی داشته باشد. مثلاً اگر به یک کودک دو ساله درباره خطرات عقرب بگویید، او باز هم ممکن است دستش را به سمت آن ببرد، زیرا شهود خطر در او هنوز شکل نگرفته است.</p><h3>نکات پایانی</h3><ul><li>**اطلاعات آنلاین:** هر اطلاعاتی که در اینترنت وجود دارد، ممکن است دستکاری شود.</li><li>**دیتای اصلی:** همیشه یک کپی ایزوله از دیتای خام و اصلی خود داشته باشید.</li><li>**کلین کردن:** قبل از ورود داده به الگوریتم هوش مصنوعی، باید آن را منیپولیت (کلین) کنید.</li><li>**لاس شدن داده:** در فرآیند کلین کردن، خواه‌ناخواه بخشی از داده‌ها از دست می‌روند.</li><li>**اسکرین اسکرپینگ (Screen Scraping):** به معنای استخراج محتوا از صفحات وب است.</li></ul></ol></div></div>','<div style=\"max-width: 100%; overflow-x: hidden; word-wrap: break-word; padding: 1rem; box-sizing: border-box;\"><h1>مقدمه و نکات اداری</h1><p>در ابتدای جلسه، نکات اداری و آموزشی مهمی مطرح شد:</p><ul><li>امتحان میان‌ترم در تاریخ ۱۹ آبان برگزار خواهد شد. این جلسه زوج است و تنها دو ساعت زمان برای تدریس باقی مانده است.</li><li>این درس بیشتر جنبه حفظی و جغرافیایی دارد و محاسبات زیادی ندارد، فقط چند الگوریتم کلیدی وجود دارد.</li><li>برای مطالعه، هر اسلاید یا لکچر معمولاً شامل ۲ تا ۴ فصل کوتاه است.</li><li>هر فصل دارای اهداف مشخصی است. برای درک بهتر مطالب هر لکچر، کافی است اهداف فصل را بررسی کرده و سعی کنید به سوالات مربوط به آن‌ها پاسخ تشریحی دهید. پاسخ‌های کوتاه کافی نیستند و باید کامل و جامع باشند.</li><li>در طول کلاس، مشارکت فعال داشته باشید و سوالات خود را بپرسید.</li><li>پیشنهاد شد که برای درک بهتر مطالب، هر آنچه به ذهنتان می‌رسد را کامل بنویسید، حتی اگر فکر می‌کنید اشتباه است.</li></ul><h2>هوش مصنوعی (AI)</h2><p>در جلسه گذشته درباره زیرساخت‌های ذهنی هوش مصنوعی صحبت شد و به این نتیجه رسیدیم که هوش مصنوعی فعلاً تعریف خاص و دقیقی ندارد.</p><ul><li>**مصنوعی بودن:** مشخص است که هوش مصنوعی ارگانیک یا طبیعی نیست.</li><li>**هوش:** بحث هوش هنوز هم برای موجودات ذی‌شعور (انسان) تعریف دقیقی ندارد، چه رسد به کامپیوترها و ریاضیات.</li></ul><h3>تعریف ما از هوش مصنوعی</h3><p>با توجه به عدم وجود تعریف دقیق، ما خودمان را ملاک قرار دادیم و هوش مصنوعی را اینگونه تعریف کردیم:</p><blockquote>یک نرم‌افزاری که بتواند تفکر (فکر کردن) و مهم‌تر از آن، عمل کردن (تصمیم‌گیری) انسان‌ها را شبیه‌سازی کند.</blockquote><h3>انقلاب هوش مصنوعی</h3><p>انقلابی که باعث شد هوش مصنوعی وارد همه حوزه‌ها و رشته‌ها (از زن‌شناسی و زیست‌شناسی تا پزشکی، پرستاری، نانوایی، شیمی، اتومبیل و غیره) شود، توانایی ماشین‌ها در درک زبان طبیعی ماست.</p><ul><li>روبات‌ها سال‌هاست اختراع شده‌اند، اما توانایی درک زبان طبیعی انسان باعث شده است که بتوانند با ما ارتباط برقرار کنند و وارد زندگی ما شوند.</li><li>پردازش زبان طبیعی (NLP) بسیار پیشرفت کرده است و دیگر نیازی نیست که ما زبان موجود غیرارگانیک (کامپیوتر) را بدانیم؛ آن‌ها زبان ما را می‌فهمند.</li></ul><h2>داده (Data)</h2><p>فصل دوم به بحث داده اختصاص دارد.</p><ul><li>**اهمیت داده:** داده (دیتا) همان چیزی است که هوش مصنوعی امروز را هوش مصنوعی کرده است، نه قدرت الگوریتم‌ها. الگوریتم‌های هوش مصنوعی هنوز در مراحل اولیه هستند و ریاضیات پشت آن‌ها بسیار ساده است (مانند y = ax + b).</li><li>**هدف درس:** این درس در مقطع کارشناسی بیشتر به دنبال ایجاد یک تعریف و آماده‌سازی ذهن شما برای مقاطع بالاتر است.</li></ul><h3>داده خام و دانش</h3><p>اگر پنج عدد (مثلاً ۲، ۷، ۴.۵، ۱۲، ۱۹.۵) را بدون هیچ توضیحی داشته باشیم، این‌ها \"دیتای خام\" هستند. زمانی که کنار هر عدد، اسم یک درس را بنویسیم (مثلاً نمره یک درس)، این دیتا معنی پیدا کرده و به \"دانش\" تبدیل می‌شود.</p><ul><li>**اینسایت (Insight):** کاری که در هوش مصنوعی انجام می‌شود، استخراج اینسایت یا دانش از دیتاست.</li><li>**دیتا ساینس (Data Science):** اگر دانش خاصی از دیتا استخراج شود، به آن دیتا ساینس می‌گویند.</li><li>**دیتا ماینینگ (Data Mining):** دیتا ماینینگ بیشتر بر روش‌های استخراج داده تمرکز دارد، در حالی که دیتا ساینس بر خود دانش استخراج شده تمرکز می‌کند.</li><li>**منسوخ شدن:** بسیاری از مشاغل مرتبط با دیتا ساینس و دیتا ماینینگ به دلیل ظهور مدل‌های زبان بزرگ (LLMs) در حال منسوخ شدن هستند، زیرا LLMs می‌توانند این کارها را به صورت خودکار و با دقت بالا انجام دهند.</li></ul><h3>بیگ دیتا (Big Data)</h3><p>بیگ دیتا یا کلان‌داده، گرایشی در مهندسی نرم‌افزار است که به تولید داده در مقیاس فوق‌العاده بزرگ (مثلاً ۱۰ به توان ۳۰ یا کوینتیلیون) می‌پردازد.</p><ul><li>**مقیاس داده:** روزانه تا سه کوینتیلیون داده تولید می‌شود.</li><li>**اینترنت سرفیس و دارک:** تنها ۲ تا ۳ درصد اینترنت، اینترنت سرفیس (قابل مشاهده) است و ۹۷ درصد آن اینترنت دارک (غیرقابل مشاهده) است. اطلاعات اینترنت دارک شامل داده‌های شخصی در گوشی‌ها، کامپیوترهای خانگی، سازمان‌ها و ادارات است که به صورت عمومی به اشتراک گذاشته نمی‌شوند.</li><li>**حجم داده:** حجم داده‌های تولید شده بسیار عظیم است و اعداد فعلی ما در برابر آن ناچیز به نظر می‌رسند.</li><li>**مصرف انرژی AI:** هوش مصنوعی به دلیل پردازش و ذخیره‌سازی حجم عظیمی از داده‌ها، مصرف انرژی بسیار بالایی دارد. به عنوان مثال، ۱۰ درصد برق آمریکا توسط دیتاسنترهای هوش مصنوعی مصرف می‌شود که چندین برابر کل مصرف برق ایران است.</li></ul><h3>ویژگی‌های بیگ دیتا (۵V)</h3><p>بیگ دیتا دارای ۵ ویژگی (V) است که هر کدام یک مفهوم بزرگ را شامل می‌شوند:</p><ol><li>**Volume (حجم):** حجم عظیم داده‌های تولید شده.</li><li>**Variety (تنوع):** داده‌ها می‌توانند ساختاریافته یا غیرساختاریافته باشند.</li><h4>داده‌های ساختاریافته و غیرساختاریافته</h4><ul><li>**قبل از ۲۰۰۰:** بیشتر داده‌ها ساختاریافته بودند (مانند جداول اکسل یا فایل‌های CSV). الگوریتم‌های آن زمان فقط می‌توانستند داده‌های ساختاریافته را درک کنند. شرکت‌ها و دولت‌ها اطلاعات را ساختارمند می‌کردند.</li><li>**امروزه:** بیشتر داده‌ها (حدود ۹۹ درصد) غیرساختاریافته هستند (مانند ویدیو، عکس، کامنت‌های شبکه‌های اجتماعی). الگوریتم‌های هوش مصنوعی پیشرفت کرده‌اند و می‌توانند از داده‌های غیرساختاریافته نیز دانش استخراج کنند.</li><li>**کرونا:** همه‌گیری کرونا نیز با ایجاد زیرساخت‌های غیرحضوری، به انفجار اطلاعات و تولید داده‌های غیرساختاریافته کمک کرد.</li></ul><h3>رابطه داده و هوش</h3><p>هرچه داده بیشتر باشد، هوش (پرفورمنس الگوریتم‌های هوش مصنوعی) نیز بیشتر می‌شود. البته این رابطه تا حدی ثابت شده و پس از آن، شیب افزایش پرفورمنس بسیار کم می‌شود. هدف ما ایجاد یک انقلاب جدید در ریاضیات و یادگیری ماشین است تا این شیب دوباره افزایش یابد.</p><h3>اورفیتینگ (Overfitting)</h3><p>اورفیتینگ به معنای بیش‌برازش است؛ یعنی الگوریتم بیش از حد به داده‌های آموزشی خود فیت شده و توانایی تعمیم (Generalization) به داده‌های جدید را از دست می‌دهد.</p><ul><li>**مثال:** خودروی خودران تسلا که در کارخانه یا شهر خاصی آموزش دیده، ممکن است در تهران با اتفاقات جدیدی مواجه شود که قبلاً ندیده است.</li><li>**مدیریت اورفیتینگ:** روش‌های استانداردی برای مدیریت و کاهش اورفیتینگ وجود دارد (مانند میتیگیت کردن اثر آن)، اما نمی‌توان آن را به طور کامل حذف کرد.</li><li>**جنرالایز کردن:** برای جلوگیری از اورفیتینگ، باید الگوریتم را طوری آموزش داد که بتواند جنرالایز شود و الگوهای کلی و مشترک را از داده‌ها یاد بگیرد، نه فقط الگوهای خاص داده‌های آموزشی.</li></ul><h3>منبع داده</h3><p>قبلاً موجودات ارگانیک (انسان، حیوانات، گیاهان) تولیدکننده اصلی داده بودند، اما امروزه بیشتر داده‌ها توسط موجودات غیرارگانیک تولید می‌شوند. در آینده، داده‌های ارگانیک ارزش بسیار بالایی پیدا خواهند کرد و ممکن است برای خرید آن‌ها پول زیادی پرداخت شود.</p><h3>قابل اعتماد بودن و پیش‌بینی‌پذیری (Trustworthiness &amp; Predictability)</h3><ul><li>**قابل اعتماد بودن:** دیتای قابل اعتماد، دیتایی است که در محدوده منطقی و مورد انتظار عمل کند. مثلاً نمرات بین ۰ تا ۲۰ باشند.</li><li>**پیش‌بینی‌پذیری (اینسایت جدید):** دیتای مفید، علاوه بر قابل اعتماد بودن، باید اینسایت‌های جدید و غیرمنتظره‌ای را ارائه دهد که ما قبلاً نمی‌توانستیم آن‌ها را حدس بزنیم.</li></ul><h3>انسان و داده</h3><p>ما انسان‌ها ذاتاً مستعد خطا هستیم و اطلاعات کمی درباره خودمان داریم. بسیاری از کارهای ما عقلانی نیستند. باهوش‌ترین موجود زنده روی زمین مورچه است که ۲۴۰ میلیون سال عمر دارد، در حالی که انسان امروزی (هوموساپینس) حدود ۱ میلیون سال عمر دارد.</p><ul><li>**تهاجمی بودن انسان:** انسان‌ها به شدت تهاجمی هستند و همه موجودات را از بین می‌برند.</li><li>**نقش زنان در بقا:** بقای گونه انسان به دلیل نرخ باروری زنان است.</li><li>**اخلاق و فلسفه:** این مباحث جنبه‌های فلسفی و اخلاقی زیادی دارند و می‌توانند به کشفیات جدید منجر شوند.</li></ul><h3>مدیریت و پاکسازی داده</h3><ul><li>**نظارت بر ورودی‌ها:** ورودی‌های انسانی باید نظارت و کنترل شوند (مثلاً از طریق فرم‌ها در اپلیکیشن‌ها و وب‌سایت‌ها) تا از ورود داده‌های نامعتبر جلوگیری شود.</li><li>**فشرده‌سازی:** داده‌ها، به خصوص متن، می‌توانند تا حد زیادی فشرده شوند (مثلاً به یک صدم حجم اصلی).</li><li>**عدم حذف داده:** در سیستم‌های بیگ دیتا، چیزی به نام حذف (Delete) داده وجود ندارد. اطلاعات حتی پس از حذف توسط کاربر، در سرورها ذخیره می‌شوند.</li></ul><h3>اطلاعات شناسایی‌پذیر شخصی (PII)</h3><p>PII شامل اطلاعاتی مانند چهره، کد ملی، شماره پلاک و هر اطلاعاتی است که بتواند یک فرد را شناسایی کند.</p><ul><li>**پاکسازی PII:** هر اطلاعاتی از نوع PII باید پاکسازی شود (مثلاً بلور کردن چهره‌ها در نقشه‌های گوگل).</li><li>**عدم سوءاستفاده:** نباید از اطلاعات برای حدس زدن PII استفاده کرد.</li><li>**نقض حریم خصوصی:** دولت‌ها اغلب اطلاعات آماری از مناطق جمع‌آوری می‌کنند و سپس با استفاده از آن، افراد را شناسایی می‌کنند.</li><li>**دقت بالا:** اپلیکیشن‌های تشخیص چهره چینی با دقت ۹۹.۹۹ درصد افراد را شناسایی می‌کنند.</li></ul><h3>یادگیری عمیق (Deep Learning)</h3><p>یادگیری عمیق، اساس هوش مصنوعی امروزی است. در یادگیری عمیق، الگوریتم خودش می‌فهمد که چه ویژگی‌هایی را برای تشخیص بررسی کند، برخلاف روش‌های قدیمی که مهندسان باید ویژگی‌ها را به صورت دستی تعریف می‌کردند.</p><ul><li>**مزایا:** یادگیری عمیق خطای کمتری دارد و می‌تواند با موانعی مانند ماسک، عینک یا ریش نیز افراد را شناسایی کند.</li><li>**مدل‌های متن‌باز:** مدل‌های متن‌باز مانند YOLO برای تشخیص چهره و اشیا وجود دارند.</li><li>**ترینینگ مدل:** این مدل‌ها باید روی دیتاست‌های خاص هر کاربرد، دوباره ترین شوند.</li></ul><h3>مانیپولیت (Manipulate) و منیپولیت (Manicure)</h3><ul><li>**منیپولیت (Manicure):** به معنای مرتب کردن و سازماندهی داده‌هاست، بدون تغییر ذات آن‌ها.</li><li>**مانیپولیت (Manipulate):** به معنای دستکاری و تغییر ذات داده‌هاست.</li><li>**قاعده:** به عنوان یک متخصص، شما حق دارید داده‌ها را منیپولیت کنید، اما حق ندارید آن‌ها را مانیپولیت کنید. مانیپولیت کردن داده‌ها باعث اورفیتینگ مدل می‌شود.</li><li>**دیتای خام:** دیتای خام باید تا حد امکان دست‌نخورده و نزدیک به واقعیت باقی بماند.</li></ul><h3>دیتای گمشده (Missing Data)</h3><p>سه نوع دیتای گمشده وجود دارد که نحوه برخورد با آن‌ها متفاوت است:</p><ol><li>**دیتای حیاتی:** اگر فیلدهای حیاتی (مانند کد ملی) گم شده باشند، آن رکورد به درد نمی‌خورد و باید حذف شود.</li><li>**دیتای غیرحیاتی جزئی:** اگر فیلدهای غیرحیاتی (مانند ۲۰ درصد از یک ستون) گم شده باشند، می‌توان با میانگین یا میانه، جای خالی را پر کرد.</li><li>**دیتای غیرحیاتی عمده:** اگر بیشتر یک ستون (مثلاً ۸۰ درصد) گم شده باشد، نمی‌توان با میانگین‌گیری آن را پر کرد و باید از شرکت درخواست دیتای سالم‌تر کرد.</li></ol><h3>ناترازی داده (Data Imbalance)</h3><p>ناترازی داده زمانی رخ می‌دهد که داده‌ها از نظر منطقی یکدیگر را نقض کنند (مثلاً مدل شما آقایان را باحجاب تشخیص دهد).</p><h3>اخلاق (Ethics) و سوگیری (Bias)</h3><p>اخلاق و سوگیری در هوش مصنوعی بسیار مهم هستند و متأسفانه امروزه به شدت در حال افزایش‌اند.</p><ul><li>**سانسورشیپ (Censorship):** بسیاری از LLMs دارای سانسورشیپ هستند و اطلاعات مذهبی، سیاسی یا هر اطلاعاتی که آسیب‌رسان تلقی شود را حذف می‌کنند.</li><li>**سوگیری ذاتی:** داده‌های ارگانیک ذاتاً سوگیرانه هستند، زیرا هر فردی بر اساس منافع خود صحبت می‌کند. این سوگیری در مقیاس بزرگ در اینترنت وجود دارد.</li><li>**مثال:** اگر از هوش مصنوعی بپرسید که پرستار مرد است یا زن، ممکن است به دلیل سوگیری در داده‌های آموزشی، پاسخ دهد که زن است، در حالی که بسیاری از پرستاران مرد هستند.</li><li>**قوانین:** قانون‌گذاران در سطح دولت‌ها هنوز قوانین مشخصی برای مقابله با سوگیری هوش مصنوعی ندارند.</li></ul><h3>عدم شهود واقعی (Lack of True Intuition)</h3><p>هوش مصنوعی نمی‌تواند شهود واقعی داشته باشد. مثلاً اگر به یک کودک دو ساله درباره خطرات عقرب بگویید، او باز هم ممکن است دستش را به سمت آن ببرد، زیرا شهود خطر در او هنوز شکل نگرفته است.</p><h3>نکات پایانی</h3><ul><li>**اطلاعات آنلاین:** هر اطلاعاتی که در اینترنت وجود دارد، ممکن است دستکاری شود.</li><li>**دیتای اصلی:** همیشه یک کپی ایزوله از دیتای خام و اصلی خود داشته باشید.</li><li>**کلین کردن:** قبل از ورود داده به الگوریتم هوش مصنوعی، باید آن را منیپولیت (کلین) کنید.</li><li>**لاس شدن داده:** در فرآیند کلین کردن، خواه‌ناخواه بخشی از داده‌ها از دست می‌روند.</li><li>**اسکرین اسکرپینگ (Screen Scraping):** به معنای استخراج محتوا از صفحات وب است.</li></ul></ol></div>','completed','2025-11-09 07:00:48','2025-12-03 04:33:26',NULL,NULL,0,NULL,1,NULL),(51,6,1,'سازنده‌ها و وراثت','1404/07/07','<div style=\"max-width: 100%; overflow-x: hidden; word-wrap: break-word; padding: 1rem; box-sizing: border-box;\"><div style=\"max-width: 100%; overflow-x: hidden; word-wrap: break-word; padding: 1rem; box-sizing: border-box;\"><h1>سازنده‌ها و وراثت</h1><h2>سازنده پیش‌فرض (Default Constructor)</h2><p>هر کلاسی، حتی اگر شما هیچ سازنده‌ای برای آن تعریف نکنید، یک سازنده پیش‌فرض (default constructor) دارد. این سازنده:</p><ul><li>بدون پارامتر است.</li><li>هم‌نام با کلاس خودش است.</li><li>محتوای داخلی آن خالی است (هیچ کاری انجام نمی‌دهد).</li></ul><p>وقتی شما یک شیء از این کلاس را بدون فراخوانی صریح سازنده ایجاد می‌کنید (مثلاً <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">new MyClass()</code>)، این سازنده پیش‌فرض به صورت خودکار در زمان اجرا فراخوانی می‌شود، حتی اگر خالی باشد. دلیل وجود این سازنده پیش‌فرض این است که برای هر کلاسی لازم نیست که حتماً یک سازنده سفارشی داشته باشد.</p><h2>سازنده‌های صریح و وراثت</h2><h3>مثال ۱: کلاس A و کلاس B (با سازنده‌های بدون پارامتر)</h3><p>فرض کنید دو کلاس داریم:</p><pre style=\"white-space: pre-wrap !important; word-wrap: break-word !important; overflow-x: auto !important; max-width: 100% !important; padding: 1rem; background-color: #f5f5f5; border-radius: 4px; direction: ltr; font-family: \'Courier New\', monospace; font-size: 0.9em; line-height: 1.5; margin: 1rem 0;white-space: pre-wrap !important; word-wrap: break-word !important; overflow-x: auto !important; max-width: 100% !important; padding: 1rem; background-color: #f5f5f5; border-radius: 4px; direction: ltr; font-family: \'Courier New\', monospace; font-size: 0.9em; line-height: 1.5; margin: 1rem 0;\"><code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; display: block; overflow-x: auto; font-family: \'Courier New\', monospace;white-space: pre-wrap !important; word-wrap: break-word !important; display: block; overflow-x: auto; font-family: \'Courier New\', monospace;\">class A {<br/>    public A() {<br/>        System.out.println(\"Hi\");<br/>    }<br/>}<br/><br/>class B extends A {<br/>    public B() {<br/>        System.out.println(\"Bye\");<br/>    }<br/>}</code></pre><ul><li>اگر شیئی از <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">A</code> بسازیم (<code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">new A()</code>)، خروجی \"Hi\" خواهد بود.</li><li>اگر شیئی از <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">B</code> بسازیم (<code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">new B()</code>)، خروجی \"Bye\" خواهد بود.</li></ul><h3>مثال ۲: کلاس B با سازنده خالی (بدون فراخوانی صریح سازنده والد)</h3><p>حالا فرض کنید کلاس <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">B</code> به شکل زیر باشد (سازنده آن خالی است):</p><pre style=\"white-space: pre-wrap !important; word-wrap: break-word !important; overflow-x: auto !important; max-width: 100% !important; padding: 1rem; background-color: #f5f5f5; border-radius: 4px; direction: ltr; font-family: \'Courier New\', monospace; font-size: 0.9em; line-height: 1.5; margin: 1rem 0;white-space: pre-wrap !important; word-wrap: break-word !important; overflow-x: auto !important; max-width: 100% !important; padding: 1rem; background-color: #f5f5f5; border-radius: 4px; direction: ltr; font-family: \'Courier New\', monospace; font-size: 0.9em; line-height: 1.5; margin: 1rem 0;\"><code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; display: block; overflow-x: auto; font-family: \'Courier New\', monospace;white-space: pre-wrap !important; word-wrap: break-word !important; display: block; overflow-x: auto; font-family: \'Courier New\', monospace;\">class B extends A {<br/>    public B() {<br/>        // این سازنده خالی است و هیچ فراخوانی صریحی به سازنده A ندارد.<br/>    }<br/>}</code></pre><p>اگر شیئی از <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">B</code> بسازیم (<code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">new B()</code>)، چه اتفاقی می‌افتد؟</p><p>در این حالت، چون <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">B</code> از <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">A</code> ارث‌بری می‌کند و سازنده <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">B</code> هیچ فراخوانی صریحی به سازنده والد ندارد، کامپایلر به صورت ضمنی یک فراخوانی به سازنده پیش‌فرض بدون پارامتر والد (<code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">super()</code>) در ابتدای سازنده <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">B</code> اضافه می‌کند. بنابراین، خروجی \"Hi\" خواهد بود.</p><h3>قاعده کلی سازنده‌ها در وراثت</h3><ul><li>اگر کلاسی هیچ سازنده‌ای نداشته باشد، کامپایلر یک سازنده پیش‌فرض بدون پارامتر (no-arg constructor) برای آن ایجاد می‌کند.</li><li>اگر کلاسی حداقل یک سازنده صریح (با یا بدون پارامتر) داشته باشد، کامپایلر دیگر سازنده پیش‌فرض بدون پارامتر را به صورت خودکار ایجاد نمی‌کند.</li><li>در یک کلاس فرزند، اگر سازنده کلاس فرزند به صورت صریح سازنده والد را فراخوانی نکند (با استفاده از <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">super()</code> یا <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">super(parameters)</code>)، کامپایلر به صورت خودکار یک فراخوانی ضمنی به سازنده پیش‌فرض بدون پارامتر والد (<code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">super()</code>) در ابتدای سازنده فرزند اضافه می‌کند.</li><li>اگر کلاس والد سازنده پیش‌فرض بدون پارامتر نداشته باشد و کلاس فرزند نیز به صورت صریح سازنده دیگری از والد را فراخوانی نکند، خطای کامپایل رخ خواهد داد.</li></ul><h2>استفاده از کلمه کلیدی <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">super</code></h2><h3>مثال ۳: انتقال پارامترها به سازنده والد</h3><p>فرض کنید کلاس <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">A</code> یک فیلد <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">age</code> دارد و سازنده آن <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">age</code> را می‌گیرد. همچنین فرض کنید <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">A</code> فقط همین یک سازنده را دارد و سازنده پیش‌فرض بدون پارامتر را ندارد:</p><pre style=\"white-space: pre-wrap !important; word-wrap: break-word !important; overflow-x: auto !important; max-width: 100% !important; padding: 1rem; background-color: #f5f5f5; border-radius: 4px; direction: ltr; font-family: \'Courier New\', monospace; font-size: 0.9em; line-height: 1.5; margin: 1rem 0;white-space: pre-wrap !important; word-wrap: break-word !important; overflow-x: auto !important; max-width: 100% !important; padding: 1rem; background-color: #f5f5f5; border-radius: 4px; direction: ltr; font-family: \'Courier New\', monospace; font-size: 0.9em; line-height: 1.5; margin: 1rem 0;\"><code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; display: block; overflow-x: auto; font-family: \'Courier New\', monospace;white-space: pre-wrap !important; word-wrap: break-word !important; display: block; overflow-x: auto; font-family: \'Courier New\', monospace;\">class A {<br/>    int age;<br/>    public A(int age) {<br/>        this.age = age;<br/>        System.out.println(\"Age in A: \" + age);<br/>    }<br/>}</code></pre><p>و کلاس <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">B</code> از <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">A</code> ارث‌بری می‌کند. ما می‌خواهیم شیئی از <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">B</code> بسازیم و دو مقدار (مثلاً <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">age = 15</code> و <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">otherVar = 12</code>) را به آن پاس دهیم. سازنده <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">B</code> باید به این شکل باشد:</p><pre style=\"white-space: pre-wrap !important; word-wrap: break-word !important; overflow-x: auto !important; max-width: 100% !important; padding: 1rem; background-color: #f5f5f5; border-radius: 4px; direction: ltr; font-family: \'Courier New\', monospace; font-size: 0.9em; line-height: 1.5; margin: 1rem 0;white-space: pre-wrap !important; word-wrap: break-word !important; overflow-x: auto !important; max-width: 100% !important; padding: 1rem; background-color: #f5f5f5; border-radius: 4px; direction: ltr; font-family: \'Courier New\', monospace; font-size: 0.9em; line-height: 1.5; margin: 1rem 0;\"><code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; display: block; overflow-x: auto; font-family: \'Courier New\', monospace;white-space: pre-wrap !important; word-wrap: break-word !important; display: block; overflow-x: auto; font-family: \'Courier New\', monospace;\">class B extends A {<br/>    int otherVar;<br/>    public B(int age, int otherVar) {<br/>        // اینجا نمی‌توانیم مستقیماً age را مقداردهی کنیم<br/>        // زیرا age متعلق به کلاس والد است.<br/>        // همچنین، A دیگر سازنده پیش‌فرض بدون پارامتر ندارد،<br/>        // بنابراین فراخوانی ضمنی super() خطا می‌دهد.<br/><br/>        super(age); // فراخوانی سازنده والد با پارامتر age<br/>        this.otherVar = otherVar;<br/>        System.out.println(\"Other var in B: \" + otherVar);<br/>    }<br/>}</code></pre><p>وقتی از کلمه کلیدی <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">super(age)</code> استفاده می‌کنیم:</p><ul><li>این دستور به کامپایلر می‌گوید که به کلاس والد (<code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">A</code>) برود.</li><li>در کلاس والد، به دنبال سازنده‌ای بگردد که یک پارامتر از نوع <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">int</code> می‌پذیرد.</li><li>آن سازنده را با مقداری که به <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">super</code> فرستاده‌ایم (در اینجا <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">age</code>) فراخوانی کند.</li></ul><p>این کار باعث می‌شود که فیلدهای کلاس والد (مانند <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">age</code>) توسط سازنده والد مقداردهی شوند. این مکانیزم برای اطمینان از مقداردهی صحیح بخش ارث‌بری شده از شیء در زمان ساخت آن ضروری است.</p><p>به عبارت دیگر، <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">super</code> در پرانتز سازنده فرزند، برای ارسال مقادیر به سازنده والد استفاده می‌شود تا ویژگی‌هایی که از والد به ارث رسیده، به درستی مقداردهی شوند.</p></div></div>','<div style=\"max-width: 100%; overflow-x: hidden; word-wrap: break-word; padding: 1rem; box-sizing: border-box;\"><h1>سازنده‌ها و وراثت</h1><h2>سازنده پیش‌فرض (Default Constructor)</h2><p>هر کلاسی، حتی اگر شما هیچ سازنده‌ای برای آن تعریف نکنید، یک سازنده پیش‌فرض (default constructor) دارد. این سازنده:</p><ul><li>بدون پارامتر است.</li><li>هم‌نام با کلاس خودش است.</li><li>محتوای داخلی آن خالی است (هیچ کاری انجام نمی‌دهد).</li></ul><p>وقتی شما یک شیء از این کلاس را بدون فراخوانی صریح سازنده ایجاد می‌کنید (مثلاً <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">new MyClass()</code>)، این سازنده پیش‌فرض به صورت خودکار در زمان اجرا فراخوانی می‌شود، حتی اگر خالی باشد. دلیل وجود این سازنده پیش‌فرض این است که برای هر کلاسی لازم نیست که حتماً یک سازنده سفارشی داشته باشد.</p><h2>سازنده‌های صریح و وراثت</h2><h3>مثال ۱: کلاس A و کلاس B (با سازنده‌های بدون پارامتر)</h3><p>فرض کنید دو کلاس داریم:</p><pre style=\"white-space: pre-wrap !important; word-wrap: break-word !important; overflow-x: auto !important; max-width: 100% !important; padding: 1rem; background-color: #f5f5f5; border-radius: 4px; direction: ltr; font-family: \'Courier New\', monospace; font-size: 0.9em; line-height: 1.5; margin: 1rem 0;\"><code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; display: block; overflow-x: auto; font-family: \'Courier New\', monospace;\">class A {<br/>    public A() {<br/>        System.out.println(\"Hi\");<br/>    }<br/>}<br/><br/>class B extends A {<br/>    public B() {<br/>        System.out.println(\"Bye\");<br/>    }<br/>}</code></pre><ul><li>اگر شیئی از <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">A</code> بسازیم (<code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">new A()</code>)، خروجی \"Hi\" خواهد بود.</li><li>اگر شیئی از <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">B</code> بسازیم (<code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">new B()</code>)، خروجی \"Bye\" خواهد بود.</li></ul><h3>مثال ۲: کلاس B با سازنده خالی (بدون فراخوانی صریح سازنده والد)</h3><p>حالا فرض کنید کلاس <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">B</code> به شکل زیر باشد (سازنده آن خالی است):</p><pre style=\"white-space: pre-wrap !important; word-wrap: break-word !important; overflow-x: auto !important; max-width: 100% !important; padding: 1rem; background-color: #f5f5f5; border-radius: 4px; direction: ltr; font-family: \'Courier New\', monospace; font-size: 0.9em; line-height: 1.5; margin: 1rem 0;\"><code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; display: block; overflow-x: auto; font-family: \'Courier New\', monospace;\">class B extends A {<br/>    public B() {<br/>        // این سازنده خالی است و هیچ فراخوانی صریحی به سازنده A ندارد.<br/>    }<br/>}</code></pre><p>اگر شیئی از <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">B</code> بسازیم (<code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">new B()</code>)، چه اتفاقی می‌افتد؟</p><p>در این حالت، چون <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">B</code> از <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">A</code> ارث‌بری می‌کند و سازنده <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">B</code> هیچ فراخوانی صریحی به سازنده والد ندارد، کامپایلر به صورت ضمنی یک فراخوانی به سازنده پیش‌فرض بدون پارامتر والد (<code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">super()</code>) در ابتدای سازنده <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">B</code> اضافه می‌کند. بنابراین، خروجی \"Hi\" خواهد بود.</p><h3>قاعده کلی سازنده‌ها در وراثت</h3><ul><li>اگر کلاسی هیچ سازنده‌ای نداشته باشد، کامپایلر یک سازنده پیش‌فرض بدون پارامتر (no-arg constructor) برای آن ایجاد می‌کند.</li><li>اگر کلاسی حداقل یک سازنده صریح (با یا بدون پارامتر) داشته باشد، کامپایلر دیگر سازنده پیش‌فرض بدون پارامتر را به صورت خودکار ایجاد نمی‌کند.</li><li>در یک کلاس فرزند، اگر سازنده کلاس فرزند به صورت صریح سازنده والد را فراخوانی نکند (با استفاده از <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">super()</code> یا <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">super(parameters)</code>)، کامپایلر به صورت خودکار یک فراخوانی ضمنی به سازنده پیش‌فرض بدون پارامتر والد (<code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">super()</code>) در ابتدای سازنده فرزند اضافه می‌کند.</li><li>اگر کلاس والد سازنده پیش‌فرض بدون پارامتر نداشته باشد و کلاس فرزند نیز به صورت صریح سازنده دیگری از والد را فراخوانی نکند، خطای کامپایل رخ خواهد داد.</li></ul><h2>استفاده از کلمه کلیدی <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">super</code></h2><h3>مثال ۳: انتقال پارامترها به سازنده والد</h3><p>فرض کنید کلاس <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">A</code> یک فیلد <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">age</code> دارد و سازنده آن <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">age</code> را می‌گیرد. همچنین فرض کنید <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">A</code> فقط همین یک سازنده را دارد و سازنده پیش‌فرض بدون پارامتر را ندارد:</p><pre style=\"white-space: pre-wrap !important; word-wrap: break-word !important; overflow-x: auto !important; max-width: 100% !important; padding: 1rem; background-color: #f5f5f5; border-radius: 4px; direction: ltr; font-family: \'Courier New\', monospace; font-size: 0.9em; line-height: 1.5; margin: 1rem 0;\"><code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; display: block; overflow-x: auto; font-family: \'Courier New\', monospace;\">class A {<br/>    int age;<br/>    public A(int age) {<br/>        this.age = age;<br/>        System.out.println(\"Age in A: \" + age);<br/>    }<br/>}</code></pre><p>و کلاس <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">B</code> از <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">A</code> ارث‌بری می‌کند. ما می‌خواهیم شیئی از <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">B</code> بسازیم و دو مقدار (مثلاً <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">age = 15</code> و <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">otherVar = 12</code>) را به آن پاس دهیم. سازنده <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">B</code> باید به این شکل باشد:</p><pre style=\"white-space: pre-wrap !important; word-wrap: break-word !important; overflow-x: auto !important; max-width: 100% !important; padding: 1rem; background-color: #f5f5f5; border-radius: 4px; direction: ltr; font-family: \'Courier New\', monospace; font-size: 0.9em; line-height: 1.5; margin: 1rem 0;\"><code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; display: block; overflow-x: auto; font-family: \'Courier New\', monospace;\">class B extends A {<br/>    int otherVar;<br/>    public B(int age, int otherVar) {<br/>        // اینجا نمی‌توانیم مستقیماً age را مقداردهی کنیم<br/>        // زیرا age متعلق به کلاس والد است.<br/>        // همچنین، A دیگر سازنده پیش‌فرض بدون پارامتر ندارد،<br/>        // بنابراین فراخوانی ضمنی super() خطا می‌دهد.<br/><br/>        super(age); // فراخوانی سازنده والد با پارامتر age<br/>        this.otherVar = otherVar;<br/>        System.out.println(\"Other var in B: \" + otherVar);<br/>    }<br/>}</code></pre><p>وقتی از کلمه کلیدی <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">super(age)</code> استفاده می‌کنیم:</p><ul><li>این دستور به کامپایلر می‌گوید که به کلاس والد (<code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">A</code>) برود.</li><li>در کلاس والد، به دنبال سازنده‌ای بگردد که یک پارامتر از نوع <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">int</code> می‌پذیرد.</li><li>آن سازنده را با مقداری که به <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">super</code> فرستاده‌ایم (در اینجا <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">age</code>) فراخوانی کند.</li></ul><p>این کار باعث می‌شود که فیلدهای کلاس والد (مانند <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">age</code>) توسط سازنده والد مقداردهی شوند. این مکانیزم برای اطمینان از مقداردهی صحیح بخش ارث‌بری شده از شیء در زمان ساخت آن ضروری است.</p><p>به عبارت دیگر، <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">super</code> در پرانتز سازنده فرزند، برای ارسال مقادیر به سازنده والد استفاده می‌شود تا ویژگی‌هایی که از والد به ارث رسیده، به درستی مقداردهی شوند.</p></div>','completed','2025-11-09 07:28:35','2025-12-03 04:33:26',NULL,NULL,0,NULL,1,NULL),(52,4,1,'هوش مصنوعی مولد (Generative AI) — کلیات و معماری ترانسفورمر','1404/08/05','<div style=\"max-width: 100%; overflow-x: hidden; word-wrap: break-word; padding: 1rem; box-sizing: border-box;\"><div style=\"max-width: 100%; overflow-x: hidden; word-wrap: break-word; padding: 1rem; box-sizing: border-box;\"><h1>مقدمه و کلیات هوش مصنوعی مولد (Generative AI)</h1><p>این جلسه به بررسی هوش مصنوعی مولد (Generative AI) می‌پردازیم. هدف این است که درک کلی از ابزارهایی که استفاده می‌کنید، به دست آورید و ابهامات شما برطرف شود. ما به کلیات و مفاهیم اصلی می‌پردازیم و وارد جزئیات ریاضی و فرمول‌ها نمی‌شویم.</p><h2>وظایف هوش مصنوعی</h2><p>در جلسات گذشته گفتیم که هوش مصنوعی دو وظیفه کلی انجام می‌دهد:</p><ul><li><strong>تشخیص (Discrimination)</strong>: این حوزه را در جلسات گذشته با بررسی شبکه‌های عصبی و درخت‌ها پوشش دادیم. به عنوان مثال، با چند سؤال می‌توان نام افراد را پیدا کرد.</li><li><strong>تولید (Generation)</strong>: تمرکز این جلسه بر روی این حوزه است. هوش مصنوعی مولد داده‌های جدید را تولید می‌کند، نه فقط داده‌های موجود را بازتولید. این شامل یک جنبه خلاقیت نیز می‌شود.</li></ul><h3>داده‌های تولیدی</h3><p>داده‌های جدیدی که توسط هوش مصنوعی مولد تولید می‌شوند، می‌توانند هر چیزی باشند:</p><ul><li>تصاویر</li><li>صدا</li><li>ویدئو</li><li>کد برنامه</li><li>سیگنال‌ها</li><li>و هر چیز دیگری که فکرش را بکنید.</li></ul><h3>مدل‌ها و معماری‌ها</h3><p>در حوزه هوش مصنوعی، ما از اصطلاح <strong>مدل‌های هوش مصنوعی (AI Models)</strong> استفاده می‌کنیم، نه برنامه‌های هوش مصنوعی. هر مدل هوش مصنوعی از یک یا چند <strong>معماری (Architecture)</strong> استفاده می‌کند.</p><p>معماری‌های خاصی وجود دارند که به آن‌ها «بیگ جامپ» (Big Jump) می‌گوییم. این معماری‌ها معمولاً توسط شرکت‌های بزرگ توسعه داده می‌شوند و سرمایه‌گذاری زیادی روی آن‌ها انجام می‌شود.</p><h4>معماری ترانسفورمر (Transformer)</h4><p>یکی از این معماری‌های مهم و «بیگ جامپ»، <strong>ترانسفورمر (Transformer)</strong> است که احتمالاً توسط گوگل معرفی شده است. ظهور هوش مصنوعی مولد به شدت با این معماری گره خورده است.</p><p>ترانسفورمر باعث شد که ما بتوانیم الگوهای کلی و مشترکی که قبلاً کشف می‌کردیم را بهتر کشف کنیم و حتی بتوانیم آن‌ها را کمی تغییر دهیم تا داده‌های جدیدی تولید کنیم.</p><p>ترانسفورمرها نوعی شبکه عصبی عمیق هستند، اما با یک معماری خاص. آن‌ها جزو خانواده شبکه‌های عصبی بازگشتی (RNN) مانند LSTM محسوب می‌شوند و حتی از LSTM در ساختار داخلی خود استفاده می‌کنند.</p><h3>انفجار هوش مصنوعی مولد</h3><p>انفجار هوش مصنوعی مولد را می‌توان از طریق مدل‌هایی مانند GPT (Generative Pre-trained Transformer) مشاهده کرد. این انفجار با معرفی ChatGPT در اواخر سال ۲۰۲۲ آغاز شد و یک «هایپ» (Hype) بزرگ در حوزه هوش مصنوعی ایجاد کرد.</p><p>پس از آن، با معرفی مدل‌هایی مانند GPT-3، GPT-4 و DALL-E، وارد مرحله‌ای شدیم که به آن «AI Effect» می‌گویند؛ یعنی نوآوری‌های جدید هوش مصنوعی دیگر به اندازه قبل شگفت‌انگیز نیستند. این نشان می‌دهد که هوش مصنوعی به سرعت در حال پیشرفت و عادی شدن است.</p><p>مفهوم هوش مصنوعی بسیار قدیمی‌تر از خود کامپیوترهاست. ایده هوش در دستگاه‌های غیرارگانیک از دیرباز وجود داشته است.</p><h2>منطق پشت هوش مصنوعی مولد (به زبان ساده)</h2><p>ما قصد نداریم فرمول‌های ریاضی را بررسی کنیم، بلکه منطق پشت هوش مصنوعی مولد را به زبانی ساده‌سازی شده توضیح می‌دهیم.</p><h3>یادگیری الگوها با انکودر (Encoder)</h3><p>فرض کنید یک دیتاست از تصاویر اسب داریم. ما از یک <strong>انکودر (Encoder)</strong> یا <strong>اتو-انکودر (Autoencoder)</strong> استفاده می‌کنیم. کار انکودر این است که الگوهای کلی و مشترک را از داده‌ها یاد بگیرد و استخراج کند. به عنوان مثال، از تصاویر اسب، مفهوم کلی «اسب بودن» را یاد می‌گیرد.</p><p>این الگوها به صورت وزن‌ها (اعداد) نمایش داده می‌شوند که به خودی خود برای ما معنی خاصی ندارند، اما در واقع همان الگوها هستند.</p><h3>تولید داده جدید با نویز (Noise) و دیکودر (Decoder)</h3><p>پس از اینکه الگوها یاد گرفته شدند (به صورت اعداد)، ما به این اعداد <strong>نویز (Noise)</strong> اضافه می‌کنیم. نویز در اینجا به معنای تغییرات تصادفی کوچک در این الگوهای عددی است. مثلاً اگر عددی ۲.۷۳ باشد، آن را به ۲.۷۵ تغییر می‌دهیم. این تغییرات کوچک و تصادفی هستند، اما داده کاملاً تصادفی نیستند.</p><p>سپس، این الگوهای کمی تغییر یافته را به یک <strong>دیکودر (Decoder)</strong> می‌دهیم. دیکودر این الگوها را بازسازی می‌کند و داده‌های جدیدی تولید می‌کند که دقیقاً مشابه داده‌های اصلی نیستند، اما ویژگی‌های کلی آن‌ها را حفظ کرده‌اند.</p><h3>چالش کنترل تولید</h3><p>مشکلی که در ابتدا وجود داشت این بود که ما کنترلی بر روی نویز و در نتیجه بر روی خروجی نداشتیم. تصاویر تولید شده اغلب تصادفی و غیرمرتبط بودند. هدف این بود که بتوانیم نویز را طوری کنترل کنیم که تصویر تولید شده همچنان یک «اسب» باشد، اما یک اسب «جدید».</p><p>مدل‌های یادگیری ماشین قبلی نمی‌توانستند این الگوهای ساده را کنترل کنند، اما به تدریج این مشکل حل شد.</p><h2>ترانسفورمرها و معماری‌های خاص</h2><p>ترانسفورمرها به خودی خود یک تابع آماده در کتابخانه‌هایی مانند TensorFlow یا PyTorch هستند و به تنهایی چیزی تولید نمی‌کنند. آن‌ها باید در یک <strong>معماری خاص</strong> استفاده شوند.</p><p>این معماری دارای یک بخش غیرقابل تغییر (معمولاً ترانسفورمر پیش‌آموزش‌دیده و متن‌باز مانند GPT یا ResNet) و یک بخش قابل آموزش است. بخش قابل آموزش جایی است که دانشجویان و محققان می‌توانند نوآوری کنند و از شبکه‌های ساده‌تری مانند U-Net استفاده کنند.</p><p>با ترکیب این ابزارها و معماری‌های مختلف، می‌توان یک معماری خاص برای تولید داده‌های جدید ایجاد کرد.</p><h2>بازنمایی کلمات (Word Representation)</h2><p>هدف این است که کلمات و جملات را به گونه‌ای <strong>بازنمایی (Represent)</strong> کنیم که برای کامپیوتر و الگوریتم‌های یادگیری ماشین، همان معنایی را داشته باشند که برای ما انسان‌ها دارند.</p><h3>مدل Bag of Words (BOW)</h3><p>اولین و ساده‌ترین تلاش‌ها در این زمینه، مدل <strong>Bag of Words (BOW)</strong> بود. در این مدل، جایگاه و ترتیب کلمات در جمله مهم نیست؛ فقط <strong>تکرار (Frequency)</strong> آن‌ها اهمیت دارد.</p><h4>مثال BOW</h4><p>فرض کنید دو متن داریم:</p><ol><li>متن اول: «گربه مادر خوابید.»</li><li>متن دوم: «بچه گربه، گربه مادر پرید.»</li></ol><p>توکن (Token) کوچکترین واحد معنایی یک جمله است. در اینجا، کلمات را به عنوان توکن در نظر می‌گیریم: «گربه»، «مادر»، «خوابید»، «بچه»، «پرید».</p><p>سپس تعداد تکرار هر کلمه را در هر متن می‌شماریم. مثلاً در متن اول، «گربه» یک بار، «مادر» یک بار و «خوابید» یک بار تکرار شده است. این متن به صورت عددی (مثلاً [۱، ۱، ۱، ۰، ۰]) بازنمایی می‌شود.</p><p>این بازنمایی عددی به خودی خود برای ما معنی ندارد، اما به طرز شگفت‌انگیزی، وقتی این اعداد وارد الگوریتم‌های ریاضی می‌شوند، تقریباً همان معانی را منتقل می‌کنند.</p><h3>منطق ریاضی در زبان</h3><p>ما نمی‌دانیم چرا این اتفاق می‌افتد، اما فرض می‌کنیم که پشت زبان ما انسان‌ها، یک منطق ریاضی وجود دارد. این همان ریاضیاتی است که ما درک می‌کنیم.</p><p>به عنوان مثال، اگر کلمات را به صورت بردارهای عددی در یک فضای چندبعدی رسم کنیم، روابط ریاضی بین آن‌ها برقرار می‌شود:</p><pre style=\"white-space: pre-wrap !important; word-wrap: break-word !important; overflow-x: auto !important; max-width: 100% !important; padding: 1rem; background-color: #f5f5f5; border-radius: 4px; direction: ltr; font-family: \'Courier New\', monospace; font-size: 0.9em; line-height: 1.5; margin: 1rem 0;white-space: pre-wrap !important; word-wrap: break-word !important; overflow-x: auto !important; max-width: 100% !important; padding: 1rem; background-color: #f5f5f5; border-radius: 4px; direction: ltr; font-family: \'Courier New\', monospace; font-size: 0.9em; line-height: 1.5; margin: 1rem 0;\"><code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; display: block; overflow-x: auto; font-family: \'Courier New\', monospace;white-space: pre-wrap !important; word-wrap: break-word !important; display: block; overflow-x: auto; font-family: \'Courier New\', monospace;\">ملکه = زن + مرد - پادشاه</code></pre><p>یا فاصله بین «پریدن» و «پرید» (فعل و گذشته آن) برابر است با فاصله بین «خوابیدن» و «خوابید». همچنین، فاصله بین «گربه مادر» و «بچه گربه» برابر است با فاصله بین «مرغ» و «جوجه». این نشان می‌دهد که روابط معنایی مانند «مادری» را می‌توان از طریق اعداد نمایش داد.</p><p>این مفاهیم نشان می‌دهند که پشت آنچه ما درک می‌کنیم، ریاضیات و اعداد (ماتریس‌ها) نهفته است.</p><p>مدل BOW بسیار قدیمی است و معانی زیادی را منتقل نمی‌کند، زیرا فقط بر اساس تکرار کلمات است. بسیاری از فرمول‌های ریاضی پاسخ‌های خوبی با این مدل نمی‌دهند.</p><h2>مکانیسم توجه (Attention Mechanism)</h2><p>برای پاسخ دقیق‌تر به سؤالات مربوط به هوش مصنوعی مولد، به مفهوم <strong>توجه (Attention)</strong> می‌پردازیم.</p><p>بردار توجه (Attention Vector) یک بردار عددی است که به اندازه بردار ورودی است و نشان‌دهنده میزان توجه به هر قسمت از ورودی است. ترانسفورمرها بر مبنای همین مکانیسم توجه کار می‌کنند.</p><p>فرض کنید می‌خواهیم فقط روی کلمه «گربه» تمرکز کنیم. در این صورت، در بردار توجه، مقدار مربوط به «گربه» یک و بقیه صفر می‌شوند. سپس این بردار توجه را در بردار اصلی کلمات ضرب می‌کنیم تا فقط روی «گربه» تمرکز شود.</p><p>این نشان می‌دهد که شما از مفاهیم سطح پایین (مانند ضرب و تقسیم) برای ایجاد مکانیسم‌های پیچیده استفاده می‌کنید.</p><h3>نحوه عملکرد GPT و ترانسفورمرها</h3><p>GPT و ترانسفورمرها چگونه کار می‌کنند؟ آن‌ها از مفاهیم سطح پایین‌تر مانند RNNها، LSTMها، و اتو-انکودرها استفاده می‌کنند و آن‌ها را با یک معماری خاص به هم متصل می‌کنند. این اتصالات و ترتیب قرار گرفتن این اجزا در یک «پایپ‌لاین» (Pipeline) است که اهمیت دارد.</p><p>اینکه چگونه این اجزا به هم متصل می‌شوند، عمدتاً از طریق <strong>آزمون و خطا (Trial and Error)</strong> کشف می‌شود. در حال حاضر، ما ابزار ریاضی برای اثبات اینکه «این روش بهتر است» نداریم و فقط به صورت تجربی عمل می‌کنیم.</p><h3>جلوگیری از Overfitting</h3><p>برای جلوگیری از <strong>Overfitting</strong> (بیش‌برازش)، هیچ راه‌حل قطعی وجود ندارد و فقط به صورت تجربی و با آزمون و خطا عمل می‌کنیم.</p><h2>فرآیند آموزش مدل‌ها</h2><p>فرآیند کلی آموزش مدل‌ها به این صورت است:</p><ol><li><strong>منابع (Resources)</strong>: شما یک سری منابع پردازشی (زمان یا واحد پردازش) و تعداد مشخصی <strong>اپوک (Epoch)</strong> (تکرار آموزش بر روی کل دیتاست) در اختیار دارید. برای مدل‌های کوچک، می‌توان ۲۰۰ تا ۳۰۰ اپوک انجام داد، اما برای مدل‌های بزرگی مانند GPT، ممکن است فقط ۱۰ تا ۱۲ اپوک انجام شود که ماه‌ها طول می‌کشد و میلیون‌ها دلار هزینه برق دارد.</li><li><strong>حالت یادگیری (Training Mode)</strong>: ابتدا مدل را در حالت یادگیری (Training) قرار می‌دهید.</li><li><strong>داده‌های آموزشی (Training Data)</strong>: کل داده‌های آموزشی را به مدل می‌دهید.</li><li><strong>محاسبه خطا (Loss Calculation)</strong>: مدل بر اساس ورودی، خروجی را پیش‌بینی می‌کند. سپس میزان خطا (Loss) بین خروجی مدل و مقدار صحیح را محاسبه می‌کنید.</li><li><strong>به‌روزرسانی وزن‌ها (Weight Update)</strong>: با استفاده از یک تابع خاص (Proprietary Function)، وزن‌های مدل را به‌روزرسانی می‌کنید تا خطا کاهش یابد.</li></ol><p>این فرآیند به صورت تکراری انجام می‌شود تا مدل به بهترین عملکرد خود برسد.</p></div></div>','<div style=\"max-width: 100%; overflow-x: hidden; word-wrap: break-word; padding: 1rem; box-sizing: border-box;\"><h1>مقدمه و کلیات هوش مصنوعی مولد (Generative AI)</h1><p>این جلسه به بررسی هوش مصنوعی مولد (Generative AI) می‌پردازیم. هدف این است که درک کلی از ابزارهایی که استفاده می‌کنید، به دست آورید و ابهامات شما برطرف شود. ما به کلیات و مفاهیم اصلی می‌پردازیم و وارد جزئیات ریاضی و فرمول‌ها نمی‌شویم.</p><h2>وظایف هوش مصنوعی</h2><p>در جلسات گذشته گفتیم که هوش مصنوعی دو وظیفه کلی انجام می‌دهد:</p><ul><li><strong>تشخیص (Discrimination)</strong>: این حوزه را در جلسات گذشته با بررسی شبکه‌های عصبی و درخت‌ها پوشش دادیم. به عنوان مثال، با چند سؤال می‌توان نام افراد را پیدا کرد.</li><li><strong>تولید (Generation)</strong>: تمرکز این جلسه بر روی این حوزه است. هوش مصنوعی مولد داده‌های جدید را تولید می‌کند، نه فقط داده‌های موجود را بازتولید. این شامل یک جنبه خلاقیت نیز می‌شود.</li></ul><h3>داده‌های تولیدی</h3><p>داده‌های جدیدی که توسط هوش مصنوعی مولد تولید می‌شوند، می‌توانند هر چیزی باشند:</p><ul><li>تصاویر</li><li>صدا</li><li>ویدئو</li><li>کد برنامه</li><li>سیگنال‌ها</li><li>و هر چیز دیگری که فکرش را بکنید.</li></ul><h3>مدل‌ها و معماری‌ها</h3><p>در حوزه هوش مصنوعی، ما از اصطلاح <strong>مدل‌های هوش مصنوعی (AI Models)</strong> استفاده می‌کنیم، نه برنامه‌های هوش مصنوعی. هر مدل هوش مصنوعی از یک یا چند <strong>معماری (Architecture)</strong> استفاده می‌کند.</p><p>معماری‌های خاصی وجود دارند که به آن‌ها «بیگ جامپ» (Big Jump) می‌گوییم. این معماری‌ها معمولاً توسط شرکت‌های بزرگ توسعه داده می‌شوند و سرمایه‌گذاری زیادی روی آن‌ها انجام می‌شود.</p><h4>معماری ترانسفورمر (Transformer)</h4><p>یکی از این معماری‌های مهم و «بیگ جامپ»، <strong>ترانسفورمر (Transformer)</strong> است که احتمالاً توسط گوگل معرفی شده است. ظهور هوش مصنوعی مولد به شدت با این معماری گره خورده است.</p><p>ترانسفورمر باعث شد که ما بتوانیم الگوهای کلی و مشترکی که قبلاً کشف می‌کردیم را بهتر کشف کنیم و حتی بتوانیم آن‌ها را کمی تغییر دهیم تا داده‌های جدیدی تولید کنیم.</p><p>ترانسفورمرها نوعی شبکه عصبی عمیق هستند، اما با یک معماری خاص. آن‌ها جزو خانواده شبکه‌های عصبی بازگشتی (RNN) مانند LSTM محسوب می‌شوند و حتی از LSTM در ساختار داخلی خود استفاده می‌کنند.</p><h3>انفجار هوش مصنوعی مولد</h3><p>انفجار هوش مصنوعی مولد را می‌توان از طریق مدل‌هایی مانند GPT (Generative Pre-trained Transformer) مشاهده کرد. این انفجار با معرفی ChatGPT در اواخر سال ۲۰۲۲ آغاز شد و یک «هایپ» (Hype) بزرگ در حوزه هوش مصنوعی ایجاد کرد.</p><p>پس از آن، با معرفی مدل‌هایی مانند GPT-3، GPT-4 و DALL-E، وارد مرحله‌ای شدیم که به آن «AI Effect» می‌گویند؛ یعنی نوآوری‌های جدید هوش مصنوعی دیگر به اندازه قبل شگفت‌انگیز نیستند. این نشان می‌دهد که هوش مصنوعی به سرعت در حال پیشرفت و عادی شدن است.</p><p>مفهوم هوش مصنوعی بسیار قدیمی‌تر از خود کامپیوترهاست. ایده هوش در دستگاه‌های غیرارگانیک از دیرباز وجود داشته است.</p><h2>منطق پشت هوش مصنوعی مولد (به زبان ساده)</h2><p>ما قصد نداریم فرمول‌های ریاضی را بررسی کنیم، بلکه منطق پشت هوش مصنوعی مولد را به زبانی ساده‌سازی شده توضیح می‌دهیم.</p><h3>یادگیری الگوها با انکودر (Encoder)</h3><p>فرض کنید یک دیتاست از تصاویر اسب داریم. ما از یک <strong>انکودر (Encoder)</strong> یا <strong>اتو-انکودر (Autoencoder)</strong> استفاده می‌کنیم. کار انکودر این است که الگوهای کلی و مشترک را از داده‌ها یاد بگیرد و استخراج کند. به عنوان مثال، از تصاویر اسب، مفهوم کلی «اسب بودن» را یاد می‌گیرد.</p><p>این الگوها به صورت وزن‌ها (اعداد) نمایش داده می‌شوند که به خودی خود برای ما معنی خاصی ندارند، اما در واقع همان الگوها هستند.</p><h3>تولید داده جدید با نویز (Noise) و دیکودر (Decoder)</h3><p>پس از اینکه الگوها یاد گرفته شدند (به صورت اعداد)، ما به این اعداد <strong>نویز (Noise)</strong> اضافه می‌کنیم. نویز در اینجا به معنای تغییرات تصادفی کوچک در این الگوهای عددی است. مثلاً اگر عددی ۲.۷۳ باشد، آن را به ۲.۷۵ تغییر می‌دهیم. این تغییرات کوچک و تصادفی هستند، اما داده کاملاً تصادفی نیستند.</p><p>سپس، این الگوهای کمی تغییر یافته را به یک <strong>دیکودر (Decoder)</strong> می‌دهیم. دیکودر این الگوها را بازسازی می‌کند و داده‌های جدیدی تولید می‌کند که دقیقاً مشابه داده‌های اصلی نیستند، اما ویژگی‌های کلی آن‌ها را حفظ کرده‌اند.</p><h3>چالش کنترل تولید</h3><p>مشکلی که در ابتدا وجود داشت این بود که ما کنترلی بر روی نویز و در نتیجه بر روی خروجی نداشتیم. تصاویر تولید شده اغلب تصادفی و غیرمرتبط بودند. هدف این بود که بتوانیم نویز را طوری کنترل کنیم که تصویر تولید شده همچنان یک «اسب» باشد، اما یک اسب «جدید».</p><p>مدل‌های یادگیری ماشین قبلی نمی‌توانستند این الگوهای ساده را کنترل کنند، اما به تدریج این مشکل حل شد.</p><h2>ترانسفورمرها و معماری‌های خاص</h2><p>ترانسفورمرها به خودی خود یک تابع آماده در کتابخانه‌هایی مانند TensorFlow یا PyTorch هستند و به تنهایی چیزی تولید نمی‌کنند. آن‌ها باید در یک <strong>معماری خاص</strong> استفاده شوند.</p><p>این معماری دارای یک بخش غیرقابل تغییر (معمولاً ترانسفورمر پیش‌آموزش‌دیده و متن‌باز مانند GPT یا ResNet) و یک بخش قابل آموزش است. بخش قابل آموزش جایی است که دانشجویان و محققان می‌توانند نوآوری کنند و از شبکه‌های ساده‌تری مانند U-Net استفاده کنند.</p><p>با ترکیب این ابزارها و معماری‌های مختلف، می‌توان یک معماری خاص برای تولید داده‌های جدید ایجاد کرد.</p><h2>بازنمایی کلمات (Word Representation)</h2><p>هدف این است که کلمات و جملات را به گونه‌ای <strong>بازنمایی (Represent)</strong> کنیم که برای کامپیوتر و الگوریتم‌های یادگیری ماشین، همان معنایی را داشته باشند که برای ما انسان‌ها دارند.</p><h3>مدل Bag of Words (BOW)</h3><p>اولین و ساده‌ترین تلاش‌ها در این زمینه، مدل <strong>Bag of Words (BOW)</strong> بود. در این مدل، جایگاه و ترتیب کلمات در جمله مهم نیست؛ فقط <strong>تکرار (Frequency)</strong> آن‌ها اهمیت دارد.</p><h4>مثال BOW</h4><p>فرض کنید دو متن داریم:</p><ol><li>متن اول: «گربه مادر خوابید.»</li><li>متن دوم: «بچه گربه، گربه مادر پرید.»</li></ol><p>توکن (Token) کوچکترین واحد معنایی یک جمله است. در اینجا، کلمات را به عنوان توکن در نظر می‌گیریم: «گربه»، «مادر»، «خوابید»، «بچه»، «پرید».</p><p>سپس تعداد تکرار هر کلمه را در هر متن می‌شماریم. مثلاً در متن اول، «گربه» یک بار، «مادر» یک بار و «خوابید» یک بار تکرار شده است. این متن به صورت عددی (مثلاً [۱، ۱، ۱، ۰، ۰]) بازنمایی می‌شود.</p><p>این بازنمایی عددی به خودی خود برای ما معنی ندارد، اما به طرز شگفت‌انگیزی، وقتی این اعداد وارد الگوریتم‌های ریاضی می‌شوند، تقریباً همان معانی را منتقل می‌کنند.</p><h3>منطق ریاضی در زبان</h3><p>ما نمی‌دانیم چرا این اتفاق می‌افتد، اما فرض می‌کنیم که پشت زبان ما انسان‌ها، یک منطق ریاضی وجود دارد. این همان ریاضیاتی است که ما درک می‌کنیم.</p><p>به عنوان مثال، اگر کلمات را به صورت بردارهای عددی در یک فضای چندبعدی رسم کنیم، روابط ریاضی بین آن‌ها برقرار می‌شود:</p><pre style=\"white-space: pre-wrap !important; word-wrap: break-word !important; overflow-x: auto !important; max-width: 100% !important; padding: 1rem; background-color: #f5f5f5; border-radius: 4px; direction: ltr; font-family: \'Courier New\', monospace; font-size: 0.9em; line-height: 1.5; margin: 1rem 0;\"><code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; display: block; overflow-x: auto; font-family: \'Courier New\', monospace;\">ملکه = زن + مرد - پادشاه</code></pre><p>یا فاصله بین «پریدن» و «پرید» (فعل و گذشته آن) برابر است با فاصله بین «خوابیدن» و «خوابید». همچنین، فاصله بین «گربه مادر» و «بچه گربه» برابر است با فاصله بین «مرغ» و «جوجه». این نشان می‌دهد که روابط معنایی مانند «مادری» را می‌توان از طریق اعداد نمایش داد.</p><p>این مفاهیم نشان می‌دهند که پشت آنچه ما درک می‌کنیم، ریاضیات و اعداد (ماتریس‌ها) نهفته است.</p><p>مدل BOW بسیار قدیمی است و معانی زیادی را منتقل نمی‌کند، زیرا فقط بر اساس تکرار کلمات است. بسیاری از فرمول‌های ریاضی پاسخ‌های خوبی با این مدل نمی‌دهند.</p><h2>مکانیسم توجه (Attention Mechanism)</h2><p>برای پاسخ دقیق‌تر به سؤالات مربوط به هوش مصنوعی مولد، به مفهوم <strong>توجه (Attention)</strong> می‌پردازیم.</p><p>بردار توجه (Attention Vector) یک بردار عددی است که به اندازه بردار ورودی است و نشان‌دهنده میزان توجه به هر قسمت از ورودی است. ترانسفورمرها بر مبنای همین مکانیسم توجه کار می‌کنند.</p><p>فرض کنید می‌خواهیم فقط روی کلمه «گربه» تمرکز کنیم. در این صورت، در بردار توجه، مقدار مربوط به «گربه» یک و بقیه صفر می‌شوند. سپس این بردار توجه را در بردار اصلی کلمات ضرب می‌کنیم تا فقط روی «گربه» تمرکز شود.</p><p>این نشان می‌دهد که شما از مفاهیم سطح پایین (مانند ضرب و تقسیم) برای ایجاد مکانیسم‌های پیچیده استفاده می‌کنید.</p><h3>نحوه عملکرد GPT و ترانسفورمرها</h3><p>GPT و ترانسفورمرها چگونه کار می‌کنند؟ آن‌ها از مفاهیم سطح پایین‌تر مانند RNNها، LSTMها، و اتو-انکودرها استفاده می‌کنند و آن‌ها را با یک معماری خاص به هم متصل می‌کنند. این اتصالات و ترتیب قرار گرفتن این اجزا در یک «پایپ‌لاین» (Pipeline) است که اهمیت دارد.</p><p>اینکه چگونه این اجزا به هم متصل می‌شوند، عمدتاً از طریق <strong>آزمون و خطا (Trial and Error)</strong> کشف می‌شود. در حال حاضر، ما ابزار ریاضی برای اثبات اینکه «این روش بهتر است» نداریم و فقط به صورت تجربی عمل می‌کنیم.</p><h3>جلوگیری از Overfitting</h3><p>برای جلوگیری از <strong>Overfitting</strong> (بیش‌برازش)، هیچ راه‌حل قطعی وجود ندارد و فقط به صورت تجربی و با آزمون و خطا عمل می‌کنیم.</p><h2>فرآیند آموزش مدل‌ها</h2><p>فرآیند کلی آموزش مدل‌ها به این صورت است:</p><ol><li><strong>منابع (Resources)</strong>: شما یک سری منابع پردازشی (زمان یا واحد پردازش) و تعداد مشخصی <strong>اپوک (Epoch)</strong> (تکرار آموزش بر روی کل دیتاست) در اختیار دارید. برای مدل‌های کوچک، می‌توان ۲۰۰ تا ۳۰۰ اپوک انجام داد، اما برای مدل‌های بزرگی مانند GPT، ممکن است فقط ۱۰ تا ۱۲ اپوک انجام شود که ماه‌ها طول می‌کشد و میلیون‌ها دلار هزینه برق دارد.</li><li><strong>حالت یادگیری (Training Mode)</strong>: ابتدا مدل را در حالت یادگیری (Training) قرار می‌دهید.</li><li><strong>داده‌های آموزشی (Training Data)</strong>: کل داده‌های آموزشی را به مدل می‌دهید.</li><li><strong>محاسبه خطا (Loss Calculation)</strong>: مدل بر اساس ورودی، خروجی را پیش‌بینی می‌کند. سپس میزان خطا (Loss) بین خروجی مدل و مقدار صحیح را محاسبه می‌کنید.</li><li><strong>به‌روزرسانی وزن‌ها (Weight Update)</strong>: با استفاده از یک تابع خاص (Proprietary Function)، وزن‌های مدل را به‌روزرسانی می‌کنید تا خطا کاهش یابد.</li></ol><p>این فرآیند به صورت تکراری انجام می‌شود تا مدل به بهترین عملکرد خود برسد.</p></div>','completed','2025-11-09 07:30:45','2025-12-03 04:33:26',NULL,NULL,0,NULL,1,NULL),(53,4,1,'هوش مصنوعی مولد (Generative AI) - مفاهیم و معماری ترنسفورمر','1404/08/05','<div style=\"max-width: 100%; overflow-x: hidden; word-wrap: break-word; padding: 1rem; box-sizing: border-box;\"><div style=\"max-width: 100%; overflow-x: hidden; word-wrap: break-word; padding: 1rem; box-sizing: border-box;\"><h1>هوش مصنوعی مولد (Generative AI)</h1><p>هدف این جلسه این است که بسیاری از سؤالات و ابهامات شما درباره ابزارهایی که استفاده می‌کنید، برطرف شود. وقتی از یک LLM استفاده می‌کنید، می‌خواهیم کلیت و آنچه پشت آن است را بفهمید. البته جزئیات آن در سطح کارشناسی نیست.</p><h2>وظایف هوش مصنوعی</h2><p>اگر از جلسات گذشته به خاطر داشته باشید، هوش مصنوعی در حوزه انجام وظیفه دو تا تسک کلی انجام می‌دهد:</p><ul><li><b>تشخیص (Discrimination):</b> برای تشخیص استفاده می‌شود.</li><li><b>تولید (Generation):</b> برای تولید استفاده می‌شود.</li></ul><p>در جلسات گذشته به تشخیص‌گرها پرداختیم، مثل شبکه‌های عصبی و درخت‌ها، که با چند سؤال، اسم آدم‌ها را پیدا می‌کردند. این برای تشخیص بود.</p><h2>معرفی هوش مصنوعی مولد (GenAI)</h2><p>امروز می‌خواهیم درباره <b>Generative AI (GenAI)</b> صحبت کنیم. کلیات آن را بررسی می‌کنیم، نه جزئیات و فرمول‌ها و الگوریتم‌ها و اصطلاحات خاص. فقط اصطلاحات کلی.</p><p>GenAI مخفف Generative AI است. ان‌شاءالله بخش بزرگی از شما چه در مارکت، چه در حوزه دانشگاه، در این حوزه فعالیت خواهید کرد. چه در بازار، چه در شرکت‌های هوش مصنوعی، سازمان‌های دولتی، یا در بحث پژوهش و استارتاپ‌ها. احتمالاً خیلی از شما به این حوزه که حوزه تازه آمده و اوایلش است، علاقه‌مند باشید.</p><h3>تعریف GenAI</h3><p>کل ماجرا چیست؟ کل ماجرا این است که یک هوش مصنوعی توانایی انجام دادن برخی کارها را در حداقل یک سطح انسان معمولی داشته باشد. این کارها را چطور انجام می‌دهد؟ با یادگیری ماشین.</p><h3>یادگیری ماشین</h3><p>یادگیری ماشین چی بود؟ یک سری روش ریاضی بود که می‌آمد الگوهای کلی و مشترک را از روی داده‌ها یاد می‌گرفت. حالا این الگوهای کلی و مشترک که یاد گرفته یعنی چی؟ یعنی چهره آدم‌ها، همه آدم‌های دنیا، یک تمپلت مشخصی دارند. بله، در جزئیات متفاوتند، ولی یک تمپلت کلی و یک الگوی کلی و مشترک برای شناخت انسان‌ها وجود دارد.</p><p>حالا این‌ها را می‌توانیم جزئیاتش را یک کمی کم و زیاد کنیم و بر اساس آن، آدم‌های مختلفی را تولید بکنیم، عکس‌های جدیدی تولید بکنیم، چهره‌های جدیدی تولید بکنیم که خیلی واقعی به نظر می‌رسند ولی در دنیای واقعی وجود خارجی ندارند.</p><p>ما درباره این صحبت می‌کنیم. ابتدا احتمالاً درباره تصویر و بعدش جلوتر که برویم، درباره متن. خیلی جالب خواهد بود.</p><h3>اهداف آموزشی</h3><p>همانطور که گفتم، برای امتحان، اگر می‌خواهید درس بخوانید، این جزوه را بخوانید تا چیزهایی که باید یادتان باشد، یادتان بماند. یا از توی کتاب، نکات مهم را از انتهای فصل برمی‌دارید یا از توی جزوه. دوستانی که جلسه اولشان است، برای امتحان خواندن، این‌ها را به صورت سؤال طراحی کنید و پاسخشان را بدهید. این تضمین می‌کند که حداقل نمره امتحان را می‌توانید بگیرید.</p><h2>مفهوم هوش مصنوعی مولد</h2><p>اولین کاری که می‌خواهیم انجام دهیم، یک تعریفی از آن داشته باشیم. هوش مصنوعی مولد، چیکار می‌کند؟ داده جدید تولید می‌کند. البته نه فقط تولید، خلق می‌کند. انگار یک جور خلاقیت هم تویش باید باشد. داده‌های جدید.</p><p>این داده‌ها هر چیزی می‌تواند باشد: متن، تصویر، صدا، ویدئو، کد برنامه، هر چیزی که فکر کنید، سیگنال.</p><h3>مدل‌ها و معماری‌ها</h3><p>شما به عنوان نسلی که وارد حوزه کامپیوتر می‌شوید و بیشتر با این هوش مصنوعی از این به بعد درگیر خواهید بود، همانطور که گفتیم، ما اصطلاحات داریم، مثل مدل‌های هوش مصنوعی. جلسه گذشته بهتون گفتم، شبکه‌های عصبی، برنامه‌های هوش مصنوعی، ما نمی‌گوییم برنامه هوش مصنوعی، بهش می‌گوییم مدل هوش مصنوعی.</p><p>این مدل‌ها هر کدامشان یک یا چند معماری استفاده کرده‌اند. یعنی هر مدلی از یک معماری حداقل استفاده می‌کند. و بعد معماری‌هایی هستند که یک بیگ جامپ بزرگند. معمولاً این‌ها را شرکت‌های بزرگ می‌سازند. چرا؟ چون سرمایه‌گذاری می‌کنند، ابزار دارند.</p><p>یکی از این بیگ جامپ‌های بزرگ، معماری <b>ترنسفورمر (Transformer)</b> است. فکر کنم مال آزمایشگاه گوگل باشد. این معماری را حالا شاید توی اسلایدها معماری‌اش را هم ببینیم. این باعث شده که ما بتوانیم آن الگوهای کلی و مشترکی که قبلاً کشف می‌کردیم را بهتر کشف کنیم و بتوانیم به این‌ها چیکار کنیم؟ یک کمی هم تغییر بدهیم و با آن‌ها بتوانیم دیتای جدید تولید کنیم.</p><p>پس، زیر سر این هوش مصنوعی مولد، ظهور یک معماری به نام <b>ترنسفورمر</b> بود که توانسته LLMها را به وجود بیاورد و حتی مدل‌های بصری. و این انفجارش را هم شما از طریق مدل GPT، یعنی Generative Pre-trained Transformer، می‌بینید.</p><h3>ترنسفورمرها</h3><p>ترنسفورمرها همان شبکه‌های عصبی اصلی‌ترین و یک جور شبکه عصبی عمیق هستند، ولی معماری خاصی دارند. تفاوتشان با RNNها این است که این‌ها هم جزو خانواده RNNها محسوب می‌شوند. LSTM هم یک نوع RNN است. این‌ها قدیمی‌تر بودند. خود فکر می‌کنم این ترنسفورمر دوباره از این‌ها استفاده کرده است.</p><h2>منطق پشت هوش مصنوعی مولد</h2><p>حالا بیایید منطق پشتش را با هم بررسی کنیم. ما که قرار نیست فرمول ریاضی‌اش و الگوریتم‌هایش را با هم بررسی کنیم، ولی منطقش را با هم به زبان ساده‌سازی شده با هم بررسی می‌کنیم.</p><h3>انتقال الگوها</h3><p>شما یک دیتاستی دارید از تصاویر اسب‌ها. بهش می‌گوییم دیتاسف اسب. یک دونه <b>ان‌کدر (Encoder)</b> هم داریم. اگر درست‌ترش را بگویم، <b>آتو ان‌کدر (Autoencoder)</b> هست. این چیکار می‌کند؟ یاد می‌گیرد که از این دیتاسف چجوری این‌ها را به یک رپرزنتیشنی در بیاورد. کار آتو ان‌کدر همین است. یک رپرزنتیشنی در بیاورد که شما بتوانید از آن حداکثر الگوها را استخراج کنید. حالا تصاویر اسب، الگوهای اسب. این‌ها فرمول ریاضی‌اش و فلان این‌هاست. این وزن‌ها کنار هم هیچ معنی هم ندارد. ولی آن‌ها در واقع الگوها هستند. چی هستند الگوها؟</p><p>شما مثلاً توی مثال اسب، اگر ببینید، دنبال چی هستید؟ مفهوم اسب. اسب بودن یعنی چی؟ اسب. این مفهوم کلی است.</p><h3>رمزگذاری و رمزگشایی (Encoder-Decoder)</h3><p>GenAI ما معمولاً دو بخش دارد. یک بخش <b>رمزگذاری (Encoder)</b> داریم و یک بخش <b>رمزگشایی (Decoder)</b> داریم. بخش رمزگذاری از یک سری آتو ان‌کدرها استفاده می‌کند که بیایند چیکار کنند؟ الگوهای کلی و مشترک مربوط به آبجکت را استخراج کنند، یعنی درست‌ترش یاد بگیرند. خب. بعد این چیکار می‌کند؟ این الگوهایی که یاد گرفته، یک سری عددند دیگر. می‌آید توشون <b>نویز (Noise)</b> تدریق می‌کند. نویز، واقعاً نویز. یعنی اعداد تصادفی کوچولو. مثلاً اگر اینجا این پنج تا عدد دارید که مثلاً ۲.۵، ۲.۷۳، ۲.۵ و فلان این‌ها، این‌ها را یک کوچولو اون مقادیر کمشون، اعشارشون را بالاتر می‌برد. ۲.۷۳ می‌شود ۲.۷۵. ولی رندوم هیچکی نمی‌داند چرا. فعلاً نمی‌دانیم چرا.</p><p>این تغییرات کوچیک را یک مقدار نویز اضافه می‌کنیم و با اون وزن‌ها جمع می‌شود. خیلی ساده. و دوباره اون را می‌دهیم به یک آتو ان‌کدر دیگر، یعنی به وزن اولیه می‌دهیم که مفهوم اسب بودن را می‌داند. این اعداد را دوباره اگر رمزگشایی کند، اسب‌های جدیدی به ما می‌دهد، ولی هنوز اسب‌اند. درسته؟ همه این‌ها. ممکن است البته بعضی از این‌ها دقیقاً همین باشند. اگر شما این تغییرات کوچیک را اونجا اضافه نمی‌کردید، دقیقاً فقط همین‌هایی که یاد گرفته بود را تولید می‌کرد. ان‌کدش می‌کردید، الگوها را دوباره دی‌کدش می‌کردید، همان را دوباره بازتولید می‌کرد. ولی شما می‌خواستید خلاقیت داشته باشید، دیتای جدید تولید کنید.</p><p>ایده ساده‌اش (که حالا اثبات ریاضی هم دارد) این است که فهمیدند که شما اگر یک کوچولو این اعداد را کم و زیادش بکنید، اوایل اصلاً بدون ایده. دوباره این آتو ان‌کدره دیتای آموزشی را بازتولید می‌کند، ولی نه دقیقاً همان.</p><p>خب، این روال کلی‌اش است. متوجه شدید؟</p><h3>معماری ترنسفورمر و تولید داده</h3><p>ترنسفورمرها خودش یک قطعه کد است. یک تابع آماده است توی کتابخانه مثلاً تنسرفلو یا پایتورچ هستش. این خودش به خودی خود چیزی برای شما تولید نمی‌کند. شما آن را دوباره باید استفاده کنید. این یک کد است. توی یک معماری دیگر استفاده می‌کنید. این معماری یک قواعد خاصی دارد. یعنی یک الگوریتم، یک قسمتی دارد برای ان‌کدینگ و این‌ها که شما نمی‌توانید. می‌توانید یا نزنید، عملی نمی‌توانید. این‌ها از قبل پیش‌آموزش‌دیده و خیلی بزرگند. معماری ترنسفورمر در اختیار شماست.</p><p>یک بخش قابل آموزش دارد. مثلاً می‌توانید از یک شبکه ساده‌ای مثل U-Net استفاده کنید. یک شبکه‌ای که اونجا اونجایی است که شما می‌توانید چی داشته باشید؟ به عنوان دانشجو و محقق، کوچیک، لوکال، ابتکار داشته باشید، ایده. شرکت‌های بزرگ همه این موضوع‌ها را تغییر می‌دهند. آن‌ها ابزار بزرگی می‌خواهند. ولی شما از ابزارهای اوپن سورس استفاده کنید. این قسمت آموزش دارد اینجا. اینجا هم شما می‌توانید تغییر ایجاد کنید. یا الگوریتم دیگر، یک مدل دیگر استفاده کنید. یا روش‌های مختلفی برای اعمال این تغییرات هست. هر کدام از این‌ها یک حوزه خیلی جدیدی است که خیلی هم تقاضا برایش هست. فعلاً فکر می‌کنم حوزه این GenAI این جنرال اینجینیرها هستند.</p><p>حوزه بصری‌اش خیلی کمتر از حوزه زبان LLMهاست. حوزه زبان LLMها خیلی سرمایه‌گذاری کردند. معمولاً حوزه بصری‌اش کمتر هستش. فقط با یک دونه ترنسفورمر و این‌ها نمی‌توانید. یک معماری دارد که ترنسفورمر بخشی از آن است. این ترنسفورمر اگر از قبل آموزش‌دیده اوپن سورس باشد، مثل چیزی که توی GPT است، یا مثلاً برای تصویر، ResNetها هستش که روی ImageNet آموزش دیده. معمولاً از این‌ها استفاده می‌کنند. و انواع ابزارهای متفرقه که وجود دارد. این‌ها را استفاده می‌کنید، کنار هم می‌گذارید، یک معماری خاصی که حالا بخواهیم خیلی کلی و غیر دقیق اگر بگوییم، چنین به اصطلاح رفتاری دارد.</p><h2>انفجار GenAI و اثر هوش مصنوعی</h2><p>الان متوجه شدید دیگر؟ ماجرای پشت این که یک مدل عکس می‌گیرد، تولید می‌کند چجوری است. خب. ایرادی که داشت این است که شما هیچ ایده‌ای نداشتید. یعنی نویز تولید می‌کردید، یک سری اعداد کوچیک با این اعداد بالا جمع می‌شد، یعنی کم می‌شد، تغییر می‌کرد. خب. این دیتای جدید تولید می‌کرد. هیچ چیزی کنترلی نداشتید و اغلب اوقات تصاویر جالبی هم در نمی‌آمد. مثلاً اگر می‌خواستید تصویر تولید کنید، حالا بعدش فکر کردند چیکار کنیم؟ به عنوان نمونه. یعنی اون نویز و تغییرات تصادفی نباید عکس قبلی ما را به یک عکس جدید تبدیل کند.</p><p>شما یک سری الگو یاد گرفتید. الگو در واقع یک سری عدد است. شما این عددها را یک کوچولو تغییر می‌دهید، ولی نباید خیلی از استیلش خارج بشود. مثلاً فرض کنید که همه چیز را اگر به صورت عدد اگر نمایش بدهید، جاهای خاصی که باید تغییر کند. رندوم این‌ها. نباید مثلاً بک‌گراندش خیلی تغییر کند. چرا؟ چون بک‌گراند خیلی ربطی به اسب بودن ندارد. یعنی همین اسب باشد، ولی دوباره یک عکس دیگر تولید کنید، بک‌گراندش مثلاً آبی باشد. این در مفهوم اسب بودن تغییری ایجاد نکرده. ولی ما باید بدانیم کجاها را. ولی متأسفانه ماشینی که داشتیم، فعلاً با این الگوی ساده نمی‌توانستیم این موضوع را کنترل کنیم که این را هم یواش یواش آمدیم جلوتر تا حلش کردیم. حالا می‌رویم روی اسلایدها.</p><p>GenAI تقریباً یک انفجار بود. آمدن چت جی‌پی‌تی نوامبر ۲۰۲۲، توی اواخر ۲۰۲۲. ۲۰۲۳ و ۲۰۲۴. که باعث انفجارش شد. یعنی ما خودمان هم باعث یک هایپی در ما هم شد. هایپ. با آمدن جی‌پی‌تی سه، جی‌پی‌تی چهار، جی‌پی‌تی فور، و این‌ها دیگه کلاً عادی شد و تقریباً از این به بعد، از جی‌پی‌تی فور به اون ور دیگه دچار AI Effect شد. یعنی انگار دیگه خیلی چیز مهمی نبود. الان مثلاً دیگه برای شما مهم نیست که جی‌پی‌تی پنج خیلی قابلیت‌هایش بیشتر از جی‌پی‌تی فور بود. ببخشید، قبل از ۲۰۲۲ هم ما درس مبانی هوش مصنوعی داشتیم توی دانشگاه. خیلی قدیمی است. علم هوش مصنوعی تعریفش قدیمی‌تر از علم خود کامپیوتر است. ایده هوش از طریق دستگاه‌های غیرارگانیک. خیلی قدیمی است. حالا شما ویدئو را ندیدید. درباره این تاریخچه را با بچه‌های سال بالایی هستش توی کتاب‌ها و داکیومنت‌هاش هست.</p><h3>مدل‌های تولید تصویر</h3><p>این برای تولید متن بود. از اون طرف برای تولید تصویر هم مدل‌هایی هست مثل دال‌ای (DALL-E) ورژن‌های دو، سه، چهار و میدجرنی (Midjourney). میدجرنی اول که آمده بود رایگان هم بود. حالا هنوز به شما کردیت رایگان می‌دهد. ولی اوایل کلاً رایگان بود. چرا؟ چون این شرکت‌ها، استارتاپ‌ها رایگان یک مشتری جذب می‌کنند و بعد پولیش می‌کنند. این استراتژی‌شان است. الان برای تولید متن، GenAI مثلاً می‌آید توکن می‌فرستد. الان می‌بینیم کاملاً. بعد می‌آید بردارش می‌کند. آفرین. اصلاً استایل بعدی همین است. ما ابتدا الان می‌خواهیم به متن بپردازیم. می‌گویم برای همین خیلی از ابهامات شما که دست به گریبان این زیر و بم بودید، احتمالاً به حد زیادی برطرف بشود. اما این چیزهایی که می‌گوییم الفبا هستش. GenAI خیلی درست مثل بقیه کارکردها، برابر با هوش مصنوعی اصلی است.</p><h2>بازنمایی متن (Text Representation)</h2><p>خب. ما توی مبانی هوش مصنوعی، اگر از کلاس‌های قبلی ذهن داشته باشید، ما گفتیم که هر الگوریتم چیکار می‌کرد؟ یک ورودی داریم، یک فضای فرضیه. از اون یک جواب درست برمی‌داشت، اون را وریفای می‌کرد. ما بعد بر اساس این، تسک‌هایی مثل AI Complete را تعریف کردیم، مثل صحبت کردن. گفتیم که یک انسان در طول روز ۳۰۰ تا ۷۰۰ تا کلمه است. یعنی شما در طول روزهای عادی‌تون، حداکثر ۳۰۰ تا کلمه برای بیان خواسته‌هاتون استفاده می‌کنید. زبان‌های دیگر هم همین است. یعنی زبان فارسی، انگلیسی، ۵ میلیون، ۵۰ میلیون کلمه دارد. ولی شما که از همه‌اش استفاده نمی‌کنید. بیشتر اون کلمات در ادبیات و کتاب‌های قدیمی است. شما در طول روز که می‌خواهید با هم صحبت کنید و خواسته‌هاتون را برطرف کنید، فقط از ۳۰۰ تا کلمه استفاده می‌کنید. ولی آیا شما با این ۳۰۰ تا کلمه چند تا خواسته را می‌توانید بیان کنید؟ تقریباً بی‌نهایت خواسته را می‌توانید با این ۳۰۰ تا کلمه بیان کنید.</p><p>نکته این است که تعداد حالاتی که این ۳۰۰ تا کلمه را می‌توانید پشت هم رندوم بچینید، بدون اینکه گرامر و این چیزها را رعایت کنید، چقدر است؟ ۲ به توان ۳۰۰ تا کلمه. خیلی بزرگ است. اگر شما می‌خواستید مثلاً یک خواسته‌تون را بگویید با این ۳۰۰ تا کلمه، درسته؟ اگر هوش نداشتید، احتمالاً برای بیان یک خواسته ساده‌ای مثل این که من آب می‌خواهم، تا ابد باید کلمات این ۳۰۰ تا کلمه را رندوم پشت سر هم می‌چیدید تا اون ترکیب درست در بیاید و مثلاً همکار دوباره متوجه خواسته شما بشود. این ایده اصلاً خوب نباشه.</p><h3>زبان و بازنمایی</h3><p>خب. زبان، این مفهوم هنوز هم خیلی چیز نیست، یک انتزاعی است. خیلی روش بحث است. انتزاعش چیه؟ یک دنیایی دارد، نظریاتی دارد و کاری به آن نداریم. ولی یکی از فن‌های ما هست. ما می‌خواهیم چیکار کنیم؟ می‌خواهیم کلمات را، همین کلمات، خب، کلمات، جملات را رپرزنت کنیم. بازنمودی ازش ایجاد کنیم، بازنمایشی ازش ایجاد کنیم که برای کامپیوتر، درست‌ترش را بگویم، برای الگوریتم‌های یادگیری ماشین، همین معنایی که ما داریم را داشته باشد.</p><p>شما چه رپرزنتیشنی از این کلمات به صورت عددی درست کنید که وقتی آن‌ها را جمله بگویید، عدد بگویید، دوباره همان معانی را داشته باشد. ما دنبال این هستیم.</p><h3>مدل Bag of Words (BoW)</h3><p>اولین تلاش‌ها، ساده‌ترین‌ها، مدلی هست به نام <b>Bag of Words (BoW)</b> یا سبد کلمات. ساده‌ترینش این است که شما وقتی کلمات را دارید، این‌ها دیگر جایگاه خاصی ندارد. اینکه کدام فعل است، اینکه کدام اسم است، اینکه کدام فاعل است، اصلاً این‌ها مهم نیست. هیچ. در هم بر هم است. داخل یک سبد است. ترتیبشان اصلاً مهم نیست. چی برایشان مهم است؟ تکرارشان، فرکانسشان، تعدادشان.</p><h3>مثال BoW</h3><p>فرض کنید که یک جمله‌ای داریم، یک سندی داریم به نام گربه مادر خوابید. متن دوم چیه؟ بچه گربه پرید. شما می‌خواهید یک رپرزنتیشنی که ایجاد کنید بر اساس چیه؟ تعداد تکرارشان. خیلی ساده.</p><h3>توکن‌سازی (Tokenization)</h3><p>اولاً توکن چیست؟ توکن یعنی یک جمله را بشکنید به کوچک‌ترین اجزای دارای معنی. برای چی؟ بسته به کاربرد. یعنی شما می‌توانید جمله را به کلمات توکن‌سازی بکنید، حتی به کاراکترها توکن کنید. هر دوی این‌ها استفاده می‌شود. هر کدام چیز اپلیکیشن‌های خودش را دارد، ولی اغلب شما در سطح کلمات توکن‌سازی می‌کنید. پس توکن را متوجه شدید. کوچک‌ترین واحد اتمی دارای معنی از یک جمله.</p><p>توکن‌ها اینجا چی‌ها هستند؟ کلماتی که این‌ها هستند: گربه هست، مادر هست، خوابید، بچه، پرید. خب. خیلی ساده می‌شماریم. کلمه گربه توی متن اول چند بار پیدا شده؟ یک بار. از مادر؟ یکی. خوابید؟ یکی. و بقیه هم همینطور. توی پایین هم همینطور. توی پایین گربه دو بار تکرار شده، مادر یک بار تکرار شده و و و.</p><p>پس ما آمدیم چیکار کردیم؟ متن یک، برای ما که یک موجود ارگانیک هستیم، از طریق این کلمات معنای مشخصی دارد. گربه مادر خوابید، معنای دیگری ندارد دیگر. یک معنا بیشتر برای ما منتقل نمی‌کند. این را شما به صورت چهار تا، پنج تا عددش می‌کنید. یک، یک، یک، صفر، صفر، صفر. هیچ معنی‌ای ندارد، درسته؟ یک بازنمایش است. ولی به طور شگفت‌انگیزی، به طور شگفت‌انگیزی، تأکید می‌کنم، می‌بینیم که این اعدادی که هیچ معنی‌ای ندارند، وقتی وارد دنیای ریاضیات می‌شوند، تقریباً همین معانی را منتقل می‌کنند. در حالی که شما یک رپرزنتیشن ازش ایجاد می‌کنید، از خود رپرزنتیشن به عنوان یک انسان هیچ تفسیری نمی‌توانید داشته باشید.</p><p>یعنی چی؟ یعنی شما این‌ها را، این بردارهای عددی را اگر ببرید توی فضای مثلاً چهار پنج بعدی، چند بعدی، یک فضا ببرید، رسمشان کنید، می‌بینید که روابط ریاضی برقرار است. مثلاً ملکه مساوی است با زن به اضافه مرد منهای پادشاه، می‌شود ملکه. یعنی ما نمی‌دانیم چرا اینجوری است. ما حدس می‌زنیم که درسته که زبان ما انسان‌ها با اعداد کار نمی‌کند، ولی پشتش، در این تکاملش، در اون ازلی‌اش، یک منطق ریاضی بوده پشتش. همین ریاضی که ما ازش به اصطلاح تلقی که ازش داریم. ما داریم از کلمات استفاده می‌کنیم، درسته؟ ولی منظورمون تهش انگار دارد دوباره همین فرمول‌های ریاضی را استفاده می‌کند. از کجا حدس می‌زنیم این موضوع درست باشد؟ از این که دوباره ما آمدیم این کاراکترها را برگرداندیم به اعداد و بردیم فرمول‌های ریاضی روش انجام دادیم، دیدیم که این جواب می‌دهد. معانی را دارد منتقل می‌کند.</p><h3>روابط معنایی در فضای برداری</h3><p>حالا بین متن اول و متن دوم، اینجا شما به عنوان یک انسان، فقط یک سری عدد می‌بینید که هیچ معنی خاصی برای شما ندارد. ولی اگر ما این‌ها را در فضای سه‌بعدی بخواهیم بکشیم، خب، می‌بینیم که این‌ها یک رابطه معنایی با هم دارند. همین رابطه معنایی که ما به اصطلاح برای ما درست است توی این دنیا. مثلاً فاصله پریدن، فعل پریدن تا زمان سومش پرید، دقیقاً برابر است با فاصله خوابیدن تا خوابید. احتمالاً افعال اینجوری هستند. یا فاصله گربه مادر تا بچه گربه، گربه بچه، خب، دقیقاً برابر است با فاصله مرغ تا جوجه. یعنی رابطه مادری را توانستیم از طریق اعداد بگیریم. رابطه مادری. نه فقط توی حالت حیوان، انسان هم همینطور. یعنی چی؟ جهانی که ما داریم زیست می‌کنیم، انگار پشتش همش ریاضی و عدد است. شما ماتریس را دیدید؟ همه صفر و یکش را می‌دهد. ماتریس را ندیدید؟ برای ما قدیمی است. ماتریس را ببینید. یک فلسفه اینجوری پشتش هست. ماتریس خیلی جلوتر از خودش است. اینقدر که مثلاً دنیا را به دو قسمت تقسیم کرده‌اند: دنیای قبل از ماتریس و دنیای بعد از ماتریس. این فلسفه جدید است.</p><h2>چالش‌های BoW و مدل‌های جدید</h2><p>اگر کسی از شما پرسید رپرزنتیشن چیه، می‌خواهم این را به ذهن شما منتقل کنم. برای یک دیتاسف کوچیک. ولی وقتی شما می‌خواهید یک مدل بزرگ بسازید، معمولاً یک دیکشنری است. دیکشنری انگلیسی. معمولاً. تازه این مدل BoW خیلی قدیمی است. خیلی معانی زیادی هم نمی‌دهد. بسیاری از فرمول‌های ریاضی پاسخ جالبی تولید نمی‌کند. چرا؟ چون ذاتاً بر اساس تکرار بوده. ولی برخی معانی کلی را هنوز هم منتقل می‌کند. سیستم‌های قدیمی از این‌ها استفاده می‌کردند. ما الان مدل‌های خیلی جدیدتری داریم، مثل چی؟ مثل GPT، مثل BERT.</p><p>شما سؤال اولتان این بود که چجوری از اورفیتینگ جلوگیری کنیم؟ هیچ راه‌حلی ندارد. فقط به صورت تجربی. یعنی هر دفعه می‌آییم چیکار می‌کنیم؟ تستش می‌کنیم. با به اصطلاح مقادیر، با آزمایشش. آره. ما یک استاندارد داریم که توی جلسه گذشته هم خودش را اینجا نوشتم. توی کلاس بعدی.</p><h2>فرآیند آموزش مدل‌ها</h2><p>کل روال آموزش مدل‌ها اینجوری است. شما یک مدل پرترین دارید برای یک تعداد اپوک. اپوک یک عدد است. شما یک تعداد توانایی پردازشی دارید. خب. این توانایی پردازش می‌تواند زمان باشد یا مقدار یونیتی که برای پردازش. مثلاً شما اگر از دانشکده می‌خواهید جی‌پی‌یو قرض بگیرید، به شما ساعت‌های خاصی بهتون می‌دهد. یک ساعت، دو ساعت بیشتر بهتون نمی‌دهد. که یک دو ساعت. دو تا، سه تا. مدل‌تون، دیتاتون کوچکتر باشد، اپوک‌ها بیشتر است. ۲۰۰ تا ۳۰۰ اپوک می‌روید. ولی مثلاً مدل‌های گنده‌ای مثل جی‌پی‌تی، من فکر می‌کنم ۱۰-۱۲ تا بیشتر ندارد. اون هم چند ماه طول می‌کشد. مثلاً چندین میلیون، ۴۰-۵۰ میلیون دلار هزینه‌اش می‌شود. برقی که مصرف می‌کنند، یک فارم شما، گرمایی که تولید می‌کنند. خیلی هزینه زا هستش.</p><p>خب. پس یک تعداد منابعی داریم. تکرار می‌دانیم انجام بدهیم. روی چی؟ روی کل، ببخشید، روی این که می‌گوید چجوری اورفیتینگ می‌خواهیم جلوگیری کنیم، چیز استانداردش این است. می‌آید چیکار می‌کند؟ می‌آید اول مدل را می‌گذارد توی حالت یادگیری (Training). خودش را می‌نویسم مدل. بعد می‌آید کل مدل را پرترین می‌کند با دیتای آموزشی. خب. پردیت تا این ترین دیتای ترین. چیکار کن؟ پارادایم یادگیری سه‌تایی یادگیری یادتونه چیکار می‌کرد؟ یک مدلی داشتید دیگر. یک مدلی داشتید. می‌آمد چیکار می‌کرد؟ یک رفتاری را پردیکت می‌کرد. مساوی است با مدل. این دیتا، دیتای این. این دیتا خودش دو تا تیکه داشت دیگر. جفت بود دیگر. جواب، و ورودی و مقدار درستش. مدل می‌کند مثلاً دیتا دات اینپوت و همین مقدار درستش. وزن را اینجا نمی‌نویسم. درستش این است که یک وزن می‌نوشتیم. این‌ها هم زبان کدنویسی است.</p><p>بعد می‌آمدیم چیکار می‌کردیم؟ مقدار لاس را محاسبه می‌کردیم. مقدار خطا. یادتان می‌آید؟ خب. یادتان می‌آید. این را می‌آمدیم چیکار می‌کردیم؟ از طریق یک تابعی، یک پرایتریا، چیکار می‌کردیم؟ جنرالایزش می‌کردیم.</p></div></div>','<div style=\"max-width: 100%; overflow-x: hidden; word-wrap: break-word; padding: 1rem; box-sizing: border-box;\"><h1>هوش مصنوعی مولد (Generative AI)</h1><p>هدف این جلسه این است که بسیاری از سؤالات و ابهامات شما درباره ابزارهایی که استفاده می‌کنید، برطرف شود. وقتی از یک LLM استفاده می‌کنید، می‌خواهیم کلیت و آنچه پشت آن است را بفهمید. البته جزئیات آن در سطح کارشناسی نیست.</p><h2>وظایف هوش مصنوعی</h2><p>اگر از جلسات گذشته به خاطر داشته باشید، هوش مصنوعی در حوزه انجام وظیفه دو تا تسک کلی انجام می‌دهد:</p><ul><li><b>تشخیص (Discrimination):</b> برای تشخیص استفاده می‌شود.</li><li><b>تولید (Generation):</b> برای تولید استفاده می‌شود.</li></ul><p>در جلسات گذشته به تشخیص‌گرها پرداختیم، مثل شبکه‌های عصبی و درخت‌ها، که با چند سؤال، اسم آدم‌ها را پیدا می‌کردند. این برای تشخیص بود.</p><h2>معرفی هوش مصنوعی مولد (GenAI)</h2><p>امروز می‌خواهیم درباره <b>Generative AI (GenAI)</b> صحبت کنیم. کلیات آن را بررسی می‌کنیم، نه جزئیات و فرمول‌ها و الگوریتم‌ها و اصطلاحات خاص. فقط اصطلاحات کلی.</p><p>GenAI مخفف Generative AI است. ان‌شاءالله بخش بزرگی از شما چه در مارکت، چه در حوزه دانشگاه، در این حوزه فعالیت خواهید کرد. چه در بازار، چه در شرکت‌های هوش مصنوعی، سازمان‌های دولتی، یا در بحث پژوهش و استارتاپ‌ها. احتمالاً خیلی از شما به این حوزه که حوزه تازه آمده و اوایلش است، علاقه‌مند باشید.</p><h3>تعریف GenAI</h3><p>کل ماجرا چیست؟ کل ماجرا این است که یک هوش مصنوعی توانایی انجام دادن برخی کارها را در حداقل یک سطح انسان معمولی داشته باشد. این کارها را چطور انجام می‌دهد؟ با یادگیری ماشین.</p><h3>یادگیری ماشین</h3><p>یادگیری ماشین چی بود؟ یک سری روش ریاضی بود که می‌آمد الگوهای کلی و مشترک را از روی داده‌ها یاد می‌گرفت. حالا این الگوهای کلی و مشترک که یاد گرفته یعنی چی؟ یعنی چهره آدم‌ها، همه آدم‌های دنیا، یک تمپلت مشخصی دارند. بله، در جزئیات متفاوتند، ولی یک تمپلت کلی و یک الگوی کلی و مشترک برای شناخت انسان‌ها وجود دارد.</p><p>حالا این‌ها را می‌توانیم جزئیاتش را یک کمی کم و زیاد کنیم و بر اساس آن، آدم‌های مختلفی را تولید بکنیم، عکس‌های جدیدی تولید بکنیم، چهره‌های جدیدی تولید بکنیم که خیلی واقعی به نظر می‌رسند ولی در دنیای واقعی وجود خارجی ندارند.</p><p>ما درباره این صحبت می‌کنیم. ابتدا احتمالاً درباره تصویر و بعدش جلوتر که برویم، درباره متن. خیلی جالب خواهد بود.</p><h3>اهداف آموزشی</h3><p>همانطور که گفتم، برای امتحان، اگر می‌خواهید درس بخوانید، این جزوه را بخوانید تا چیزهایی که باید یادتان باشد، یادتان بماند. یا از توی کتاب، نکات مهم را از انتهای فصل برمی‌دارید یا از توی جزوه. دوستانی که جلسه اولشان است، برای امتحان خواندن، این‌ها را به صورت سؤال طراحی کنید و پاسخشان را بدهید. این تضمین می‌کند که حداقل نمره امتحان را می‌توانید بگیرید.</p><h2>مفهوم هوش مصنوعی مولد</h2><p>اولین کاری که می‌خواهیم انجام دهیم، یک تعریفی از آن داشته باشیم. هوش مصنوعی مولد، چیکار می‌کند؟ داده جدید تولید می‌کند. البته نه فقط تولید، خلق می‌کند. انگار یک جور خلاقیت هم تویش باید باشد. داده‌های جدید.</p><p>این داده‌ها هر چیزی می‌تواند باشد: متن، تصویر، صدا، ویدئو، کد برنامه، هر چیزی که فکر کنید، سیگنال.</p><h3>مدل‌ها و معماری‌ها</h3><p>شما به عنوان نسلی که وارد حوزه کامپیوتر می‌شوید و بیشتر با این هوش مصنوعی از این به بعد درگیر خواهید بود، همانطور که گفتیم، ما اصطلاحات داریم، مثل مدل‌های هوش مصنوعی. جلسه گذشته بهتون گفتم، شبکه‌های عصبی، برنامه‌های هوش مصنوعی، ما نمی‌گوییم برنامه هوش مصنوعی، بهش می‌گوییم مدل هوش مصنوعی.</p><p>این مدل‌ها هر کدامشان یک یا چند معماری استفاده کرده‌اند. یعنی هر مدلی از یک معماری حداقل استفاده می‌کند. و بعد معماری‌هایی هستند که یک بیگ جامپ بزرگند. معمولاً این‌ها را شرکت‌های بزرگ می‌سازند. چرا؟ چون سرمایه‌گذاری می‌کنند، ابزار دارند.</p><p>یکی از این بیگ جامپ‌های بزرگ، معماری <b>ترنسفورمر (Transformer)</b> است. فکر کنم مال آزمایشگاه گوگل باشد. این معماری را حالا شاید توی اسلایدها معماری‌اش را هم ببینیم. این باعث شده که ما بتوانیم آن الگوهای کلی و مشترکی که قبلاً کشف می‌کردیم را بهتر کشف کنیم و بتوانیم به این‌ها چیکار کنیم؟ یک کمی هم تغییر بدهیم و با آن‌ها بتوانیم دیتای جدید تولید کنیم.</p><p>پس، زیر سر این هوش مصنوعی مولد، ظهور یک معماری به نام <b>ترنسفورمر</b> بود که توانسته LLMها را به وجود بیاورد و حتی مدل‌های بصری. و این انفجارش را هم شما از طریق مدل GPT، یعنی Generative Pre-trained Transformer، می‌بینید.</p><h3>ترنسفورمرها</h3><p>ترنسفورمرها همان شبکه‌های عصبی اصلی‌ترین و یک جور شبکه عصبی عمیق هستند، ولی معماری خاصی دارند. تفاوتشان با RNNها این است که این‌ها هم جزو خانواده RNNها محسوب می‌شوند. LSTM هم یک نوع RNN است. این‌ها قدیمی‌تر بودند. خود فکر می‌کنم این ترنسفورمر دوباره از این‌ها استفاده کرده است.</p><h2>منطق پشت هوش مصنوعی مولد</h2><p>حالا بیایید منطق پشتش را با هم بررسی کنیم. ما که قرار نیست فرمول ریاضی‌اش و الگوریتم‌هایش را با هم بررسی کنیم، ولی منطقش را با هم به زبان ساده‌سازی شده با هم بررسی می‌کنیم.</p><h3>انتقال الگوها</h3><p>شما یک دیتاستی دارید از تصاویر اسب‌ها. بهش می‌گوییم دیتاسف اسب. یک دونه <b>ان‌کدر (Encoder)</b> هم داریم. اگر درست‌ترش را بگویم، <b>آتو ان‌کدر (Autoencoder)</b> هست. این چیکار می‌کند؟ یاد می‌گیرد که از این دیتاسف چجوری این‌ها را به یک رپرزنتیشنی در بیاورد. کار آتو ان‌کدر همین است. یک رپرزنتیشنی در بیاورد که شما بتوانید از آن حداکثر الگوها را استخراج کنید. حالا تصاویر اسب، الگوهای اسب. این‌ها فرمول ریاضی‌اش و فلان این‌هاست. این وزن‌ها کنار هم هیچ معنی هم ندارد. ولی آن‌ها در واقع الگوها هستند. چی هستند الگوها؟</p><p>شما مثلاً توی مثال اسب، اگر ببینید، دنبال چی هستید؟ مفهوم اسب. اسب بودن یعنی چی؟ اسب. این مفهوم کلی است.</p><h3>رمزگذاری و رمزگشایی (Encoder-Decoder)</h3><p>GenAI ما معمولاً دو بخش دارد. یک بخش <b>رمزگذاری (Encoder)</b> داریم و یک بخش <b>رمزگشایی (Decoder)</b> داریم. بخش رمزگذاری از یک سری آتو ان‌کدرها استفاده می‌کند که بیایند چیکار کنند؟ الگوهای کلی و مشترک مربوط به آبجکت را استخراج کنند، یعنی درست‌ترش یاد بگیرند. خب. بعد این چیکار می‌کند؟ این الگوهایی که یاد گرفته، یک سری عددند دیگر. می‌آید توشون <b>نویز (Noise)</b> تدریق می‌کند. نویز، واقعاً نویز. یعنی اعداد تصادفی کوچولو. مثلاً اگر اینجا این پنج تا عدد دارید که مثلاً ۲.۵، ۲.۷۳، ۲.۵ و فلان این‌ها، این‌ها را یک کوچولو اون مقادیر کمشون، اعشارشون را بالاتر می‌برد. ۲.۷۳ می‌شود ۲.۷۵. ولی رندوم هیچکی نمی‌داند چرا. فعلاً نمی‌دانیم چرا.</p><p>این تغییرات کوچیک را یک مقدار نویز اضافه می‌کنیم و با اون وزن‌ها جمع می‌شود. خیلی ساده. و دوباره اون را می‌دهیم به یک آتو ان‌کدر دیگر، یعنی به وزن اولیه می‌دهیم که مفهوم اسب بودن را می‌داند. این اعداد را دوباره اگر رمزگشایی کند، اسب‌های جدیدی به ما می‌دهد، ولی هنوز اسب‌اند. درسته؟ همه این‌ها. ممکن است البته بعضی از این‌ها دقیقاً همین باشند. اگر شما این تغییرات کوچیک را اونجا اضافه نمی‌کردید، دقیقاً فقط همین‌هایی که یاد گرفته بود را تولید می‌کرد. ان‌کدش می‌کردید، الگوها را دوباره دی‌کدش می‌کردید، همان را دوباره بازتولید می‌کرد. ولی شما می‌خواستید خلاقیت داشته باشید، دیتای جدید تولید کنید.</p><p>ایده ساده‌اش (که حالا اثبات ریاضی هم دارد) این است که فهمیدند که شما اگر یک کوچولو این اعداد را کم و زیادش بکنید، اوایل اصلاً بدون ایده. دوباره این آتو ان‌کدره دیتای آموزشی را بازتولید می‌کند، ولی نه دقیقاً همان.</p><p>خب، این روال کلی‌اش است. متوجه شدید؟</p><h3>معماری ترنسفورمر و تولید داده</h3><p>ترنسفورمرها خودش یک قطعه کد است. یک تابع آماده است توی کتابخانه مثلاً تنسرفلو یا پایتورچ هستش. این خودش به خودی خود چیزی برای شما تولید نمی‌کند. شما آن را دوباره باید استفاده کنید. این یک کد است. توی یک معماری دیگر استفاده می‌کنید. این معماری یک قواعد خاصی دارد. یعنی یک الگوریتم، یک قسمتی دارد برای ان‌کدینگ و این‌ها که شما نمی‌توانید. می‌توانید یا نزنید، عملی نمی‌توانید. این‌ها از قبل پیش‌آموزش‌دیده و خیلی بزرگند. معماری ترنسفورمر در اختیار شماست.</p><p>یک بخش قابل آموزش دارد. مثلاً می‌توانید از یک شبکه ساده‌ای مثل U-Net استفاده کنید. یک شبکه‌ای که اونجا اونجایی است که شما می‌توانید چی داشته باشید؟ به عنوان دانشجو و محقق، کوچیک، لوکال، ابتکار داشته باشید، ایده. شرکت‌های بزرگ همه این موضوع‌ها را تغییر می‌دهند. آن‌ها ابزار بزرگی می‌خواهند. ولی شما از ابزارهای اوپن سورس استفاده کنید. این قسمت آموزش دارد اینجا. اینجا هم شما می‌توانید تغییر ایجاد کنید. یا الگوریتم دیگر، یک مدل دیگر استفاده کنید. یا روش‌های مختلفی برای اعمال این تغییرات هست. هر کدام از این‌ها یک حوزه خیلی جدیدی است که خیلی هم تقاضا برایش هست. فعلاً فکر می‌کنم حوزه این GenAI این جنرال اینجینیرها هستند.</p><p>حوزه بصری‌اش خیلی کمتر از حوزه زبان LLMهاست. حوزه زبان LLMها خیلی سرمایه‌گذاری کردند. معمولاً حوزه بصری‌اش کمتر هستش. فقط با یک دونه ترنسفورمر و این‌ها نمی‌توانید. یک معماری دارد که ترنسفورمر بخشی از آن است. این ترنسفورمر اگر از قبل آموزش‌دیده اوپن سورس باشد، مثل چیزی که توی GPT است، یا مثلاً برای تصویر، ResNetها هستش که روی ImageNet آموزش دیده. معمولاً از این‌ها استفاده می‌کنند. و انواع ابزارهای متفرقه که وجود دارد. این‌ها را استفاده می‌کنید، کنار هم می‌گذارید، یک معماری خاصی که حالا بخواهیم خیلی کلی و غیر دقیق اگر بگوییم، چنین به اصطلاح رفتاری دارد.</p><h2>انفجار GenAI و اثر هوش مصنوعی</h2><p>الان متوجه شدید دیگر؟ ماجرای پشت این که یک مدل عکس می‌گیرد، تولید می‌کند چجوری است. خب. ایرادی که داشت این است که شما هیچ ایده‌ای نداشتید. یعنی نویز تولید می‌کردید، یک سری اعداد کوچیک با این اعداد بالا جمع می‌شد، یعنی کم می‌شد، تغییر می‌کرد. خب. این دیتای جدید تولید می‌کرد. هیچ چیزی کنترلی نداشتید و اغلب اوقات تصاویر جالبی هم در نمی‌آمد. مثلاً اگر می‌خواستید تصویر تولید کنید، حالا بعدش فکر کردند چیکار کنیم؟ به عنوان نمونه. یعنی اون نویز و تغییرات تصادفی نباید عکس قبلی ما را به یک عکس جدید تبدیل کند.</p><p>شما یک سری الگو یاد گرفتید. الگو در واقع یک سری عدد است. شما این عددها را یک کوچولو تغییر می‌دهید، ولی نباید خیلی از استیلش خارج بشود. مثلاً فرض کنید که همه چیز را اگر به صورت عدد اگر نمایش بدهید، جاهای خاصی که باید تغییر کند. رندوم این‌ها. نباید مثلاً بک‌گراندش خیلی تغییر کند. چرا؟ چون بک‌گراند خیلی ربطی به اسب بودن ندارد. یعنی همین اسب باشد، ولی دوباره یک عکس دیگر تولید کنید، بک‌گراندش مثلاً آبی باشد. این در مفهوم اسب بودن تغییری ایجاد نکرده. ولی ما باید بدانیم کجاها را. ولی متأسفانه ماشینی که داشتیم، فعلاً با این الگوی ساده نمی‌توانستیم این موضوع را کنترل کنیم که این را هم یواش یواش آمدیم جلوتر تا حلش کردیم. حالا می‌رویم روی اسلایدها.</p><p>GenAI تقریباً یک انفجار بود. آمدن چت جی‌پی‌تی نوامبر ۲۰۲۲، توی اواخر ۲۰۲۲. ۲۰۲۳ و ۲۰۲۴. که باعث انفجارش شد. یعنی ما خودمان هم باعث یک هایپی در ما هم شد. هایپ. با آمدن جی‌پی‌تی سه، جی‌پی‌تی چهار، جی‌پی‌تی فور، و این‌ها دیگه کلاً عادی شد و تقریباً از این به بعد، از جی‌پی‌تی فور به اون ور دیگه دچار AI Effect شد. یعنی انگار دیگه خیلی چیز مهمی نبود. الان مثلاً دیگه برای شما مهم نیست که جی‌پی‌تی پنج خیلی قابلیت‌هایش بیشتر از جی‌پی‌تی فور بود. ببخشید، قبل از ۲۰۲۲ هم ما درس مبانی هوش مصنوعی داشتیم توی دانشگاه. خیلی قدیمی است. علم هوش مصنوعی تعریفش قدیمی‌تر از علم خود کامپیوتر است. ایده هوش از طریق دستگاه‌های غیرارگانیک. خیلی قدیمی است. حالا شما ویدئو را ندیدید. درباره این تاریخچه را با بچه‌های سال بالایی هستش توی کتاب‌ها و داکیومنت‌هاش هست.</p><h3>مدل‌های تولید تصویر</h3><p>این برای تولید متن بود. از اون طرف برای تولید تصویر هم مدل‌هایی هست مثل دال‌ای (DALL-E) ورژن‌های دو، سه، چهار و میدجرنی (Midjourney). میدجرنی اول که آمده بود رایگان هم بود. حالا هنوز به شما کردیت رایگان می‌دهد. ولی اوایل کلاً رایگان بود. چرا؟ چون این شرکت‌ها، استارتاپ‌ها رایگان یک مشتری جذب می‌کنند و بعد پولیش می‌کنند. این استراتژی‌شان است. الان برای تولید متن، GenAI مثلاً می‌آید توکن می‌فرستد. الان می‌بینیم کاملاً. بعد می‌آید بردارش می‌کند. آفرین. اصلاً استایل بعدی همین است. ما ابتدا الان می‌خواهیم به متن بپردازیم. می‌گویم برای همین خیلی از ابهامات شما که دست به گریبان این زیر و بم بودید، احتمالاً به حد زیادی برطرف بشود. اما این چیزهایی که می‌گوییم الفبا هستش. GenAI خیلی درست مثل بقیه کارکردها، برابر با هوش مصنوعی اصلی است.</p><h2>بازنمایی متن (Text Representation)</h2><p>خب. ما توی مبانی هوش مصنوعی، اگر از کلاس‌های قبلی ذهن داشته باشید، ما گفتیم که هر الگوریتم چیکار می‌کرد؟ یک ورودی داریم، یک فضای فرضیه. از اون یک جواب درست برمی‌داشت، اون را وریفای می‌کرد. ما بعد بر اساس این، تسک‌هایی مثل AI Complete را تعریف کردیم، مثل صحبت کردن. گفتیم که یک انسان در طول روز ۳۰۰ تا ۷۰۰ تا کلمه است. یعنی شما در طول روزهای عادی‌تون، حداکثر ۳۰۰ تا کلمه برای بیان خواسته‌هاتون استفاده می‌کنید. زبان‌های دیگر هم همین است. یعنی زبان فارسی، انگلیسی، ۵ میلیون، ۵۰ میلیون کلمه دارد. ولی شما که از همه‌اش استفاده نمی‌کنید. بیشتر اون کلمات در ادبیات و کتاب‌های قدیمی است. شما در طول روز که می‌خواهید با هم صحبت کنید و خواسته‌هاتون را برطرف کنید، فقط از ۳۰۰ تا کلمه استفاده می‌کنید. ولی آیا شما با این ۳۰۰ تا کلمه چند تا خواسته را می‌توانید بیان کنید؟ تقریباً بی‌نهایت خواسته را می‌توانید با این ۳۰۰ تا کلمه بیان کنید.</p><p>نکته این است که تعداد حالاتی که این ۳۰۰ تا کلمه را می‌توانید پشت هم رندوم بچینید، بدون اینکه گرامر و این چیزها را رعایت کنید، چقدر است؟ ۲ به توان ۳۰۰ تا کلمه. خیلی بزرگ است. اگر شما می‌خواستید مثلاً یک خواسته‌تون را بگویید با این ۳۰۰ تا کلمه، درسته؟ اگر هوش نداشتید، احتمالاً برای بیان یک خواسته ساده‌ای مثل این که من آب می‌خواهم، تا ابد باید کلمات این ۳۰۰ تا کلمه را رندوم پشت سر هم می‌چیدید تا اون ترکیب درست در بیاید و مثلاً همکار دوباره متوجه خواسته شما بشود. این ایده اصلاً خوب نباشه.</p><h3>زبان و بازنمایی</h3><p>خب. زبان، این مفهوم هنوز هم خیلی چیز نیست، یک انتزاعی است. خیلی روش بحث است. انتزاعش چیه؟ یک دنیایی دارد، نظریاتی دارد و کاری به آن نداریم. ولی یکی از فن‌های ما هست. ما می‌خواهیم چیکار کنیم؟ می‌خواهیم کلمات را، همین کلمات، خب، کلمات، جملات را رپرزنت کنیم. بازنمودی ازش ایجاد کنیم، بازنمایشی ازش ایجاد کنیم که برای کامپیوتر، درست‌ترش را بگویم، برای الگوریتم‌های یادگیری ماشین، همین معنایی که ما داریم را داشته باشد.</p><p>شما چه رپرزنتیشنی از این کلمات به صورت عددی درست کنید که وقتی آن‌ها را جمله بگویید، عدد بگویید، دوباره همان معانی را داشته باشد. ما دنبال این هستیم.</p><h3>مدل Bag of Words (BoW)</h3><p>اولین تلاش‌ها، ساده‌ترین‌ها، مدلی هست به نام <b>Bag of Words (BoW)</b> یا سبد کلمات. ساده‌ترینش این است که شما وقتی کلمات را دارید، این‌ها دیگر جایگاه خاصی ندارد. اینکه کدام فعل است، اینکه کدام اسم است، اینکه کدام فاعل است، اصلاً این‌ها مهم نیست. هیچ. در هم بر هم است. داخل یک سبد است. ترتیبشان اصلاً مهم نیست. چی برایشان مهم است؟ تکرارشان، فرکانسشان، تعدادشان.</p><h3>مثال BoW</h3><p>فرض کنید که یک جمله‌ای داریم، یک سندی داریم به نام گربه مادر خوابید. متن دوم چیه؟ بچه گربه پرید. شما می‌خواهید یک رپرزنتیشنی که ایجاد کنید بر اساس چیه؟ تعداد تکرارشان. خیلی ساده.</p><h3>توکن‌سازی (Tokenization)</h3><p>اولاً توکن چیست؟ توکن یعنی یک جمله را بشکنید به کوچک‌ترین اجزای دارای معنی. برای چی؟ بسته به کاربرد. یعنی شما می‌توانید جمله را به کلمات توکن‌سازی بکنید، حتی به کاراکترها توکن کنید. هر دوی این‌ها استفاده می‌شود. هر کدام چیز اپلیکیشن‌های خودش را دارد، ولی اغلب شما در سطح کلمات توکن‌سازی می‌کنید. پس توکن را متوجه شدید. کوچک‌ترین واحد اتمی دارای معنی از یک جمله.</p><p>توکن‌ها اینجا چی‌ها هستند؟ کلماتی که این‌ها هستند: گربه هست، مادر هست، خوابید، بچه، پرید. خب. خیلی ساده می‌شماریم. کلمه گربه توی متن اول چند بار پیدا شده؟ یک بار. از مادر؟ یکی. خوابید؟ یکی. و بقیه هم همینطور. توی پایین هم همینطور. توی پایین گربه دو بار تکرار شده، مادر یک بار تکرار شده و و و.</p><p>پس ما آمدیم چیکار کردیم؟ متن یک، برای ما که یک موجود ارگانیک هستیم، از طریق این کلمات معنای مشخصی دارد. گربه مادر خوابید، معنای دیگری ندارد دیگر. یک معنا بیشتر برای ما منتقل نمی‌کند. این را شما به صورت چهار تا، پنج تا عددش می‌کنید. یک، یک، یک، صفر، صفر، صفر. هیچ معنی‌ای ندارد، درسته؟ یک بازنمایش است. ولی به طور شگفت‌انگیزی، به طور شگفت‌انگیزی، تأکید می‌کنم، می‌بینیم که این اعدادی که هیچ معنی‌ای ندارند، وقتی وارد دنیای ریاضیات می‌شوند، تقریباً همین معانی را منتقل می‌کنند. در حالی که شما یک رپرزنتیشن ازش ایجاد می‌کنید، از خود رپرزنتیشن به عنوان یک انسان هیچ تفسیری نمی‌توانید داشته باشید.</p><p>یعنی چی؟ یعنی شما این‌ها را، این بردارهای عددی را اگر ببرید توی فضای مثلاً چهار پنج بعدی، چند بعدی، یک فضا ببرید، رسمشان کنید، می‌بینید که روابط ریاضی برقرار است. مثلاً ملکه مساوی است با زن به اضافه مرد منهای پادشاه، می‌شود ملکه. یعنی ما نمی‌دانیم چرا اینجوری است. ما حدس می‌زنیم که درسته که زبان ما انسان‌ها با اعداد کار نمی‌کند، ولی پشتش، در این تکاملش، در اون ازلی‌اش، یک منطق ریاضی بوده پشتش. همین ریاضی که ما ازش به اصطلاح تلقی که ازش داریم. ما داریم از کلمات استفاده می‌کنیم، درسته؟ ولی منظورمون تهش انگار دارد دوباره همین فرمول‌های ریاضی را استفاده می‌کند. از کجا حدس می‌زنیم این موضوع درست باشد؟ از این که دوباره ما آمدیم این کاراکترها را برگرداندیم به اعداد و بردیم فرمول‌های ریاضی روش انجام دادیم، دیدیم که این جواب می‌دهد. معانی را دارد منتقل می‌کند.</p><h3>روابط معنایی در فضای برداری</h3><p>حالا بین متن اول و متن دوم، اینجا شما به عنوان یک انسان، فقط یک سری عدد می‌بینید که هیچ معنی خاصی برای شما ندارد. ولی اگر ما این‌ها را در فضای سه‌بعدی بخواهیم بکشیم، خب، می‌بینیم که این‌ها یک رابطه معنایی با هم دارند. همین رابطه معنایی که ما به اصطلاح برای ما درست است توی این دنیا. مثلاً فاصله پریدن، فعل پریدن تا زمان سومش پرید، دقیقاً برابر است با فاصله خوابیدن تا خوابید. احتمالاً افعال اینجوری هستند. یا فاصله گربه مادر تا بچه گربه، گربه بچه، خب، دقیقاً برابر است با فاصله مرغ تا جوجه. یعنی رابطه مادری را توانستیم از طریق اعداد بگیریم. رابطه مادری. نه فقط توی حالت حیوان، انسان هم همینطور. یعنی چی؟ جهانی که ما داریم زیست می‌کنیم، انگار پشتش همش ریاضی و عدد است. شما ماتریس را دیدید؟ همه صفر و یکش را می‌دهد. ماتریس را ندیدید؟ برای ما قدیمی است. ماتریس را ببینید. یک فلسفه اینجوری پشتش هست. ماتریس خیلی جلوتر از خودش است. اینقدر که مثلاً دنیا را به دو قسمت تقسیم کرده‌اند: دنیای قبل از ماتریس و دنیای بعد از ماتریس. این فلسفه جدید است.</p><h2>چالش‌های BoW و مدل‌های جدید</h2><p>اگر کسی از شما پرسید رپرزنتیشن چیه، می‌خواهم این را به ذهن شما منتقل کنم. برای یک دیتاسف کوچیک. ولی وقتی شما می‌خواهید یک مدل بزرگ بسازید، معمولاً یک دیکشنری است. دیکشنری انگلیسی. معمولاً. تازه این مدل BoW خیلی قدیمی است. خیلی معانی زیادی هم نمی‌دهد. بسیاری از فرمول‌های ریاضی پاسخ جالبی تولید نمی‌کند. چرا؟ چون ذاتاً بر اساس تکرار بوده. ولی برخی معانی کلی را هنوز هم منتقل می‌کند. سیستم‌های قدیمی از این‌ها استفاده می‌کردند. ما الان مدل‌های خیلی جدیدتری داریم، مثل چی؟ مثل GPT، مثل BERT.</p><p>شما سؤال اولتان این بود که چجوری از اورفیتینگ جلوگیری کنیم؟ هیچ راه‌حلی ندارد. فقط به صورت تجربی. یعنی هر دفعه می‌آییم چیکار می‌کنیم؟ تستش می‌کنیم. با به اصطلاح مقادیر، با آزمایشش. آره. ما یک استاندارد داریم که توی جلسه گذشته هم خودش را اینجا نوشتم. توی کلاس بعدی.</p><h2>فرآیند آموزش مدل‌ها</h2><p>کل روال آموزش مدل‌ها اینجوری است. شما یک مدل پرترین دارید برای یک تعداد اپوک. اپوک یک عدد است. شما یک تعداد توانایی پردازشی دارید. خب. این توانایی پردازش می‌تواند زمان باشد یا مقدار یونیتی که برای پردازش. مثلاً شما اگر از دانشکده می‌خواهید جی‌پی‌یو قرض بگیرید، به شما ساعت‌های خاصی بهتون می‌دهد. یک ساعت، دو ساعت بیشتر بهتون نمی‌دهد. که یک دو ساعت. دو تا، سه تا. مدل‌تون، دیتاتون کوچکتر باشد، اپوک‌ها بیشتر است. ۲۰۰ تا ۳۰۰ اپوک می‌روید. ولی مثلاً مدل‌های گنده‌ای مثل جی‌پی‌تی، من فکر می‌کنم ۱۰-۱۲ تا بیشتر ندارد. اون هم چند ماه طول می‌کشد. مثلاً چندین میلیون، ۴۰-۵۰ میلیون دلار هزینه‌اش می‌شود. برقی که مصرف می‌کنند، یک فارم شما، گرمایی که تولید می‌کنند. خیلی هزینه زا هستش.</p><p>خب. پس یک تعداد منابعی داریم. تکرار می‌دانیم انجام بدهیم. روی چی؟ روی کل، ببخشید، روی این که می‌گوید چجوری اورفیتینگ می‌خواهیم جلوگیری کنیم، چیز استانداردش این است. می‌آید چیکار می‌کند؟ می‌آید اول مدل را می‌گذارد توی حالت یادگیری (Training). خودش را می‌نویسم مدل. بعد می‌آید کل مدل را پرترین می‌کند با دیتای آموزشی. خب. پردیت تا این ترین دیتای ترین. چیکار کن؟ پارادایم یادگیری سه‌تایی یادگیری یادتونه چیکار می‌کرد؟ یک مدلی داشتید دیگر. یک مدلی داشتید. می‌آمد چیکار می‌کرد؟ یک رفتاری را پردیکت می‌کرد. مساوی است با مدل. این دیتا، دیتای این. این دیتا خودش دو تا تیکه داشت دیگر. جفت بود دیگر. جواب، و ورودی و مقدار درستش. مدل می‌کند مثلاً دیتا دات اینپوت و همین مقدار درستش. وزن را اینجا نمی‌نویسم. درستش این است که یک وزن می‌نوشتیم. این‌ها هم زبان کدنویسی است.</p><p>بعد می‌آمدیم چیکار می‌کردیم؟ مقدار لاس را محاسبه می‌کردیم. مقدار خطا. یادتان می‌آید؟ خب. یادتان می‌آید. این را می‌آمدیم چیکار می‌کردیم؟ از طریق یک تابعی، یک پرایتریا، چیکار می‌کردیم؟ جنرالایزش می‌کردیم.</p></div>','completed','2025-11-09 08:13:20','2025-12-03 04:33:26',NULL,NULL,0,NULL,1,NULL),(54,1,1,'کلاس‌های انتزاعی، اینترفیس‌ها و مدیریت حافظه (Stack و Heap)','1404/08/11','<div style=\"max-width: 100%; overflow-x: hidden; word-wrap: break-word; padding: 1rem; box-sizing: border-box;\"><div style=\"max-width: 100%; overflow-x: hidden; word-wrap: break-word; padding: 1rem; box-sizing: border-box;\"><h1>کلاس‌های انتزاعی (Abstract Classes) و اینترفیس‌ها (Interfaces)</h1><p>نکته مهم این است که شما نمی‌توانید از کلاس‌های انتزاعی و اینترفیس‌ها شیء (object) بسازید.</p><h2>چندریختی (Polymorphism)</h2><p>مفهوم چندریختی این بود که شما می‌توانید سمت راست یا سمت ساختن شیء (instantiate کردن شیء) را از کلاس معادل سمت چپ یا رفرنس (reference) یا فرزندان آن انتخاب کنید. هر چیزی که در سمت راست قرار می‌گیرد، یا برابر با سمت چپ است یا فرزند آن، که به نوعی خود آن محسوب می‌شود.</p><h2>تفاوت Stack و Heap در مدیریت حافظه</h2><p>این یک مبحث بسیار مهم است که تفاوت Stack و Heap را بدانید. حافظه به دو بخش اصلی تقسیم می‌شود:</p><ul><li><strong>Stack (پشته):</strong></li><ul><li>استاتیک (static) است.</li><li>برای متغیرهای محلی (local variables) و فراخوانی توابع (function calls) استفاده می‌شود.</li><li>داده‌هایی که به آن وارد می‌شوند، ماندگاری کمتری دارند.</li><li>سریع‌تر است.</li><li>خودکار مدیریت می‌شود (وقتی اسکوپ (scope) یک متغیر تمام می‌شود، خودش پاک می‌شود).</li><li>مقادیر (value types) را ذخیره می‌کند (مانند `int`, `boolean`).</li><li>مستقیماً مقدار متغیر را در حافظه Stack ذخیره می‌کند.</li><li>مدیریت آنی دارد؛ به محض اینکه اسکوپ تمام شود، متغیر پاک می‌شود.</li></ul><li><strong>Heap (پیل):</strong></li><ul><li>دینامیک (dynamic) است.</li><li>برای رفرنس‌ها (reference types) و اشیاء (objects) استفاده می‌شود.</li><li>ماندگاری اطلاعات بیشتری دارد.</li><li>کندتر است.</li><li>خودکار نیست و توسط Garbage Collector (GC) مدیریت می‌شود (در زبان‌هایی مانند C# و Java).</li><li>مقدار حافظه‌ای که در آن ذخیره می‌شود، بیشتر است.</li><li>اشیاء را به صورت \'باکس\' ذخیره می‌کند.</li><li>آدرس شیء در Heap ذخیره می‌شود و یک رفرنس به آن آدرس در Stack قرار می‌گیرد.</li></ul></ul><h3>انواع داده‌ها</h3><p>ما دو نوع داده داریم:</p><ul><li><strong>Value Types:</strong> مانند `int`, `boolean`. این‌ها مستقیماً مقدارشان در حافظه Stack ذخیره می‌شود.</li><li><strong>Reference Types:</strong> مانند `Object` و سایر کلاس‌ها. این‌ها یک رفرنس به یک آدرس در Stack می‌زنند که خود آن آدرس به حافظه Heap اشاره دارد. شیء اصلی در حافظه Heap ذخیره می‌شود.</li></ul><p>این یعنی ذخیره‌سازی اشیاء دو مرحله‌ای است: یک مرحله آدرس شیء در Stack و مرحله دیگر خود شیء در Heap.</p><h3>Garbage Collector (GC)</h3><p>یکی از مهم‌ترین ویژگی‌های زبان جاوا (و C#) داشتن Garbage Collector است. GC می‌آید و اشیائی را که هیچ رفرنسی به آن‌ها در Heap وجود ندارد، حذف می‌کند. این باعث می‌شود که برنامه‌نویس نگران مدیریت دستی حافظه برای اشیاء نباشد. در زبان‌هایی که GC ندارند، شما باید خودتان مدیریت حافظه را انجام دهید و اشیاء بلااستفاده را پاک کنید (مانند `delete` در ++C).</p><h3>ساخت شیء و رفرنس</h3><p>وقتی شما یک شیء می‌سازید، دو بخش دارد:</p><ol><li><strong>بخش رفرنس (سمت چپ):</strong> این بخش مسئول نگهداری آدرس شیء است.</li><li><strong>بخش ساخت شیء (سمت راست):</strong> این بخش شیء را در Heap ایجاد می‌کند و آدرس آن را برمی‌گرداند.</li></ol><p>سمت چپ فقط برای ایجاد رفرنس و ذخیره یک آدرس است و کاری به انتزاعی یا اینترفیس بودن ندارد و خطایی نمی‌دهد. اما به محض اینکه بخواهید از آن شیء بسازید (instantiate کنید)، خطا می‌دهد.</p><h2>مثال عملی: کلاس انتزاعی</h2><p>فرض کنید یک کلاس انتزاعی `A` داریم:</p><pre style=\"white-space: pre-wrap !important; word-wrap: break-word !important; overflow-x: auto !important; max-width: 100% !important; padding: 1rem; background-color: #f5f5f5; border-radius: 4px; direction: ltr; font-family: \'Courier New\', monospace; font-size: 0.9em; line-height: 1.5; margin: 1rem 0;white-space: pre-wrap !important; word-wrap: break-word !important; overflow-x: auto !important; max-width: 100% !important; padding: 1rem; background-color: #f5f5f5; border-radius: 4px; direction: ltr; font-family: \'Courier New\', monospace; font-size: 0.9em; line-height: 1.5; margin: 1rem 0;\"><code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; display: block; overflow-x: auto; font-family: \'Courier New\', monospace;white-space: pre-wrap !important; word-wrap: break-word !important; display: block; overflow-x: auto; font-family: \'Courier New\', monospace;\">abstract class A {\n    public abstract void show();\n}\n</code></pre><p>اگر بخواهیم مستقیماً از `A` شیء بسازیم، خطا می‌گیریم:</p><pre style=\"white-space: pre-wrap !important; word-wrap: break-word !important; overflow-x: auto !important; max-width: 100% !important; padding: 1rem; background-color: #f5f5f5; border-radius: 4px; direction: ltr; font-family: \'Courier New\', monospace; font-size: 0.9em; line-height: 1.5; margin: 1rem 0;white-space: pre-wrap !important; word-wrap: break-word !important; overflow-x: auto !important; max-width: 100% !important; padding: 1rem; background-color: #f5f5f5; border-radius: 4px; direction: ltr; font-family: \'Courier New\', monospace; font-size: 0.9em; line-height: 1.5; margin: 1rem 0;\"><code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; display: block; overflow-x: auto; font-family: \'Courier New\', monospace;white-space: pre-wrap !important; word-wrap: break-word !important; display: block; overflow-x: auto; font-family: \'Courier New\', monospace;\">A obj = new A(); // Error: Cannot instantiate the type A\n</code></pre><p>اما می‌توانیم یک رفرنس از نوع `A` ایجاد کنیم:</p><pre style=\"white-space: pre-wrap !important; word-wrap: break-word !important; overflow-x: auto !important; max-width: 100% !important; padding: 1rem; background-color: #f5f5f5; border-radius: 4px; direction: ltr; font-family: \'Courier New\', monospace; font-size: 0.9em; line-height: 1.5; margin: 1rem 0;white-space: pre-wrap !important; word-wrap: break-word !important; overflow-x: auto !important; max-width: 100% !important; padding: 1rem; background-color: #f5f5f5; border-radius: 4px; direction: ltr; font-family: \'Courier New\', monospace; font-size: 0.9em; line-height: 1.5; margin: 1rem 0;\"><code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; display: block; overflow-x: auto; font-family: \'Courier New\', monospace;white-space: pre-wrap !important; word-wrap: break-word !important; display: block; overflow-x: auto; font-family: \'Courier New\', monospace;\">A obj; // No error\n</code></pre><p>برای استفاده از کلاس انتزاعی `A`، باید یک کلاس دیگر (مثلاً `B`) از آن ارث‌بری کند و متدهای انتزاعی آن را پیاده‌سازی کند:</p><pre style=\"white-space: pre-wrap !important; word-wrap: break-word !important; overflow-x: auto !important; max-width: 100% !important; padding: 1rem; background-color: #f5f5f5; border-radius: 4px; direction: ltr; font-family: \'Courier New\', monospace; font-size: 0.9em; line-height: 1.5; margin: 1rem 0;white-space: pre-wrap !important; word-wrap: break-word !important; overflow-x: auto !important; max-width: 100% !important; padding: 1rem; background-color: #f5f5f5; border-radius: 4px; direction: ltr; font-family: \'Courier New\', monospace; font-size: 0.9em; line-height: 1.5; margin: 1rem 0;\"><code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; display: block; overflow-x: auto; font-family: \'Courier New\', monospace;white-space: pre-wrap !important; word-wrap: break-word !important; display: block; overflow-x: auto; font-family: \'Courier New\', monospace;\">class B extends A {\n    @Override\n    public void show() {\n        // Implementation for show()\n        System.out.println(\"Hello from B\'s show method!\");\n    }\n}\n</code></pre><p>اگر کلاس `B` متد `show()` را پیاده‌سازی نکند، خودش نیز باید انتزاعی باشد. اما اگر آن را پیاده‌سازی کند، دیگر انتزاعی نیست و می‌توان از آن شیء ساخت:</p><pre style=\"white-space: pre-wrap !important; word-wrap: break-word !important; overflow-x: auto !important; max-width: 100% !important; padding: 1rem; background-color: #f5f5f5; border-radius: 4px; direction: ltr; font-family: \'Courier New\', monospace; font-size: 0.9em; line-height: 1.5; margin: 1rem 0;white-space: pre-wrap !important; word-wrap: break-word !important; overflow-x: auto !important; max-width: 100% !important; padding: 1rem; background-color: #f5f5f5; border-radius: 4px; direction: ltr; font-family: \'Courier New\', monospace; font-size: 0.9em; line-height: 1.5; margin: 1rem 0;\"><code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; display: block; overflow-x: auto; font-family: \'Courier New\', monospace;white-space: pre-wrap !important; word-wrap: break-word !important; display: block; overflow-x: auto; font-family: \'Courier New\', monospace;\">B bObj = new B(); // No error\n</code></pre><p><strong>نکات مهم:</strong></p><ul><li>کلاس انتزاعی می‌تواند متدهای عادی (concrete methods) نیز داشته باشد، نه فقط متدهای انتزاعی.</li><li>اینترفیس‌ها فقط می‌توانند متدهای انتزاعی داشته باشند (در نسخه‌های قدیمی‌تر جاوا).</li><li>در یک فایل جاوا، فقط یک کلاس می‌تواند `public` باشد.</li><li>اگر در یک کلاس، کانستراکتور (constructor) تعریف نکنید، همیشه یک کانستراکتور پیش‌فرض (default constructor) بدون پارامتر و بدون پیاده‌سازی وجود دارد.</li></ul><p>در برنامه‌نویسی مدرن، حتماً باید بر مفاهیم Stack و Heap تسلط داشته باشید.</p></div></div>','<h1>کلاس‌های انتزاعی (Abstract Classes) و اینترفیس‌ها (Interfaces)</h1><p>نکته مهم این است که شما نمی‌توانید از کلاس‌های انتزاعی و اینترفیس‌ها شیء (object) بسازید.</p><h2>چندریختی (Polymorphism)</h2><p>مفهوم چندریختی این بود که شما می‌توانید سمت راست یا سمت ساختن شیء (instantiate کردن شیء) را از کلاس معادل سمت چپ یا رفرنس (reference) یا فرزندان آن انتخاب کنید. هر چیزی که در سمت راست قرار می‌گیرد، یا برابر با سمت چپ است یا فرزند آن، که به نوعی خود آن محسوب می‌شود.</p><h2>تفاوت Stack و Heap در مدیریت حافظه</h2><p>این یک مبحث بسیار مهم است که تفاوت Stack و Heap را بدانید. حافظه به دو بخش اصلی تقسیم می‌شود:</p><ul><li><strong>Stack (پشته):</strong></li><li class=\"ql-indent-1\">استاتیک (static) است.</li><li class=\"ql-indent-1\">برای متغیرهای محلی (local variables) و فراخوانی توابع (function calls) استفاده می‌شود.</li><li class=\"ql-indent-1\">داده‌هایی که به آن وارد می‌شوند، ماندگاری کمتری دارند.</li><li class=\"ql-indent-1\">سریع‌تر است.</li><li class=\"ql-indent-1\">خودکار مدیریت می‌شود (وقتی اسکوپ (scope) یک متغیر تمام می‌شود، خودش پاک می‌شود).</li><li class=\"ql-indent-1\">مقادیر (value types) را ذخیره می‌کند (مانند `int`, `boolean`).</li><li class=\"ql-indent-1\">مستقیماً مقدار متغیر را در حافظه Stack ذخیره می‌کند.</li><li class=\"ql-indent-1\">مدیریت آنی دارد؛ به محض اینکه اسکوپ تمام شود، متغیر پاک می‌شود.</li><li><strong>Heap (پیل):</strong></li><li class=\"ql-indent-1\">دینامیک (dynamic) است.</li><li class=\"ql-indent-1\">برای رفرنس‌ها (reference types) و اشیاء (objects) استفاده می‌شود.</li><li class=\"ql-indent-1\">ماندگاری اطلاعات بیشتری دارد.</li><li class=\"ql-indent-1\">کندتر است.</li><li class=\"ql-indent-1\">خودکار نیست و توسط Garbage Collector (GC) مدیریت می‌شود (در زبان‌هایی مانند C# و Java).</li><li class=\"ql-indent-1\">مقدار حافظه‌ای که در آن ذخیره می‌شود، بیشتر است.</li><li class=\"ql-indent-1\">اشیاء را به صورت \'باکس\' ذخیره می‌کند.</li><li class=\"ql-indent-1\">آدرس شیء در Heap ذخیره می‌شود و یک رفرنس به آن آدرس در Stack قرار می‌گیرد.</li></ul><h3>انواع داده‌ها</h3><p>ما دو نوع داده داریم:</p><ul><li><strong>Value Types:</strong> مانند `int`, `boolean`. این‌ها مستقیماً مقدارشان در حافظه Stack ذخیره می‌شود.</li><li><strong>Reference Types:</strong> مانند `Object` و سایر کلاس‌ها. این‌ها یک رفرنس به یک آدرس در Stack می‌زنند که خود آن آدرس به حافظه Heap اشاره دارد. شیء اصلی در حافظه Heap ذخیره می‌شود.</li></ul><p>این یعنی ذخیره‌سازی اشیاء دو مرحله‌ای است: یک مرحله آدرس شیء در Stack و مرحله دیگر خود شیء در Heap.</p><h3>Garbage Collector (GC)</h3><p>یکی از مهم‌ترین ویژگی‌های زبان جاوا (و C#) داشتن Garbage Collector است. GC می‌آید و اشیائی را که هیچ رفرنسی به آن‌ها در Heap وجود ندارد، حذف می‌کند. این باعث می‌شود که برنامه‌نویس نگران مدیریت دستی حافظه برای اشیاء نباشد. در زبان‌هایی که GC ندارند، شما باید خودتان مدیریت حافظه را انجام دهید و اشیاء بلااستفاده را پاک کنید (مانند `delete` در ++C).</p><h3>ساخت شیء و رفرنس</h3><p>وقتی شما یک شیء می‌سازید، دو بخش دارد:</p><ol><li><strong>بخش رفرنس (سمت چپ):</strong> این بخش مسئول نگهداری آدرس شیء است.</li><li><strong>بخش ساخت شیء (سمت راست):</strong> این بخش شیء را در Heap ایجاد می‌کند و آدرس آن را برمی‌گرداند.</li></ol><p>سمت چپ فقط برای ایجاد رفرنس و ذخیره یک آدرس است و کاری به انتزاعی یا اینترفیس بودن ندارد و خطایی نمی‌دهد. اما به محض اینکه بخواهید از آن شیء بسازید (instantiate کنید)، خطا می‌دهد.</p><h2>مثال عملی: کلاس انتزاعی</h2><p>فرض کنید یک کلاس انتزاعی `A` داریم:</p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">abstract class A {\n    public abstract void show();\n}\n</pre><p>اگر بخواهیم مستقیماً از `A` شیء بسازیم، خطا می‌گیریم:</p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">A obj = new A(); // Error: Cannot instantiate the type A\n</pre><p>اما می‌توانیم یک رفرنس از نوع `A` ایجاد کنیم:</p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">A obj; // No error\n</pre><p>برای استفاده از کلاس انتزاعی `A`، باید یک کلاس دیگر (مثلاً `B`) از آن ارث‌بری کند و متدهای انتزاعی آن را پیاده‌سازی کند:</p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">class B extends A {\n    @Override\n    public void show() {\n        // Implementation for show()\n        System.out.println(\"Hello from B\'s show method!\");\n    }\n}\n</pre><p>اگر کلاس `B` متد `show()` را پیاده‌سازی نکند، خودش نیز باید انتزاعی باشد. اما اگر آن را پیاده‌سازی کند، دیگر انتزاعی نیست و می‌توان از آن شیء ساخت:</p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">B bObj = new B(); // No error\n</pre><p><strong>نکات مهم:</strong></p><ul><li>کلاس انتزاعی می‌تواند متدهای عادی (concrete methods) نیز داشته باشد، نه فقط متدهای انتزاعی.</li><li>اینترفیس‌ها فقط می‌توانند متدهای انتزاعی داشته باشند (در نسخه‌های قدیمی‌تر جاوا).</li><li>در یک فایل جاوا، فقط یک کلاس می‌تواند `public` باشد.</li><li>اگر در یک کلاس، کانستراکتور (constructor) تعریف نکنید، همیشه یک کانستراکتور پیش‌فرض (default constructor) بدون پارامتر و بدون پیاده‌سازی وجود دارد.</li></ul><p>در برنامه‌نویسی مدرن، حتماً باید بر مفاهیم Stack و Heap تسلط داشته باشید.</p>','completed','2025-11-09 08:20:53','2025-12-03 04:33:26',NULL,NULL,0,NULL,1,NULL),(55,2,1,'_Khone Barat Ridan','1404/09/01',NULL,NULL,'failed','2025-11-15 15:20:29','2025-11-15 15:20:30','خطای غیرمنتظره در پردازش فایل: FileTooLargeError. لطفاً با پشتیبانی تماس بگیرید.','FileTooLargeError: حجم فایل بیش از حد مجاز است\n\nTraceback (most recent call last):\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/app/services/ai_service.py\", line 136, in process_files_with_gemini\n    uploaded_file = genai.upload_file(path=file_path)\n                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/google/generativeai/files.py\", line 85, in upload_file\n    response = client.create_file(\n               ^^^^^^^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/google/generativeai/client.py\", line 103, in create_file\n    self._setup_discovery_api(metadata)\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/google/generativeai/client.py\", line 84, in _setup_discovery_api\n    response, content = request.execute()\n                        ^^^^^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/googleapiclient/_helpers.py\", line 130, in positional_wrapper\n    return wrapped(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/googleapiclient/http.py\", line 938, in execute\n    raise HttpError(resp, content, uri=self.uri)\ngoogleapiclient.errors.HttpError: <HttpError 403 when requesting https://generativelanguage.googleapis.com/$discovery/rest?version=v1beta&key=AIzaSyCL0mzHe7y_v9BNjglJfrTl4fRtCQ_i9hQ returned \"Forbidden\". Details: \"<!DOCTYPE html>\n<html lang=en>\n  <meta charset=utf-8>\n  <meta name=viewport content=\"initial-scale=1, minimum-scale=1, width=device-width\">\n  <title>Error 403 (Forbidden)!!1</title>\n  <style>\n    *{margin:0;padding:0}html,code{font:15px/22px arial,sans-serif}html{background:#fff;color:#222;padding:15px}body{margin:7% auto 0;max-width:390px;min-height:180px;padding:30px 0 15px}* > body{background:url(//www.google.com/images/errors/robot.png) 100% 5px no-repeat;padding-right:205px}p{margin:11px 0 22px;overflow:hidden}ins{color:#777;text-decoration:none}a img{border:0}@media screen and (max-width:772px){body{background:none;margin-top:0;max-width:none;padding-right:0}}#logo{background:url(//www.google.com/images/branding/googlelogo/1x/googlelogo_color_150x54dp.png) no-repeat;margin-left:-5px}@media only screen and (min-resolution:192dpi){#logo{background:url(//www.google.com/images/branding/googlelogo/2x/googlelogo_color_150x54dp.png) no-repeat 0% 0%/100% 100%;-moz-border-image:url(//www.google.com/images/branding/googlelogo/2x/googlelogo_color_150x54dp.png) 0}}@media only screen and (-webkit-min-device-pixel-ratio:2){#logo{background:url(//www.google.com/images/branding/googlelogo/2x/googlelogo_color_150x54dp.png) no-repeat;-webkit-background-size:100% 100%}}#logo{display:inline-block;height:54px;width:150px}\n  </style>\n  <a href=//www.google.com/><span id=logo aria-label=Google></span></a>\n  <p><b>403.</b> <ins>That’s an error.</ins>\n  <p>Your client does not have permission to get URL <code>/$discovery/rest</code> from this server.  <ins>That’s all we know.</ins>\n\">\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/app/worker/tasks_with_credits_fixed.py\", line 119, in run_processing\n    gemini_output = await process_files_with_gemini(file_paths)\n                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/app/services/ai_service.py\", line 151, in process_files_with_gemini\n    raise FileTooLargeError()\napp.services.exceptions.FileTooLargeError: حجم فایل بیش از حد مجاز است\n',0,'2025-11-15 15:20:31',1,'unknown_error'),(56,2,1,'_Khone Barat Ridan','1404/08/05',NULL,NULL,'failed','2025-11-15 15:30:17','2025-11-15 15:30:27','خطای غیرمنتظره در پردازش فایل: FileTooLargeError. لطفاً با پشتیبانی تماس بگیرید.','FileTooLargeError: حجم فایل بیش از حد مجاز است\n\nTraceback (most recent call last):\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/app/services/ai_service.py\", line 136, in process_files_with_gemini\n    uploaded_file = genai.upload_file(path=file_path)\n                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/google/generativeai/files.py\", line 85, in upload_file\n    response = client.create_file(\n               ^^^^^^^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/google/generativeai/client.py\", line 103, in create_file\n    self._setup_discovery_api(metadata)\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/google/generativeai/client.py\", line 84, in _setup_discovery_api\n    response, content = request.execute()\n                        ^^^^^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/googleapiclient/_helpers.py\", line 130, in positional_wrapper\n    return wrapped(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/googleapiclient/http.py\", line 938, in execute\n    raise HttpError(resp, content, uri=self.uri)\ngoogleapiclient.errors.HttpError: <HttpError 403 when requesting https://generativelanguage.googleapis.com/$discovery/rest?version=v1beta&key=AIzaSyCL0mzHe7y_v9BNjglJfrTl4fRtCQ_i9hQ returned \"Forbidden\". Details: \"<!DOCTYPE html>\n<html lang=en>\n  <meta charset=utf-8>\n  <meta name=viewport content=\"initial-scale=1, minimum-scale=1, width=device-width\">\n  <title>Error 403 (Forbidden)!!1</title>\n  <style>\n    *{margin:0;padding:0}html,code{font:15px/22px arial,sans-serif}html{background:#fff;color:#222;padding:15px}body{margin:7% auto 0;max-width:390px;min-height:180px;padding:30px 0 15px}* > body{background:url(//www.google.com/images/errors/robot.png) 100% 5px no-repeat;padding-right:205px}p{margin:11px 0 22px;overflow:hidden}ins{color:#777;text-decoration:none}a img{border:0}@media screen and (max-width:772px){body{background:none;margin-top:0;max-width:none;padding-right:0}}#logo{background:url(//www.google.com/images/branding/googlelogo/1x/googlelogo_color_150x54dp.png) no-repeat;margin-left:-5px}@media only screen and (min-resolution:192dpi){#logo{background:url(//www.google.com/images/branding/googlelogo/2x/googlelogo_color_150x54dp.png) no-repeat 0% 0%/100% 100%;-moz-border-image:url(//www.google.com/images/branding/googlelogo/2x/googlelogo_color_150x54dp.png) 0}}@media only screen and (-webkit-min-device-pixel-ratio:2){#logo{background:url(//www.google.com/images/branding/googlelogo/2x/googlelogo_color_150x54dp.png) no-repeat;-webkit-background-size:100% 100%}}#logo{display:inline-block;height:54px;width:150px}\n  </style>\n  <a href=//www.google.com/><span id=logo aria-label=Google></span></a>\n  <p><b>403.</b> <ins>That’s an error.</ins>\n  <p>Your client does not have permission to get URL <code>/$discovery/rest</code> from this server.  <ins>That’s all we know.</ins>\n\">\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/app/worker/tasks_with_credits_fixed.py\", line 119, in run_processing\n    gemini_output = await process_files_with_gemini(file_paths)\n                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/app/services/ai_service.py\", line 151, in process_files_with_gemini\n    raise FileTooLargeError()\napp.services.exceptions.FileTooLargeError: حجم فایل بیش از حد مجاز است\n',0,'2025-11-15 15:30:28',1,'unknown_error'),(57,7,1,'_⁨داده کاوی⁩','1404/09/09',NULL,NULL,'failed','2025-12-01 18:52:27','2025-12-01 18:52:29','خطای غیرمنتظره در پردازش فایل: FileTooLargeError. لطفاً با پشتیبانی تماس بگیرید.','FileTooLargeError: حجم فایل بیش از حد مجاز است\n\nTraceback (most recent call last):\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/app/services/ai_service.py\", line 142, in process_files_with_gemini\n    uploaded_file = genai.upload_file(path=file_path)\n                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/google/generativeai/files.py\", line 85, in upload_file\n    response = client.create_file(\n               ^^^^^^^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/google/generativeai/client.py\", line 103, in create_file\n    self._setup_discovery_api(metadata)\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/google/generativeai/client.py\", line 84, in _setup_discovery_api\n    response, content = request.execute()\n                        ^^^^^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/googleapiclient/_helpers.py\", line 130, in positional_wrapper\n    return wrapped(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/googleapiclient/http.py\", line 938, in execute\n    raise HttpError(resp, content, uri=self.uri)\ngoogleapiclient.errors.HttpError: <HttpError 403 when requesting https://generativelanguage.googleapis.com/$discovery/rest?version=v1beta&key=social returned \"Forbidden\". Details: \"<!DOCTYPE html>\n<html lang=en>\n  <meta charset=utf-8>\n  <meta name=viewport content=\"initial-scale=1, minimum-scale=1, width=device-width\">\n  <title>Error 403 (Forbidden)!!1</title>\n  <style>\n    *{margin:0;padding:0}html,code{font:15px/22px arial,sans-serif}html{background:#fff;color:#222;padding:15px}body{margin:7% auto 0;max-width:390px;min-height:180px;padding:30px 0 15px}* > body{background:url(//www.google.com/images/errors/robot.png) 100% 5px no-repeat;padding-right:205px}p{margin:11px 0 22px;overflow:hidden}ins{color:#777;text-decoration:none}a img{border:0}@media screen and (max-width:772px){body{background:none;margin-top:0;max-width:none;padding-right:0}}#logo{background:url(//www.google.com/images/branding/googlelogo/1x/googlelogo_color_150x54dp.png) no-repeat;margin-left:-5px}@media only screen and (min-resolution:192dpi){#logo{background:url(//www.google.com/images/branding/googlelogo/2x/googlelogo_color_150x54dp.png) no-repeat 0% 0%/100% 100%;-moz-border-image:url(//www.google.com/images/branding/googlelogo/2x/googlelogo_color_150x54dp.png) 0}}@media only screen and (-webkit-min-device-pixel-ratio:2){#logo{background:url(//www.google.com/images/branding/googlelogo/2x/googlelogo_color_150x54dp.png) no-repeat;-webkit-background-size:100% 100%}}#logo{display:inline-block;height:54px;width:150px}\n  </style>\n  <a href=//www.google.com/><span id=logo aria-label=Google></span></a>\n  <p><b>403.</b> <ins>That’s an error.</ins>\n  <p>Your client does not have permission to get URL <code>/$discovery/rest</code> from this server.  <ins>That’s all we know.</ins>\n\">\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/app/worker/tasks_with_credits_fixed.py\", line 119, in run_processing\n    gemini_output = await process_files_with_gemini(file_paths)\n                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/app/services/ai_service.py\", line 157, in process_files_with_gemini\n    raise FileTooLargeError()\napp.services.exceptions.FileTooLargeError: حجم فایل بیش از حد مجاز است\n',0,'2025-12-01 18:52:30',1,'unknown_error'),(58,7,1,'_⁨داده کاوی⁩','1404/09/11',NULL,NULL,'failed','2025-12-01 18:54:01','2025-12-01 18:54:02','خطای غیرمنتظره در پردازش فایل: FileTooLargeError. لطفاً با پشتیبانی تماس بگیرید.','FileTooLargeError: حجم فایل بیش از حد مجاز است\n\nTraceback (most recent call last):\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/app/services/ai_service.py\", line 142, in process_files_with_gemini\n    uploaded_file = genai.upload_file(path=file_path)\n                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/google/generativeai/files.py\", line 85, in upload_file\n    response = client.create_file(\n               ^^^^^^^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/google/generativeai/client.py\", line 103, in create_file\n    self._setup_discovery_api(metadata)\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/google/generativeai/client.py\", line 84, in _setup_discovery_api\n    response, content = request.execute()\n                        ^^^^^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/googleapiclient/_helpers.py\", line 130, in positional_wrapper\n    return wrapped(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/googleapiclient/http.py\", line 938, in execute\n    raise HttpError(resp, content, uri=self.uri)\ngoogleapiclient.errors.HttpError: <HttpError 403 when requesting https://generativelanguage.googleapis.com/$discovery/rest?version=v1beta&key=social returned \"Forbidden\". Details: \"<!DOCTYPE html>\n<html lang=en>\n  <meta charset=utf-8>\n  <meta name=viewport content=\"initial-scale=1, minimum-scale=1, width=device-width\">\n  <title>Error 403 (Forbidden)!!1</title>\n  <style>\n    *{margin:0;padding:0}html,code{font:15px/22px arial,sans-serif}html{background:#fff;color:#222;padding:15px}body{margin:7% auto 0;max-width:390px;min-height:180px;padding:30px 0 15px}* > body{background:url(//www.google.com/images/errors/robot.png) 100% 5px no-repeat;padding-right:205px}p{margin:11px 0 22px;overflow:hidden}ins{color:#777;text-decoration:none}a img{border:0}@media screen and (max-width:772px){body{background:none;margin-top:0;max-width:none;padding-right:0}}#logo{background:url(//www.google.com/images/branding/googlelogo/1x/googlelogo_color_150x54dp.png) no-repeat;margin-left:-5px}@media only screen and (min-resolution:192dpi){#logo{background:url(//www.google.com/images/branding/googlelogo/2x/googlelogo_color_150x54dp.png) no-repeat 0% 0%/100% 100%;-moz-border-image:url(//www.google.com/images/branding/googlelogo/2x/googlelogo_color_150x54dp.png) 0}}@media only screen and (-webkit-min-device-pixel-ratio:2){#logo{background:url(//www.google.com/images/branding/googlelogo/2x/googlelogo_color_150x54dp.png) no-repeat;-webkit-background-size:100% 100%}}#logo{display:inline-block;height:54px;width:150px}\n  </style>\n  <a href=//www.google.com/><span id=logo aria-label=Google></span></a>\n  <p><b>403.</b> <ins>That’s an error.</ins>\n  <p>Your client does not have permission to get URL <code>/$discovery/rest</code> from this server.  <ins>That’s all we know.</ins>\n\">\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/app/worker/tasks_with_credits_fixed.py\", line 119, in run_processing\n    gemini_output = await process_files_with_gemini(file_paths)\n                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/app/services/ai_service.py\", line 157, in process_files_with_gemini\n    raise FileTooLargeError()\napp.services.exceptions.FileTooLargeError: حجم فایل بیش از حد مجاز است\n',0,'2025-12-01 18:54:02',1,'unknown_error'),(59,7,1,'_⁨داده کاوی⁩',NULL,NULL,NULL,'failed','2025-12-01 18:55:03','2025-12-01 18:55:09','خطای غیرمنتظره در پردازش فایل: FileTooLargeError. لطفاً با پشتیبانی تماس بگیرید.','FileTooLargeError: حجم فایل بیش از حد مجاز است\n\nTraceback (most recent call last):\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/app/services/ai_service.py\", line 142, in process_files_with_gemini\n    uploaded_file = genai.upload_file(path=file_path)\n                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/google/generativeai/files.py\", line 85, in upload_file\n    response = client.create_file(\n               ^^^^^^^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/google/generativeai/client.py\", line 103, in create_file\n    self._setup_discovery_api(metadata)\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/google/generativeai/client.py\", line 84, in _setup_discovery_api\n    response, content = request.execute()\n                        ^^^^^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/googleapiclient/_helpers.py\", line 130, in positional_wrapper\n    return wrapped(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/googleapiclient/http.py\", line 938, in execute\n    raise HttpError(resp, content, uri=self.uri)\ngoogleapiclient.errors.HttpError: <HttpError 403 when requesting https://generativelanguage.googleapis.com/$discovery/rest?version=v1beta&key=AIzaSyCL0mzHe7y_v9BNjglJfrTl4fRtCQ_i9hQ returned \"Forbidden\". Details: \"<!DOCTYPE html>\n<html lang=en>\n  <meta charset=utf-8>\n  <meta name=viewport content=\"initial-scale=1, minimum-scale=1, width=device-width\">\n  <title>Error 403 (Forbidden)!!1</title>\n  <style>\n    *{margin:0;padding:0}html,code{font:15px/22px arial,sans-serif}html{background:#fff;color:#222;padding:15px}body{margin:7% auto 0;max-width:390px;min-height:180px;padding:30px 0 15px}* > body{background:url(//www.google.com/images/errors/robot.png) 100% 5px no-repeat;padding-right:205px}p{margin:11px 0 22px;overflow:hidden}ins{color:#777;text-decoration:none}a img{border:0}@media screen and (max-width:772px){body{background:none;margin-top:0;max-width:none;padding-right:0}}#logo{background:url(//www.google.com/images/branding/googlelogo/1x/googlelogo_color_150x54dp.png) no-repeat;margin-left:-5px}@media only screen and (min-resolution:192dpi){#logo{background:url(//www.google.com/images/branding/googlelogo/2x/googlelogo_color_150x54dp.png) no-repeat 0% 0%/100% 100%;-moz-border-image:url(//www.google.com/images/branding/googlelogo/2x/googlelogo_color_150x54dp.png) 0}}@media only screen and (-webkit-min-device-pixel-ratio:2){#logo{background:url(//www.google.com/images/branding/googlelogo/2x/googlelogo_color_150x54dp.png) no-repeat;-webkit-background-size:100% 100%}}#logo{display:inline-block;height:54px;width:150px}\n  </style>\n  <a href=//www.google.com/><span id=logo aria-label=Google></span></a>\n  <p><b>403.</b> <ins>That’s an error.</ins>\n  <p>Your client does not have permission to get URL <code>/$discovery/rest</code> from this server.  <ins>That’s all we know.</ins>\n\">\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/app/worker/tasks_with_credits_fixed.py\", line 119, in run_processing\n    gemini_output = await process_files_with_gemini(file_paths)\n                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/app/services/ai_service.py\", line 157, in process_files_with_gemini\n    raise FileTooLargeError()\napp.services.exceptions.FileTooLargeError: حجم فایل بیش از حد مجاز است\n',0,'2025-12-01 18:55:10',1,'unknown_error'),(60,7,1,'_⁨داده کاوی⁩',NULL,NULL,NULL,'failed','2025-12-01 18:56:13','2025-12-01 18:56:15','خطای غیرمنتظره در پردازش فایل: FileTooLargeError. لطفاً با پشتیبانی تماس بگیرید.','FileTooLargeError: حجم فایل بیش از حد مجاز است\n\nTraceback (most recent call last):\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/app/services/ai_service.py\", line 142, in process_files_with_gemini\n    uploaded_file = genai.upload_file(path=file_path)\n                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/google/generativeai/files.py\", line 85, in upload_file\n    response = client.create_file(\n               ^^^^^^^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/google/generativeai/client.py\", line 103, in create_file\n    self._setup_discovery_api(metadata)\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/google/generativeai/client.py\", line 84, in _setup_discovery_api\n    response, content = request.execute()\n                        ^^^^^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/googleapiclient/_helpers.py\", line 130, in positional_wrapper\n    return wrapped(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/googleapiclient/http.py\", line 938, in execute\n    raise HttpError(resp, content, uri=self.uri)\ngoogleapiclient.errors.HttpError: <HttpError 403 when requesting https://generativelanguage.googleapis.com/$discovery/rest?version=v1beta&key=social returned \"Forbidden\". Details: \"<!DOCTYPE html>\n<html lang=en>\n  <meta charset=utf-8>\n  <meta name=viewport content=\"initial-scale=1, minimum-scale=1, width=device-width\">\n  <title>Error 403 (Forbidden)!!1</title>\n  <style>\n    *{margin:0;padding:0}html,code{font:15px/22px arial,sans-serif}html{background:#fff;color:#222;padding:15px}body{margin:7% auto 0;max-width:390px;min-height:180px;padding:30px 0 15px}* > body{background:url(//www.google.com/images/errors/robot.png) 100% 5px no-repeat;padding-right:205px}p{margin:11px 0 22px;overflow:hidden}ins{color:#777;text-decoration:none}a img{border:0}@media screen and (max-width:772px){body{background:none;margin-top:0;max-width:none;padding-right:0}}#logo{background:url(//www.google.com/images/branding/googlelogo/1x/googlelogo_color_150x54dp.png) no-repeat;margin-left:-5px}@media only screen and (min-resolution:192dpi){#logo{background:url(//www.google.com/images/branding/googlelogo/2x/googlelogo_color_150x54dp.png) no-repeat 0% 0%/100% 100%;-moz-border-image:url(//www.google.com/images/branding/googlelogo/2x/googlelogo_color_150x54dp.png) 0}}@media only screen and (-webkit-min-device-pixel-ratio:2){#logo{background:url(//www.google.com/images/branding/googlelogo/2x/googlelogo_color_150x54dp.png) no-repeat;-webkit-background-size:100% 100%}}#logo{display:inline-block;height:54px;width:150px}\n  </style>\n  <a href=//www.google.com/><span id=logo aria-label=Google></span></a>\n  <p><b>403.</b> <ins>That’s an error.</ins>\n  <p>Your client does not have permission to get URL <code>/$discovery/rest</code> from this server.  <ins>That’s all we know.</ins>\n\">\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/app/worker/tasks_with_credits_fixed.py\", line 119, in run_processing\n    gemini_output = await process_files_with_gemini(file_paths)\n                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/app/services/ai_service.py\", line 157, in process_files_with_gemini\n    raise FileTooLargeError()\napp.services.exceptions.FileTooLargeError: حجم فایل بیش از حد مجاز است\n',0,'2025-12-01 18:56:15',1,'unknown_error'),(61,7,1,'_⁨داده کاوی⁩',NULL,NULL,NULL,'failed','2025-12-01 19:04:56','2025-12-01 19:04:59','خطای غیرمنتظره در پردازش فایل: InvalidFormatError. لطفاً با پشتیبانی تماس بگیرید.','InvalidFormatError: فرمت فایل نامعتبر است\n\nTraceback (most recent call last):\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/app/services/ai_service.py\", line 142, in process_files_with_gemini\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/google/generativeai/files.py\", line 85, in upload_file\n    response = client.create_file(\n               ^^^^^^^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/google/generativeai/client.py\", line 103, in create_file\n    self._setup_discovery_api(metadata)\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/google/generativeai/client.py\", line 84, in _setup_discovery_api\n    response, content = request.execute()\n                        ^^^^^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/googleapiclient/_helpers.py\", line 130, in positional_wrapper\n    return wrapped(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/googleapiclient/http.py\", line 938, in execute\n    raise HttpError(resp, content, uri=self.uri)\ngoogleapiclient.errors.HttpError: <HttpError 400 when requesting https://generativelanguage.googleapis.com/$discovery/rest?version=v1beta&key=social returned \"API key not valid. Please pass a valid API key.\". Details: \"[{\'@type\': \'type.googleapis.com/google.rpc.ErrorInfo\', \'reason\': \'API_KEY_INVALID\', \'domain\': \'googleapis.com\', \'metadata\': {\'service\': \'generativelanguage.googleapis.com\'}}, {\'@type\': \'type.googleapis.com/google.rpc.LocalizedMessage\', \'locale\': \'en-US\', \'message\': \'API key not valid. Please pass a valid API key.\'}]\">\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/app/worker/tasks_with_credits_fixed.py\", line 119, in run_processing\n    gemini_output = await process_files_with_gemini(file_paths)\n                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/app/services/ai_service.py\", line 153, in process_files_with_gemini\n    raise UnknownAIError(f\"خطا در آپلود فایل: {str(upload_error)}\")\n    ^^^^^^^^^^^^^^^^^^^^^^^^^\napp.services.exceptions.InvalidFormatError: فرمت فایل نامعتبر است\n',0,'2025-12-01 19:05:00',1,'unknown_error'),(62,7,1,'_⁨داده کاوی⁩',NULL,NULL,NULL,'failed','2025-12-01 19:06:17','2025-12-01 19:06:19','خطای غیرمنتظره در پردازش فایل: InvalidFormatError. لطفاً با پشتیبانی تماس بگیرید.','InvalidFormatError: فرمت فایل نامعتبر است\n\nTraceback (most recent call last):\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/app/services/ai_service.py\", line 142, in process_files_with_gemini\n    print(f\"[GEMINI]   ✓ File {i} uploaded: {uploaded_file.name}\")\n                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/google/generativeai/files.py\", line 85, in upload_file\n    response = client.create_file(\n               ^^^^^^^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/google/generativeai/client.py\", line 103, in create_file\n    self._setup_discovery_api(metadata)\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/google/generativeai/client.py\", line 84, in _setup_discovery_api\n    response, content = request.execute()\n                        ^^^^^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/googleapiclient/_helpers.py\", line 130, in positional_wrapper\n    return wrapped(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/googleapiclient/http.py\", line 938, in execute\n    raise HttpError(resp, content, uri=self.uri)\ngoogleapiclient.errors.HttpError: <HttpError 400 when requesting https://generativelanguage.googleapis.com/$discovery/rest?version=v1beta&key=social returned \"API key not valid. Please pass a valid API key.\". Details: \"[{\'@type\': \'type.googleapis.com/google.rpc.ErrorInfo\', \'reason\': \'API_KEY_INVALID\', \'domain\': \'googleapis.com\', \'metadata\': {\'service\': \'generativelanguage.googleapis.com\'}}, {\'@type\': \'type.googleapis.com/google.rpc.LocalizedMessage\', \'locale\': \'en-US\', \'message\': \'API key not valid. Please pass a valid API key.\'}]\">\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/app/worker/tasks_with_credits_fixed.py\", line 119, in run_processing\n    gemini_output = await process_files_with_gemini(file_paths)\n                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/app/services/ai_service.py\", line 153, in process_files_with_gemini\n    raise NetworkError()\napp.services.exceptions.InvalidFormatError: فرمت فایل نامعتبر است\n',0,'2025-12-01 19:06:19',1,'unknown_error'),(63,7,1,'نمایش داده‌ها، انواع داده‌ها و منابع داده',NULL,'<div style=\"max-width: 100%; overflow-x: hidden; word-wrap: break-word; padding: 1rem; box-sizing: border-box;\"><div style=\"max-width: 100%; overflow-x: hidden; word-wrap: break-word; padding: 1rem; box-sizing: border-box;\"><h1>نمایش داده‌ها در گراف‌ها</h1><h2>ماتریس همسایگی (Adjacency Matrix)</h2><ul><li>یک ماتریس همسایگی است.</li><li>بسیار پراکنده (sparse) و پرمصرف (wasteful) از نظر فضا، اما از نظر مفهومی مفید است.</li><li>عناصر آن معمولاً ۰ یا ۱ هستند.</li><li>در وب مپ‌ها نیز به همین صورت استفاده می‌شود.</li><li>در محاسبات، ماتریس همسایگی کمک می‌کند.</li><li>برای ماتریس‌های متراکم (dense) که تعداد صفرها زیاد نیست، بهتر است.</li><li>اگر ابعاد ماتریس بالا برود (مثلاً ۲ میلیارد در ۲ میلیارد برای شبکه‌های اجتماعی مانند توییتر)، بسیار بزرگ می‌شود و محاسبات پیچیده می‌گردد.</li></ul><h2>لیست همسایگی (Adjacency List)</h2><ul><li>نمایش مجموعه داده به شکل گراف به صورت لیست همسایگی.</li><li>هر گره (node) لیستی از گره‌هایی که همسایه‌اش هستند، دارد.</li><li>مثال: گره ۱ با گره ۲ و ۳ ارتباط دارد. گره ۲ با گره ۱ و ۳ ارتباط دارد. گره ۳ با گره ۴، ۱ و ۲ ارتباط دارد.</li><li>مرتب‌سازی این لیست‌ها (مثلاً به ترتیب صعودی) می‌تواند مفید باشد.</li><li>نگهداری (maintain) آن آسان نیست (not so easy to maintain). تغییرات و نگهداری آن نیاز به پشتیبانی دارد.</li><li>در فضای ذخیره‌سازی صرفه‌جویی می‌کند، اما سرعت دسترسی (مثلاً از گره ۱ به گره ۴) در ماتریس همسایگی راحت‌تر است.</li><li>برای داده‌های پراکنده (sparse) که اتصالات کمی دارند، مناسب‌تر است.</li><li>در مواردی مانند شبکه‌های اجتماعی با میلیاردها کاربر (مثل توییتر که بیش از ۲ میلیارد اکانت دارد)، که ماتریس همسایگی بسیار بزرگ می‌شود، لیست همسایگی مناسب‌تر است.</li></ul><h2>لیست جفت‌ها (List of Pairs)</h2><ul><li>یک نمایش دیگر از داده‌های گراف به صورت لیست جفت‌ها (مثلاً (۱,۲)، (۲,۳)، (۳,۴)، (۴,۵)، (۱,۳)).</li><li>این نمایش ساده‌ترین و کارآمدترین نمایش در برخی موارد است.</li><li>یک داده‌کاوی (data miner) ممکن است برای فضایی که می‌خواهد داده‌هایش به شکل گراف تجسم شود، از این روش استفاده کند.</li><li>این روش در مقایسه با ماتریس همسایگی و لیست همسایگی، خلاصه‌تر است، اما در همه جا کاربرد ندارد و فقط یال‌ها را نشان می‌دهد.</li><li>برای مقایسه، باید مجدداً در مجموعه داده جستجو کرد.</li><li>هر کدام از این روش‌ها کاربرد خاص خود را دارند.</li><li>مثال کاربرد: ساختار شیمیایی عناصر (مثلاً هیدروژن با اکسیژن). در اینجا تعداد داده‌ها زیاد است اما ترکیبیات (اتصالات) آن‌ها زیاد نیست.</li></ul><h1>انواع داده‌ها</h1><p>داده‌ها معمولاً سعی می‌شود به صورت عددی نگهداری شوند، زیرا مقایسه، تصمیم‌گیری، عملیات محاسباتی و فرمول‌های آماری روی اعداد راحت‌تر پیاده‌سازی می‌شوند. در بسیاری از موارد، متن، کلمه، رشته و غیره به عدد تبدیل می‌شوند و سپس محاسبات روی آن‌ها انجام می‌شود. به عنوان مثال، در نمایش گراف، به هر کاربر یک شماره داده می‌شود و محاسبات روی این شماره‌ها انجام می‌گیرد.</p><h2>دسته‌بندی اصلی داده‌ها</h2><ul><li><strong>داده‌های عددی (Numerical Data):</strong><ul><li>پیوسته (Continuous)</li><li>گسسته (Discrete)</li></ul></li><li><strong>داده‌های اسمی (Nominal Data):</strong> داده‌هایی که فقط نام دارند و ترتیب یا مقداری ندارند.</li><li><strong>داده‌های دسته‌ای/طبقه‌بندی‌شده (Categorical Data):</strong><ul><li>مثال: رنگ چشم (مشکی، قهوه‌ای، آبی)، رنگ مو.</li><li>مثال: کیفیت (خوب، بد، متوسط) در یک محقق.</li><li>مثال: کد پستی، کد شهر، کد تلفن.</li></ul></li><li><strong>داده‌های ترتیبی (Ordered Sequence Data):</strong> داده‌هایی که دارای ترتیب هستند.<ul><li>مثال: افزایش یا کاهش قیمت یک کالا در بورس.</li><li>مثال: درجه حرارت هوا در یک بازه زمانی.</li><li>مثال: قیمت طلا در یک بازه زمانی.</li><li>مثال: میزان جمعیت یک کشور از سال ۱۳۸۰ تا ۱۴۰۰ برای بررسی نرخ رشد جمعیت.</li></ul></li><li><strong>داده‌های گراف (Graph Data):</strong> داده‌هایی که به صورت گراف نمایش داده می‌شوند.</li></ul><p>بر اساس نوع داده‌ها (ترتیبی، دسته‌ای، عددی و غیره)، الگوریتم‌های مختلفی باید استفاده شود و تبدیل نوع داده انجام شود.</p><h1>منابع داده (Data Sources)</h1><p>برای تست، تحقیق و تحلیل داده‌ها، می‌توان از مراکز معتبر و استاندارد داده‌ها را جمع‌آوری کرد. انتخاب داده‌های مناسب و استاندارد بسیار مهم است.</p><h2>نمونه‌هایی از مخازن داده</h2><ul><li><strong>UCI Machine Learning Repository:</strong> یک منبع معتبر برای دیتاست‌های یادگیری ماشین.</li><li><strong>Google Dataset Search:</strong> شامل داده‌های تصویر، ویدئو، صوت، متن، رباتیک و غیره.</li><li><strong>Kaggle:</strong> یک پلتفرم محبوب برای دیتاست‌ها و مسابقات داده‌کاوی.</li><li><strong>KDD (Knowledge Discovery and Data Mining):</strong> یک منبع برای دیتاست‌ها.</li><li><strong>مؤسسات تحقیقاتی:</strong> برخی مؤسسات تحقیقاتی (مانند یک مؤسسه آلمانی) نیز دیتاست‌های خوبی را ارائه می‌دهند.</li></ul><h2>مثال دیتاست Bank Marketing از UCI</h2><ul><li><strong>هدف:</strong> پیش‌بینی اینکه آیا مشتری در یک کمپین بازاریابی مستقیم بانکی، سپرده مدت‌دار را مشترک می‌شود یا خیر.</li><li><strong>تعداد نمونه‌ها:</strong> ۴۵,۲۱۱ نمونه.</li><li><strong>حوزه داده:</strong> داده‌های کسب‌وکار (Business Data).</li><li><strong>نوع وظیفه:</strong> دسته‌بندی (Classification).</li><li><strong>تعداد ویژگی‌ها:</strong> ۱۶ ویژگی.</li><li><strong>نوع ویژگی‌ها:</strong> چندمتغیره (Multivariate)، دسته‌ای (Categorical) و عددی صحیح (Integer).</li><li><strong>نمونه ویژگی‌ها:</strong><ul><li><strong>Age (سن):</strong> عددی صحیح.</li><li><strong>Job (شغل):</strong> دسته‌ای (مثلاً دانشجو، شاغل، تکنسین).</li><li><strong>Marital (وضعیت تأهل):</strong> دسته‌ای (مثلاً متأهل، مطلقه، مجرد).</li><li><strong>Education (تحصیلات):</strong> دسته‌ای (مثلاً پایه، دبیرستان).</li><li><strong>Default (اعتبار پیش‌فرض):</strong> باینری (۰ یا ۱).</li><li><strong>Balance (موجودی):</strong> عددی صحیح.</li><li><strong>Average Yearly Balance (میانگین موجودی سالانه):</strong> عددی صحیح. (سیستم‌های بانکی کشورهای مختلف ممکن است در این زمینه متفاوت باشند).</li><li><strong>Housing (مسکن):</strong> دسته‌ای (دارد/ندارد).</li><li><strong>Loan (وام):</strong> دسته‌ای (دارد/ندارد).</li></ul></li></ul><h2>مثال دیتاست Student Stress Level Analysis</h2><ul><li><strong>تعداد ویژگی‌ها:</strong> ۶ ویژگی.</li><li><strong>نمونه ویژگی‌ها:</strong><ul><li>میزان مطالعه در هفته.</li><li>کیفیت خواب.</li><li>بار مطالعاتی.</li><li>تعداد دفعات ورزش در هفته.</li><li>میزان استرس.</li></ul></li></ul><p>فرمت‌هایی مانند CSV (Comma Separated Values)، XML یا JSON برای ذخیره‌سازی و ایجاد دیتاست‌ها استفاده می‌شوند. جمع‌آوری و ایجاد دیتاست‌های استاندارد و معتبر یک مرحله مهم در حوزه داده‌کاوی است.</p><h1>اطلاعات تکمیلی</h1><ul><li><strong>تکالیف:</strong> تکالیف باید انجام شوند.</li><li><strong>حضور و غیاب:</strong> لیست حضور و غیاب برای ارزیابی نهایی مهم است.</li><li><strong>برنامه کلاس‌ها:</strong> دوشنبه و چهارشنبه، ساعت ۸ تا ۱۰ صبح.</li></ul></div></div>','<div style=\"max-width: 100%; overflow-x: hidden; word-wrap: break-word; padding: 1rem; box-sizing: border-box;\"><h1>نمایش داده‌ها در گراف‌ها</h1><h2>ماتریس همسایگی (Adjacency Matrix)</h2><ul><li>یک ماتریس همسایگی است.</li><li>بسیار پراکنده (sparse) و پرمصرف (wasteful) از نظر فضا، اما از نظر مفهومی مفید است.</li><li>عناصر آن معمولاً ۰ یا ۱ هستند.</li><li>در وب مپ‌ها نیز به همین صورت استفاده می‌شود.</li><li>در محاسبات، ماتریس همسایگی کمک می‌کند.</li><li>برای ماتریس‌های متراکم (dense) که تعداد صفرها زیاد نیست، بهتر است.</li><li>اگر ابعاد ماتریس بالا برود (مثلاً ۲ میلیارد در ۲ میلیارد برای شبکه‌های اجتماعی مانند توییتر)، بسیار بزرگ می‌شود و محاسبات پیچیده می‌گردد.</li></ul><h2>لیست همسایگی (Adjacency List)</h2><ul><li>نمایش مجموعه داده به شکل گراف به صورت لیست همسایگی.</li><li>هر گره (node) لیستی از گره‌هایی که همسایه‌اش هستند، دارد.</li><li>مثال: گره ۱ با گره ۲ و ۳ ارتباط دارد. گره ۲ با گره ۱ و ۳ ارتباط دارد. گره ۳ با گره ۴، ۱ و ۲ ارتباط دارد.</li><li>مرتب‌سازی این لیست‌ها (مثلاً به ترتیب صعودی) می‌تواند مفید باشد.</li><li>نگهداری (maintain) آن آسان نیست (not so easy to maintain). تغییرات و نگهداری آن نیاز به پشتیبانی دارد.</li><li>در فضای ذخیره‌سازی صرفه‌جویی می‌کند، اما سرعت دسترسی (مثلاً از گره ۱ به گره ۴) در ماتریس همسایگی راحت‌تر است.</li><li>برای داده‌های پراکنده (sparse) که اتصالات کمی دارند، مناسب‌تر است.</li><li>در مواردی مانند شبکه‌های اجتماعی با میلیاردها کاربر (مثل توییتر که بیش از ۲ میلیارد اکانت دارد)، که ماتریس همسایگی بسیار بزرگ می‌شود، لیست همسایگی مناسب‌تر است.</li></ul><h2>لیست جفت‌ها (List of Pairs)</h2><ul><li>یک نمایش دیگر از داده‌های گراف به صورت لیست جفت‌ها (مثلاً (۱,۲)، (۲,۳)، (۳,۴)، (۴,۵)، (۱,۳)).</li><li>این نمایش ساده‌ترین و کارآمدترین نمایش در برخی موارد است.</li><li>یک داده‌کاوی (data miner) ممکن است برای فضایی که می‌خواهد داده‌هایش به شکل گراف تجسم شود، از این روش استفاده کند.</li><li>این روش در مقایسه با ماتریس همسایگی و لیست همسایگی، خلاصه‌تر است، اما در همه جا کاربرد ندارد و فقط یال‌ها را نشان می‌دهد.</li><li>برای مقایسه، باید مجدداً در مجموعه داده جستجو کرد.</li><li>هر کدام از این روش‌ها کاربرد خاص خود را دارند.</li><li>مثال کاربرد: ساختار شیمیایی عناصر (مثلاً هیدروژن با اکسیژن). در اینجا تعداد داده‌ها زیاد است اما ترکیبیات (اتصالات) آن‌ها زیاد نیست.</li></ul><h1>انواع داده‌ها</h1><p>داده‌ها معمولاً سعی می‌شود به صورت عددی نگهداری شوند، زیرا مقایسه، تصمیم‌گیری، عملیات محاسباتی و فرمول‌های آماری روی اعداد راحت‌تر پیاده‌سازی می‌شوند. در بسیاری از موارد، متن، کلمه، رشته و غیره به عدد تبدیل می‌شوند و سپس محاسبات روی آن‌ها انجام می‌شود. به عنوان مثال، در نمایش گراف، به هر کاربر یک شماره داده می‌شود و محاسبات روی این شماره‌ها انجام می‌گیرد.</p><h2>دسته‌بندی اصلی داده‌ها</h2><ul><li><strong>داده‌های عددی (Numerical Data):</strong><ul><li>پیوسته (Continuous)</li><li>گسسته (Discrete)</li></ul></li><li><strong>داده‌های اسمی (Nominal Data):</strong> داده‌هایی که فقط نام دارند و ترتیب یا مقداری ندارند.</li><li><strong>داده‌های دسته‌ای/طبقه‌بندی‌شده (Categorical Data):</strong><ul><li>مثال: رنگ چشم (مشکی، قهوه‌ای، آبی)، رنگ مو.</li><li>مثال: کیفیت (خوب، بد، متوسط) در یک محقق.</li><li>مثال: کد پستی، کد شهر، کد تلفن.</li></ul></li><li><strong>داده‌های ترتیبی (Ordered Sequence Data):</strong> داده‌هایی که دارای ترتیب هستند.<ul><li>مثال: افزایش یا کاهش قیمت یک کالا در بورس.</li><li>مثال: درجه حرارت هوا در یک بازه زمانی.</li><li>مثال: قیمت طلا در یک بازه زمانی.</li><li>مثال: میزان جمعیت یک کشور از سال ۱۳۸۰ تا ۱۴۰۰ برای بررسی نرخ رشد جمعیت.</li></ul></li><li><strong>داده‌های گراف (Graph Data):</strong> داده‌هایی که به صورت گراف نمایش داده می‌شوند.</li></ul><p>بر اساس نوع داده‌ها (ترتیبی، دسته‌ای، عددی و غیره)، الگوریتم‌های مختلفی باید استفاده شود و تبدیل نوع داده انجام شود.</p><h1>منابع داده (Data Sources)</h1><p>برای تست، تحقیق و تحلیل داده‌ها، می‌توان از مراکز معتبر و استاندارد داده‌ها را جمع‌آوری کرد. انتخاب داده‌های مناسب و استاندارد بسیار مهم است.</p><h2>نمونه‌هایی از مخازن داده</h2><ul><li><strong>UCI Machine Learning Repository:</strong> یک منبع معتبر برای دیتاست‌های یادگیری ماشین.</li><li><strong>Google Dataset Search:</strong> شامل داده‌های تصویر، ویدئو، صوت، متن، رباتیک و غیره.</li><li><strong>Kaggle:</strong> یک پلتفرم محبوب برای دیتاست‌ها و مسابقات داده‌کاوی.</li><li><strong>KDD (Knowledge Discovery and Data Mining):</strong> یک منبع برای دیتاست‌ها.</li><li><strong>مؤسسات تحقیقاتی:</strong> برخی مؤسسات تحقیقاتی (مانند یک مؤسسه آلمانی) نیز دیتاست‌های خوبی را ارائه می‌دهند.</li></ul><h2>مثال دیتاست Bank Marketing از UCI</h2><ul><li><strong>هدف:</strong> پیش‌بینی اینکه آیا مشتری در یک کمپین بازاریابی مستقیم بانکی، سپرده مدت‌دار را مشترک می‌شود یا خیر.</li><li><strong>تعداد نمونه‌ها:</strong> ۴۵,۲۱۱ نمونه.</li><li><strong>حوزه داده:</strong> داده‌های کسب‌وکار (Business Data).</li><li><strong>نوع وظیفه:</strong> دسته‌بندی (Classification).</li><li><strong>تعداد ویژگی‌ها:</strong> ۱۶ ویژگی.</li><li><strong>نوع ویژگی‌ها:</strong> چندمتغیره (Multivariate)، دسته‌ای (Categorical) و عددی صحیح (Integer).</li><li><strong>نمونه ویژگی‌ها:</strong><ul><li><strong>Age (سن):</strong> عددی صحیح.</li><li><strong>Job (شغل):</strong> دسته‌ای (مثلاً دانشجو، شاغل، تکنسین).</li><li><strong>Marital (وضعیت تأهل):</strong> دسته‌ای (مثلاً متأهل، مطلقه، مجرد).</li><li><strong>Education (تحصیلات):</strong> دسته‌ای (مثلاً پایه، دبیرستان).</li><li><strong>Default (اعتبار پیش‌فرض):</strong> باینری (۰ یا ۱).</li><li><strong>Balance (موجودی):</strong> عددی صحیح.</li><li><strong>Average Yearly Balance (میانگین موجودی سالانه):</strong> عددی صحیح. (سیستم‌های بانکی کشورهای مختلف ممکن است در این زمینه متفاوت باشند).</li><li><strong>Housing (مسکن):</strong> دسته‌ای (دارد/ندارد).</li><li><strong>Loan (وام):</strong> دسته‌ای (دارد/ندارد).</li></ul></li></ul><h2>مثال دیتاست Student Stress Level Analysis</h2><ul><li><strong>تعداد ویژگی‌ها:</strong> ۶ ویژگی.</li><li><strong>نمونه ویژگی‌ها:</strong><ul><li>میزان مطالعه در هفته.</li><li>کیفیت خواب.</li><li>بار مطالعاتی.</li><li>تعداد دفعات ورزش در هفته.</li><li>میزان استرس.</li></ul></li></ul><p>فرمت‌هایی مانند CSV (Comma Separated Values)، XML یا JSON برای ذخیره‌سازی و ایجاد دیتاست‌ها استفاده می‌شوند. جمع‌آوری و ایجاد دیتاست‌های استاندارد و معتبر یک مرحله مهم در حوزه داده‌کاوی است.</p><h1>اطلاعات تکمیلی</h1><ul><li><strong>تکالیف:</strong> تکالیف باید انجام شوند.</li><li><strong>حضور و غیاب:</strong> لیست حضور و غیاب برای ارزیابی نهایی مهم است.</li><li><strong>برنامه کلاس‌ها:</strong> دوشنبه و چهارشنبه، ساعت ۸ تا ۱۰ صبح.</li></ul></div>','completed','2025-12-01 19:11:20','2025-12-03 04:33:26',NULL,NULL,0,NULL,1,NULL),(64,7,1,'_⁨داده کاوی⁩','1404/07/28',NULL,NULL,'failed','2025-12-02 08:34:24','2025-12-02 08:34:25','خطای غیرمنتظره در پردازش فایل: AttributeError. لطفاً با پشتیبانی تماس بگیرید.','AttributeError: \'Settings\' object has no attribute \'USE_GEMINI_DISPATCHER\'\n\nTraceback (most recent call last):\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/app/worker/tasks_with_credits_fixed.py\", line 108, in run_processing\n    from app.services.ai_service import process_files_with_gemini\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/app/services/ai_service.py\", line 19, in <module>\n    if settings.USE_GEMINI_DISPATCHER:\n       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/pydantic/main.py\", line 761, in __getattr__\n    raise AttributeError(f\'{type(self).__name__!r} object has no attribute {item!r}\')\nAttributeError: \'Settings\' object has no attribute \'USE_GEMINI_DISPATCHER\'\n',0,'2025-12-02 08:34:26',1,'unknown_error'),(65,7,1,'_⁨داده کاوی⁩','1404/07/09',NULL,NULL,'failed','2025-12-02 08:35:00','2025-12-02 08:45:03','خطای غیرمنتظره در پردازش فایل: NetworkError. لطفاً با پشتیبانی تماس بگیرید.','NetworkError: خطا در اتصال به سرویس. لطفا اتصال اینترنت خود را بررسی کنید\n\nTraceback (most recent call last):\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/app/services/ai_service.py\", line 244, in process_files_with_gemini\n    response = model.generate_content(\n               ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/google/generativeai/generative_models.py\", line 331, in generate_content\n    response = self._client.generate_content(\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/google/ai/generativelanguage_v1beta/services/generative_service/client.py\", line 835, in generate_content\n    response = rpc(\n               ^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/google/api_core/gapic_v1/method.py\", line 131, in __call__\n    return wrapped_func(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/google/api_core/retry/retry_unary.py\", line 294, in retry_wrapped_func\n    return retry_target(\n           ^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/google/api_core/retry/retry_unary.py\", line 156, in retry_target\n    next_sleep = _retry_error_helper(\n                 ^^^^^^^^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/google/api_core/retry/retry_base.py\", line 214, in _retry_error_helper\n    raise final_exc from source_exc\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/google/api_core/retry/retry_unary.py\", line 147, in retry_target\n    result = target()\n             ^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/google/api_core/timeout.py\", line 130, in func_with_timeout\n    return func(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/google/api_core/grpc_helpers.py\", line 75, in error_remapped_callable\n    return callable_(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/google/ai/generativelanguage_v1beta/services/generative_service/transports/rest.py\", line 1148, in __call__\n    response = GenerativeServiceRestTransport._GenerateContent._get_response(\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/google/ai/generativelanguage_v1beta/services/generative_service/transports/rest.py\", line 1048, in _get_response\n    response = getattr(session, method)(\n               ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/requests/sessions.py\", line 637, in post\n    return self.request(\"POST\", url, data=data, json=json, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/google/auth/transport/requests.py\", line 540, in request\n    response = super(AuthorizedSession, self).request(\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/requests/sessions.py\", line 589, in request\n    resp = self.send(prep, **send_kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/requests/sessions.py\", line 703, in send\n    r = adapter.send(request, **kwargs)\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/requests/adapters.py\", line 659, in send\n    raise ConnectionError(err, request=request)\nrequests.exceptions.ConnectionError: (\'Connection aborted.\', TimeoutError(\'timed out\'))\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/app/worker/tasks_with_credits_fixed.py\", line 119, in run_processing\n    gemini_output = await process_files_with_gemini(file_paths)\n                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/app/services/ai_service.py\", line 259, in process_files_with_gemini\n    raise NetworkError()\napp.services.exceptions.NetworkError: خطا در اتصال به سرویس. لطفا اتصال اینترنت خود را بررسی کنید\n',0,'2025-12-02 08:45:04',1,'unknown_error'),(66,7,1,'_⁨داده کاوی⁩','1404/08/05',NULL,NULL,'failed','2025-12-02 08:58:08','2025-12-02 09:08:11','خطای غیرمنتظره در پردازش فایل: NetworkError. لطفاً با پشتیبانی تماس بگیرید.','NetworkError: خطا در اتصال به سرویس. لطفا اتصال اینترنت خود را بررسی کنید\n\nTraceback (most recent call last):\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/app/services/ai_service.py\", line 235, in process_files_with_gemini\n    response = model.generate_content(\n               ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/google/generativeai/generative_models.py\", line 331, in generate_content\n    response = self._client.generate_content(\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/google/ai/generativelanguage_v1beta/services/generative_service/client.py\", line 835, in generate_content\n    response = rpc(\n               ^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/google/api_core/gapic_v1/method.py\", line 131, in __call__\n    return wrapped_func(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/google/api_core/retry/retry_unary.py\", line 294, in retry_wrapped_func\n    return retry_target(\n           ^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/google/api_core/retry/retry_unary.py\", line 156, in retry_target\n    next_sleep = _retry_error_helper(\n                 ^^^^^^^^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/google/api_core/retry/retry_base.py\", line 214, in _retry_error_helper\n    raise final_exc from source_exc\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/google/api_core/retry/retry_unary.py\", line 147, in retry_target\n    result = target()\n             ^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/google/api_core/timeout.py\", line 130, in func_with_timeout\n    return func(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/google/api_core/grpc_helpers.py\", line 75, in error_remapped_callable\n    return callable_(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/google/ai/generativelanguage_v1beta/services/generative_service/transports/rest.py\", line 1148, in __call__\n    response = GenerativeServiceRestTransport._GenerateContent._get_response(\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/google/ai/generativelanguage_v1beta/services/generative_service/transports/rest.py\", line 1048, in _get_response\n    response = getattr(session, method)(\n               ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/requests/sessions.py\", line 637, in post\n    return self.request(\"POST\", url, data=data, json=json, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/google/auth/transport/requests.py\", line 540, in request\n    response = super(AuthorizedSession, self).request(\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/requests/sessions.py\", line 589, in request\n    resp = self.send(prep, **send_kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/requests/sessions.py\", line 703, in send\n    r = adapter.send(request, **kwargs)\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/requests/adapters.py\", line 659, in send\n    raise ConnectionError(err, request=request)\nrequests.exceptions.ConnectionError: (\'Connection aborted.\', TimeoutError(\'timed out\'))\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/app/worker/tasks_with_credits_fixed.py\", line 119, in run_processing\n    gemini_output = await process_files_with_gemini(file_paths)\n                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/app/services/ai_service.py\", line 250, in process_files_with_gemini\n    raise NetworkError()\napp.services.exceptions.NetworkError: خطا در اتصال به سرویس. لطفا اتصال اینترنت خود را بررسی کنید\n',0,'2025-12-02 09:08:12',1,'unknown_error'),(67,7,1,'_⁨داده کاوی⁩','1404/07/07',NULL,NULL,'failed','2025-12-02 20:00:08','2025-12-02 20:10:13','خطای غیرمنتظره در پردازش فایل: NetworkError. لطفاً با پشتیبانی تماس بگیرید.','NetworkError: خطا در اتصال به سرویس. لطفا اتصال اینترنت خود را بررسی کنید\n\nTraceback (most recent call last):\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/app/services/ai_service.py\", line 238, in process_files_with_gemini\n    response = model.generate_content(\n               ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/google/generativeai/generative_models.py\", line 331, in generate_content\n    response = self._client.generate_content(\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/google/ai/generativelanguage_v1beta/services/generative_service/client.py\", line 835, in generate_content\n    response = rpc(\n               ^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/google/api_core/gapic_v1/method.py\", line 131, in __call__\n    return wrapped_func(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/google/api_core/retry/retry_unary.py\", line 294, in retry_wrapped_func\n    return retry_target(\n           ^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/google/api_core/retry/retry_unary.py\", line 156, in retry_target\n    next_sleep = _retry_error_helper(\n                 ^^^^^^^^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/google/api_core/retry/retry_base.py\", line 214, in _retry_error_helper\n    raise final_exc from source_exc\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/google/api_core/retry/retry_unary.py\", line 147, in retry_target\n    result = target()\n             ^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/google/api_core/timeout.py\", line 130, in func_with_timeout\n    return func(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/google/api_core/grpc_helpers.py\", line 75, in error_remapped_callable\n    return callable_(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/google/ai/generativelanguage_v1beta/services/generative_service/transports/rest.py\", line 1148, in __call__\n    response = GenerativeServiceRestTransport._GenerateContent._get_response(\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/google/ai/generativelanguage_v1beta/services/generative_service/transports/rest.py\", line 1048, in _get_response\n    response = getattr(session, method)(\n               ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/requests/sessions.py\", line 637, in post\n    return self.request(\"POST\", url, data=data, json=json, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/google/auth/transport/requests.py\", line 540, in request\n    response = super(AuthorizedSession, self).request(\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/requests/sessions.py\", line 589, in request\n    resp = self.send(prep, **send_kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/requests/sessions.py\", line 703, in send\n    r = adapter.send(request, **kwargs)\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/venv/lib/python3.12/site-packages/requests/adapters.py\", line 659, in send\n    raise ConnectionError(err, request=request)\nrequests.exceptions.ConnectionError: (\'Connection aborted.\', TimeoutError(\'timed out\'))\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/app/worker/tasks_with_credits_fixed.py\", line 119, in run_processing\n    gemini_output = await process_files_with_gemini(file_paths)\n                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/lili/Desktop/DriveD/work/neviso/thirdTry/neviso-backend/app/services/ai_service.py\", line 253, in process_files_with_gemini\n    raise NetworkError()\napp.services.exceptions.NetworkError: خطا در اتصال به سرویس. لطفا اتصال اینترنت خود را بررسی کنید\n',0,'2025-12-02 20:10:13',1,'unknown_error'),(68,7,1,'نمایش داده‌ها و انواع داده‌ها در داده‌کاوی','1404/08/05','<div style=\"max-width: 100%; overflow-x: hidden; word-wrap: break-word; padding: 1rem; box-sizing: border-box;\"><div style=\"max-width: 100%; overflow-x: hidden; word-wrap: break-word; padding: 1rem; box-sizing: border-box;\"><h1>نمایش داده‌ها</h1><p>در حوزه داده‌کاوی، نمایش داده‌ها از اهمیت بالایی برخوردار است. دو روش اصلی برای نمایش گراف‌ها (مجموعه داده‌ها) مورد بحث قرار گرفت:</p><h2>ماتریس همسایگی (Adjacency Matrix)</h2><ul><li>این یک ماتریس همسایگی است.</li><li>بسیار پراکنده (sparse) و با اتلاف حافظه زیاد (wasteful) است، اما از نظر مفهومی بسیار مفید و کاربردی است.</li><li>ممکن است عناصر آن عمدتاً صفر یا خالی باشند.</li><li>در کاربردهایی مانند Google Maps نیز به همین صورت است.</li><li>در سرعت دسترسی، ماتریس همسایگی عملکرد بهتری دارد، زیرا می‌توان به راحتی از یک گره به گره دیگر دسترسی پیدا کرد (مثلاً از گره ۱ به گره ۴).</li><li>در محاسبات، ماتریس همسایگی کمک می‌کند.</li><li>اما وقتی ابعاد ماتریس بسیار بالا می‌رود (مثلاً ۲ میلیارد سطر و ۲ میلیارد ستون برای داده‌های توییتر)، حجم آن بسیار زیاد می‌شود (۴ با ۱۸ صفر). در این حالت، محاسبات پیچیده می‌شوند و ممکن است نگهداری این مدل مناسب نباشد.</li></ul><h2>لیست همسایگی (Adjacency List)</h2><ul><li>این روش، نمایش همین مجموعه داده به شکل گراف را به صورت یک لیست همسایگی نشان می‌دهد.</li><li>هر گره یک لیستی از گره‌هایی دارد که همسایه آن هستند.</li><li>مثال: گره ۱ با گره ۲ و ۳ ارتباط مستقیم دارد. گره ۲ با گره ۱ و ۳. گره ۳ با گره ۴، ۱ و ۲.</li><li>اگر گره‌ها به ترتیب مرتب شوند (مثلاً ۱، ۲، ۳، ۴)، بهتر است.</li><li>این روش برای نگهداری (maintenance) آسان نیست.</li><li>در مقایسه با ماتریس همسایگی، لیست همسایگی در صرفه‌جویی فضای ذخیره‌سازی بهتر عمل می‌کند.</li><li>این روش فقط یال‌ها را نشان می‌دهد (مثلاً ۱ و ۲ ارتباط دارند، ۲ و ۳ ارتباط دارند).</li><li>برای مقایسه، باید مجدداً در مجموعه داده جستجو کرد.</li><li>هر کدام از این روش‌ها کاربرد خاص خود را در جایگاه‌های مختلف دارند.</li><li>مثلاً در اشکال شیمیایی، یک اتم ممکن است با اتم‌های دیگر ارتباط داشته باشد که این نیز نوعی گراف است. ساختار شیمیایی عناصر (مانند هیدروژن با اکسیژن) از نظر ذخیره‌سازی مفید است، زیرا همه عناصر با هم ترکیب نمی‌شوند یا اتصال ندارند.</li><li>در این حالت، تعداد ساختارهای داده زیاد است اما ترکیبات آن‌ها زیاد نیست. بنابراین، این نوع نمایش در فرمول‌های شیمیایی و حوزه شیمی بسیار کاربرد دارد.</li></ul><h2>نمایش لیست جفت‌ها (List of Pairs)</h2><ul><li>این روش به صورت یک لیست از جفت‌ها (list of pairs) است.</li><li>به عنوان ساده‌ترین و کارآمدترین نمایش در یک محیط گراف در نظر گرفته می‌شود.</li><li>مثال: (۱,۲)، (۱,۳)، (۲,۳)، (۳,۴)، (۴,۵)، (۱,۳).</li><li>یک داده‌کاو ممکن است تصمیم بگیرد که برای فضایی که داده‌هایش باید به شکل گراف تجسم شود، این روش ذخیره‌سازی را در نظر بگیرد.</li></ul><h2>انواع داده‌ها (Types of Data)</h2><p>داده‌ها انواع مختلفی دارند که در داده‌کاوی مورد استفاده قرار می‌گیرند:</p><h3>۱. داده‌های عددی (Numerical Data)</h3><ul><li>داده‌های عددی و غیرعددی دو دسته‌بندی بسیار مهم هستند.</li><li>داده‌ها معمولاً سعی می‌شود به صورت عددی نگهداری شوند.</li><li>چرا؟ زیرا مقایسه کردن اعداد با یکدیگر، تصمیم‌گیری، عملیات محاسباتی، فرمول‌های آماری و غیره روی اعداد خیلی راحت‌تر پیاده می‌شود.</li><li>خیلی جاها، متن، کلمه، رشته و غیره تبدیل به عدد می‌شود و بعد روی آن‌ها محاسبه انجام می‌شود.</li><li>خودشان به دو دسته تقسیم می‌شوند: داده‌های عددی پیوسته (continuous) و گسسته (discrete).</li></ul><h3>۲. داده‌های طبقه‌بندی شده (Categorical Data)</h3><ul><li>داده‌های دسته‌ای یا طبقه‌بندی شده.</li><li>مثال: رنگ چشم (مشکی، قهوه‌ای، آبی)، رنگ مو.</li><li>مثال دیگر: خوب، بد، متوسط در ارزیابی‌ها.</li><li>مثال دیگر: کد پستی، کد شهرها، کد تلفن.</li></ul><h3>۳. داده‌های ترتیبی (Ordered Sequence Data)</h3><ul><li>داده‌های ترتیبی.</li><li>مثال: افزایش و کاهش قیمت یک کالا در بورس.</li><li>مثال: داده‌های مربوط به درجه حرارت هوا از یک بازه زمانی تا بازه زمانی دیگر.</li><li>مثال: قیمت طلا.</li><li>مثال: میزان جمعیت یک کشور از سال ۱۳۸۰ تا ۱۴۰۰ برای بررسی نرخ رشد جمعیت (افزایشی یا کاهشی بودن).</li></ul><h3>۴. داده‌های مجموعه (Set Data)</h3><ul><li>این نوع داده‌ها شامل مجموعه‌ای از آیتم‌ها هستند که ترتیب خاصی ندارند.</li></ul><h3>۵. داده‌های گراف (Graph Data)</h3><ul><li>این نوع داده‌ها ساختارهای شبکه‌ای را نشان می‌دهند که شامل گره‌ها و یال‌ها هستند.</li></ul><p>بر اساس اینکه داده‌های ما ترتیبی، مجموعه‌ای، طبقه‌بندی شده یا عددی هستند، هر کدام از این‌ها در الگوریتم‌های مختلف باید تبدیل نوع انجام شود و کاربردش متفاوت خواهد بود.</p><h2>منابع جمع‌آوری داده (Data Collection Sources)</h2><p>برای تست و تحلیل داده، می‌توان از منابع معتبر و استاندارد استفاده کرد:</p><ul><li><strong>Kaggle:</strong> یک سایت بسیار خوب برای دسترسی به مجموعه داده‌ها (datasets) است.</li><li><strong>UCI Machine Learning Repository:</strong> مخزن داده‌های یادگیری ماشین دانشگاه UCI (University of California, Irvine) در آمریکا.</li><li><strong>Google Datasets:</strong> مخزن داده‌های گوگل شامل تصویر، ویدئو، صوت، متن، رباتیک و غیره.</li><li><strong>Knowledge Discovery in Databases (KDD) Nuggets:</strong> یک سایت بسیار خوب دیگر برای کشف دانش از داده‌ها.</li><li><strong>German Research Centre for Artificial Intelligence (DFKI):</strong> یک موسسه تحقیقاتی آلمانی که داده‌ست‌های خوبی را در زمینه یادگیری ماشین و تحلیل ارائه می‌دهد.</li></ul><p>این سایت‌ها داده‌هایی را جمع‌آوری کرده‌اند که بر اساس مقاصد آموزشی یا اهداف مختلف دیگر توسط حوزه‌های مختلف استفاده شده و استاندارد هستند. اگر داده‌ها صرفاً با ویژگی‌های دلخواه انتخاب و ذخیره شوند، لزوماً نمی‌توانند در حوزه‌های مختلف داده‌کاوی مورد استفاده قرار گیرند.</p><p>فرمت‌های ذخیره‌سازی داده نیز مهم هستند، مانند CSV (Comma Separated Values)، XML یا JSON، که هر کدام مرحله‌ای از فرآیند داده‌کاوی محسوب می‌شوند.</p>\n<p><strong>مثال‌هایی از داده‌ست‌ها:</strong></p>\n<ul>\n<li><strong>Bank Marketing Dataset (UCI):</strong> شامل ۴۵,۲۱۱ نمونه با ۱۶ ویژگی. نوع داده‌ها تجاری (business) است و هدف آن طبقه‌بندی (classification) است تا پیش‌بینی کند آیا مشتری در یک سپرده مدت‌دار (term deposit) عضو می‌شود یا خیر. ویژگی‌ها شامل:\n    <ul>\n<li><code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">Age</code>: عددی (integer)</li>\n<li><code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">Job</code>: دسته‌ای (categorical) - مانند دانشجو (student)، شاغل (employed)، تکنسین (technician)</li>\n<li><code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">Marital</code>: دسته‌ای (categorical) - مانند متأهل (married)، مطلقه (divorced)، بیوه (widowed)</li>\n<li><code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">Education</code>: دسته‌ای (categorical) - مانند پایه (basic)، دبیرستان (high school)، بی‌سواد (illiterate)</li>\n<li><code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">Default</code>: نشان‌دهنده اعتبار پیش‌فرض (default credit) - صفر یا یک</li>\n<li><code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">Balance</code>: میزان موجودی (integer)</li>\n<li><code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">Average Yearly Balance</code>: میانگین موجودی سالانه</li>\n<li><code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">Housing</code>: مسکن دارد یا خیر</li>\n<li><code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">Contact</code>: نوع تماس</li>\n</ul>\n</li>\n<li><strong>Student Stress Level Dataset (Kaggle):</strong> تحلیل داده‌ست مربوط به سطح استرس دانش‌آموزان. شامل ۶ ویژگی، مانند:\n    <ul>\n<li>تعداد دفعات مطالعه در هفته</li>\n<li>کیفیت خواب</li>\n<li>میزان بار مطالعاتی</li>\n<li>تعداد دفعات ورزش در هفته</li>\n<li>سطح استرس</li>\n</ul>\n</li>\n<li><strong>Sports Statistics (DFKI):</strong> داده‌های آماری حوزه ورزش، مانند فوتبال.</li>\n</ul>\n<p><strong>نکته:</strong> تصویر ارائه شده (سایدبار برنامه Oculis) یک مثال عمومی از رابط کاربری است و ارتباط مستقیمی با محتوای سخنرانی ندارد، اما ممکن است به عنوان یک نمونه بصری از سازماندهی اطلاعات در یک سیستم داده‌محور در نظر گرفته شود.</p></div></div>','<h1>نمایش داده‌ها</h1><p>در حوزه داده‌کاوی، نمایش داده‌ها از اهمیت بالایی برخوردار است. دو روش اصلی برای نمایش گراف‌ها (مجموعه داده‌ها) مورد بحث قرار گرفت:</p><h2>ماتریس همسایگی (Adjacency Matrix)</h2><ul><li>این یک ماتریس همسایگی است.</li><li>بسیار پراکنده (sparse) و با اتلاف حافظه زیاد (wasteful) است، اما از نظر مفهومی بسیار مفید و کاربردی است.</li><li>ممکن است عناصر آن عمدتاً صفر یا خالی باشند.</li><li>در کاربردهایی مانند Google Maps نیز به همین صورت است.</li><li>در سرعت دسترسی، ماتریس همسایگی عملکرد بهتری دارد، زیرا می‌توان به راحتی از یک گره به گره دیگر دسترسی پیدا کرد (مثلاً از گره ۱ به گره ۴).</li><li>در محاسبات، ماتریس همسایگی کمک می‌کند.</li><li>اما وقتی ابعاد ماتریس بسیار بالا می‌رود (مثلاً ۲ میلیارد سطر و ۲ میلیارد ستون برای داده‌های توییتر)، حجم آن بسیار زیاد می‌شود (۴ با ۱۸ صفر). در این حالت، محاسبات پیچیده می‌شوند و ممکن است نگهداری این مدل مناسب نباشد.</li></ul><h2>لیست همسایگی (Adjacency List)</h2><ul><li>این روش، نمایش همین مجموعه داده به شکل گراف را به صورت یک لیست همسایگی نشان می‌دهد.</li><li>هر گره یک لیستی از گره‌هایی دارد که همسایه آن هستند.</li><li>مثال: گره ۱ با گره ۲ و ۳ ارتباط مستقیم دارد. گره ۲ با گره ۱ و ۳. گره ۳ با گره ۴، ۱ و ۲.</li><li>اگر گره‌ها به ترتیب مرتب شوند (مثلاً ۱، ۲، ۳، ۴)، بهتر است.</li><li>این روش برای نگهداری (maintenance) آسان نیست.</li><li>در مقایسه با ماتریس همسایگی، لیست همسایگی در صرفه‌جویی فضای ذخیره‌سازی بهتر عمل می‌کند.</li><li>این روش فقط یال‌ها را نشان می‌دهد (مثلاً ۱ و ۲ ارتباط دارند، ۲ و ۳ ارتباط دارند).</li><li>برای مقایسه، باید مجدداً در مجموعه داده جستجو کرد.</li><li>هر کدام از این روش‌ها کاربرد خاص خود را در جایگاه‌های مختلف دارند.</li><li>مثلاً در اشکال شیمیایی، یک اتم ممکن است با اتم‌های دیگر ارتباط داشته باشد که این نیز نوعی گراف است. ساختار شیمیایی عناصر (مانند هیدروژن با اکسیژن) از نظر ذخیره‌سازی مفید است، زیرا همه عناصر با هم ترکیب نمی‌شوند یا اتصال ندارند.</li><li>در این حالت، تعداد ساختارهای داده زیاد است اما ترکیبات آن‌ها زیاد نیست. بنابراین، این نوع نمایش در فرمول‌های شیمیایی و حوزه شیمی بسیار کاربرد دارد.</li></ul><h2>نمایش لیست جفت‌ها (List of Pairs)</h2><ul><li>این روش به صورت یک لیست از جفت‌ها (list of pairs) است.</li><li>به عنوان ساده‌ترین و کارآمدترین نمایش در یک محیط گراف در نظر گرفته می‌شود.</li><li>مثال: (۱,۲)، (۱,۳)، (۲,۳)، (۳,۴)، (۴,۵)، (۱,۳).</li><li>یک داده‌کاو ممکن است تصمیم بگیرد که برای فضایی که داده‌هایش باید به شکل گراف تجسم شود، این روش ذخیره‌سازی را در نظر بگیرد.</li></ul><h2>انواع داده‌ها (Types of Data)</h2><p>داده‌ها انواع مختلفی دارند که در داده‌کاوی مورد استفاده قرار می‌گیرند:</p><h3>۱. داده‌های عددی (Numerical Data)</h3><ul><li>داده‌های عددی و غیرعددی دو دسته‌بندی بسیار مهم هستند.</li><li>داده‌ها معمولاً سعی می‌شود به صورت عددی نگهداری شوند.</li><li>چرا؟ زیرا مقایسه کردن اعداد با یکدیگر، تصمیم‌گیری، عملیات محاسباتی، فرمول‌های آماری و غیره روی اعداد خیلی راحت‌تر پیاده می‌شود.</li><li>خیلی جاها، متن، کلمه، رشته و غیره تبدیل به عدد می‌شود و بعد روی آن‌ها محاسبه انجام می‌شود.</li><li>خودشان به دو دسته تقسیم می‌شوند: داده‌های عددی پیوسته (continuous) و گسسته (discrete).</li></ul><h3>۲. داده‌های طبقه‌بندی شده (Categorical Data)</h3><ul><li>داده‌های دسته‌ای یا طبقه‌بندی شده.</li><li>مثال: رنگ چشم (مشکی، قهوه‌ای، آبی)، رنگ مو.</li><li>مثال دیگر: خوب، بد، متوسط در ارزیابی‌ها.</li><li>مثال دیگر: کد پستی، کد شهرها، کد تلفن.</li></ul><h3>۳. داده‌های ترتیبی (Ordered Sequence Data)</h3><ul><li>داده‌های ترتیبی.</li><li>مثال: افزایش و کاهش قیمت یک کالا در بورس.</li><li>مثال: داده‌های مربوط به درجه حرارت هوا از یک بازه زمانی تا بازه زمانی دیگر.</li><li>مثال: قیمت طلا.</li><li>مثال: میزان جمعیت یک کشور از سال ۱۳۸۰ تا ۱۴۰۰ برای بررسی نرخ رشد جمعیت (افزایشی یا کاهشی بودن).</li></ul><h3>۴. داده‌های مجموعه (Set Data)</h3><ul><li>این نوع داده‌ها شامل مجموعه‌ای از آیتم‌ها هستند که ترتیب خاصی ندارند.</li></ul><h3>۵. داده‌های گراف (Graph Data)</h3><ul><li>این نوع داده‌ها ساختارهای شبکه‌ای را نشان می‌دهند که شامل گره‌ها و یال‌ها هستند.</li></ul><p>بر اساس اینکه داده‌های ما ترتیبی، مجموعه‌ای، طبقه‌بندی شده یا عددی هستند، هر کدام از این‌ها در الگوریتم‌های مختلف باید تبدیل نوع انجام شود و کاربردش متفاوت خواهد بود.</p><h2>منابع جمع‌آوری داده (Data Collection Sources)</h2><p>برای تست و تحلیل داده، می‌توان از منابع معتبر و استاندارد استفاده کرد:</p><ul><li><strong>Kaggle:</strong> یک سایت بسیار خوب برای دسترسی به مجموعه داده‌ها (datasets) است.</li><li><strong>UCI Machine Learning Repository:</strong> مخزن داده‌های یادگیری ماشین دانشگاه UCI (University of California, Irvine) در آمریکا.</li><li><strong>Google Datasets:</strong> مخزن داده‌های گوگل شامل تصویر، ویدئو، صوت، متن، رباتیک و غیره.</li><li><strong>Knowledge Discovery in Databases (KDD) Nuggets:</strong> یک سایت بسیار خوب دیگر برای کشف دانش از داده‌ها.</li><li><strong>German Research Centre for Artificial Intelligence (DFKI):</strong> یک موسسه تحقیقاتی آلمانی که داده‌ست‌های خوبی را در زمینه یادگیری ماشین و تحلیل ارائه می‌دهد.</li></ul><p>این سایت‌ها داده‌هایی را جمع‌آوری کرده‌اند که بر اساس مقاصد آموزشی یا اهداف مختلف دیگر توسط حوزه‌های مختلف استفاده شده و استاندارد هستند. اگر داده‌ها صرفاً با ویژگی‌های دلخواه انتخاب و ذخیره شوند، لزوماً نمی‌توانند در حوزه‌های مختلف داده‌کاوی مورد استفاده قرار گیرند.</p><p>فرمت‌های ذخیره‌سازی داده نیز مهم هستند، مانند CSV (Comma Separated Values)، XML یا JSON، که هر کدام مرحله‌ای از فرآیند داده‌کاوی محسوب می‌شوند.</p><p><strong>مثال‌هایی از داده‌ست‌ها:</strong></p><ul><li><strong>Bank Marketing Dataset (UCI):</strong> شامل ۴۵,۲۱۱ نمونه با ۱۶ ویژگی. نوع داده‌ها تجاری (business) است و هدف آن طبقه‌بندی (classification) است تا پیش‌بینی کند آیا مشتری در یک سپرده مدت‌دار (term deposit) عضو می‌شود یا خیر. ویژگی‌ها شامل:</li><li class=\"ql-indent-1\"><code>Age</code>: عددی (integer)</li><li class=\"ql-indent-1\"><code>Job</code>: دسته‌ای (categorical) - مانند دانشجو (student)، شاغل (employed)، تکنسین (technician)</li><li class=\"ql-indent-1\"><code>Marital</code>: دسته‌ای (categorical) - مانند متأهل (married)، مطلقه (divorced)، بیوه (widowed)</li><li class=\"ql-indent-1\"><code>Education</code>: دسته‌ای (categorical) - مانند پایه (basic)، دبیرستان (high school)، بی‌سواد (illiterate)</li><li class=\"ql-indent-1\"><code>Default</code>: نشان‌دهنده اعتبار پیش‌فرض (default credit) - صفر یا یک</li><li class=\"ql-indent-1\"><code>Balance</code>: میزان موجودی (integer)</li><li class=\"ql-indent-1\"><code>Average Yearly Balance</code>: میانگین موجودی سالانه</li><li class=\"ql-indent-1\"><code>Housing</code>: مسکن دارد یا خیر</li><li class=\"ql-indent-1\"><code>Contact</code>: نوع تماس</li><li><strong>Student Stress Level Dataset (Kaggle):</strong> تحلیل داده‌ست مربوط به سطح استرس دانش‌آموزان. شامل ۶ ویژگی، مانند:</li><li class=\"ql-indent-1\">تعداد دفعات مطالعه در هفته</li><li class=\"ql-indent-1\">کیفیت خواب</li><li class=\"ql-indent-1\">میزان بار مطالعاتی</li><li class=\"ql-indent-1\">تعداد دفعات ورزش در هفته</li><li class=\"ql-indent-1\">سطح استرس</li><li><strong>Sports Statistics (DFKI):</strong> داده‌های آماری حوزه ورزش، مانند فوتبال.</li></ul><p><strong>نکته:</strong> تصویر ارائه شده (سایدبار برنامه Oculis) یک مثال عمومی از رابط کاربری است و ارتباط مستقیمی با محتوای سخنرانی ندارد، اما ممکن است به عنوان یک نمونه بصری از سازماندهی اطلاعات در یک سیستم داده‌محور در نظر گرفته شود.</p>','completed','2025-12-02 20:21:17','2025-12-03 04:33:26',NULL,NULL,0,NULL,1,NULL),(69,7,1,'_⁨داده کاوی⁩',NULL,NULL,NULL,'processing','2025-12-02 20:46:27','2025-12-02 20:46:27',NULL,NULL,0,NULL,1,NULL),(70,5,1,'رمزنگاری نامتقارن و الگوریتم RSA – چالش‌ها و کاربردها','1404/09/05','<div style=\"max-width: 100%; overflow-x: hidden; word-wrap: break-word; padding: 1rem; box-sizing: border-box;\"><div style=\"max-width: 100%; overflow-x: hidden; word-wrap: break-word; padding: 1rem; box-sizing: border-box;\"><h1>مقدمه‌ای بر رمزنگاری نامتقارن و چالش‌ها</h1><p>در جلسات قبل در مورد رمزنگاری نامتقارن صحبت کردیم. یکی از نکات مهم این بود که وقتی شما کلید عمومی خود را در اختیار عموم قرار می‌دهید، چگونه می‌توان اطمینان حاصل کرد که این کلید واقعاً متعلق به شماست و نه شخص دیگری که خودش را جای شما جا زده است؟</p><h2>مثال سناریوی حمله Man-in-the-Middle</h2><p>فرض کنید من می‌خواهم پیامی را برای بردیار بفرستم. بردیار کلید عمومی خود را در اختیار عموم قرار می‌دهد. من کلید عمومی بردیار را می‌گیرم، پیامم را با آن رمز می‌کنم و خیالم راحت است که فقط بردیار می‌تواند آن را با کلید خصوصی‌اش باز کند. از طرفی، اگر بردیار بخواهد به من جواب دهد، پیام را با کلید خصوصی خودش رمز می‌کند و من با کلید عمومی خودم آن را باز می‌کنم. این یک فرآیند ساده و کارآمد است.</p><p>اما نکته اصلی اینجاست: وقتی من به بردیار پیام می‌دهم، از کجا مطمئنم که این کلید عمومی که به دست من رسیده، واقعاً مال بردیار است؟ شاید آیدین خودش را جای بردیار جا زده و کلید عمومی خودش را به من داده باشد. در این صورت، من پیام را با کلید عمومی آیدین رمز می‌کنم و آیدین به راحتی آن را باز می‌کند و به محتوای پیام من دسترسی پیدا می‌کند. این همان حمله \'Man-in-the-Middle\' است.</p><p>مشکل این است که ما فکر می‌کنیم امنیت رمزنگاری نامتقارن کامل است، در حالی که اینطور نیست. مسئله توزیع کلید در رمزنگاری نامتقارن برطرف شده است، اما مشکل این است که چطور مطمئن شویم کلید عمومی لزوماً متعلق به شخصی است که ادعا می‌کند. این توضیحات نشان می‌دهد که توزیع کلید آسان‌تر شده، اما همچنان ما مطمئن نیستیم که کلید متعلق به چه کسی است. این‌ها سوالاتی است که باید پرسیده شود.</p><h2>کاربردهای رمزنگاری نامتقارن</h2><p>کاربردهای رمزنگاری نامتقارن چیست؟ نام ببرید.</p><ul><li><b>امضای دیجیتال (Digital Signature):</b> این کاربرد به ما اطمینان می‌دهد که فرستنده پیام، همان کسی است که ادعا می‌کند و همچنین از عدم انکار (Non-repudiation) اطمینان حاصل می‌کند. یعنی فرستنده نمی‌تواند بعداً منکر ارسال پیام شود.</li><li><b>توزیع کلید (Key Distribution):</b> رمزنگاری نامتقارن به حل مشکل توزیع کلیدهای متقارن کمک می‌کند.</li></ul><p>این‌ها چیزهایی است که از شما پرسیده می‌شود.</p><h2>محدودیت‌ها و حملات</h2><p>یکی از حملاتی که به رمزنگاری کلید عمومی می‌زنند، حمله Brute-Force است که سعی می‌کنند کلید خصوصی را از کلید عمومی محاسبه کنند. نکته مهم این است که هنوز اثبات نشده که ما نمی‌توانیم از کلید عمومی به کلید خصوصی برسیم. همچنین ثابت هم نشده که می‌شود. یعنی هنوز کسی نتوانسته این مسئله را حل کند، اما اثبات هم نشده که نمی‌شود. این نکته بسیار مهمی است. اگر کسی بتواند این کار را انجام دهد، یا جایزه خیلی زیادی می‌برد یا اگر بخواهد خصمانه از آن استفاده کند، می‌تواند کارهای زیادی انجام دهد.</p><h2>الگوریتم RSA</h2><p>الگوریتم RSA در دانشگاه MIT ساخته شده و مشهورترین و پرکاربردترین الگوریتم رمزنگاری کلید عمومی است. این الگوریتم مبتنی بر توان‌رسانی پیمانه‌ای (Modular Exponentiation) و استفاده از اعداد طبیعی خیلی بزرگ است. امنیت آن ناشی از دشوار بودن تجزیه اعداد بزرگ (حاصل‌ضرب دو عامل اول بزرگ) می‌باشد. استانداردهای مربوط به آن تحت عنوان PKCS (Public Key Cryptography Standards) استاندارد شده است.</p><h3>نحوه عملکرد RSA</h3><p>الگوریتم RSA چگونه انجام می‌شود؟</p><ul><li><p>یک پیمانه محاسبه داریم که <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">n</code> است.</p></li><li><p>یک <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">e</code> داریم که نمای رمزگذاری (Encryption Exponent) است.</p></li><li><p>یک <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">d</code> داریم که نمای رمزگشایی (Decryption Exponent) است.</p></li><li><p><code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">M</code> هم که پیام اصلی ماست (یک عدد صحیح).</p></li><li><p><code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">C</code> هم که پیام رمز شده (Ciphertext) است.</p></li></ul><p>تابع RSA یک تابع یک‌طرفه است:</p><pre style=\"white-space: pre-wrap !important; word-wrap: break-word !important; overflow-x: auto !important; max-width: 100% !important; padding: 1rem; background-color: #f5f5f5; border-radius: 4px; direction: ltr; font-family: \'Courier New\', monospace; font-size: 0.9em; line-height: 1.5; margin: 1rem 0;white-space: pre-wrap !important; word-wrap: break-word !important; overflow-x: auto !important; max-width: 100% !important; padding: 1rem; background-color: #f5f5f5; border-radius: 4px; direction: ltr; font-family: \'Courier New\', monospace; font-size: 0.9em; line-height: 1.5; margin: 1rem 0;\"><code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; display: block; overflow-x: auto; font-family: \'Courier New\', monospace;white-space: pre-wrap !important; word-wrap: break-word !important; display: block; overflow-x: auto; font-family: \'Courier New\', monospace;\">C = M^e mod n</code></pre><p>و تابع معکوس آن که رمزگشایی است:</p><pre style=\"white-space: pre-wrap !important; word-wrap: break-word !important; overflow-x: auto !important; max-width: 100% !important; padding: 1rem; background-color: #f5f5f5; border-radius: 4px; direction: ltr; font-family: \'Courier New\', monospace; font-size: 0.9em; line-height: 1.5; margin: 1rem 0;white-space: pre-wrap !important; word-wrap: break-word !important; overflow-x: auto !important; max-width: 100% !important; padding: 1rem; background-color: #f5f5f5; border-radius: 4px; direction: ltr; font-family: \'Courier New\', monospace; font-size: 0.9em; line-height: 1.5; margin: 1rem 0;\"><code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; display: block; overflow-x: auto; font-family: \'Courier New\', monospace;white-space: pre-wrap !important; word-wrap: break-word !important; display: block; overflow-x: auto; font-family: \'Courier New\', monospace;\">M = C^d mod n</code></pre><h3>مفاهیم ریاضی مورد نیاز (پیش‌نمایش برای جلسه بعد)</h3><p>برای درک کامل RSA، نیاز به یادآوری چند مفهوم ریاضی داریم:</p><ul><li><p><b>هم‌نهشتی (Congruence):</b> مفهوم <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">mod</code>.</p></li><li><p><b>اعداد اول (Prime Numbers):</b> <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">p</code> و <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">q</code> دو عدد اول بزرگ هستند که <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">n = p * q</code>.</p></li><li><p><b>تابع اویلر (Euler\'s Totient Function یا Phi Function):</b> <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">φ(n)</code></p><ul><li><p>تعریف: تعداد اعداد کوچک‌تر از <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">n</code> که نسبت به <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">n</code> اول هستند (یعنی بزرگترین مقسوم‌علیه مشترکشان با <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">n</code>، یک است).</p></li><li><p>اگر <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">n = p * q</code> باشد (که <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">p</code> و <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">q</code> اعداد اول هستند)، آنگاه <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">φ(n) = (p-1)(q-1)</code>.</p></li><li><p>مثال: <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">φ(8)</code> = 4 (اعداد 1، 3، 5، 7 نسبت به 8 اول هستند). <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">φ(6)</code> = 2 (اعداد 1، 5 نسبت به 6 اول هستند).</p></li></ul></li><li><p><b>بزرگترین مقسوم‌علیه مشترک (GCD):</b> دو عدد نسبت به هم اول هستند اگر <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">GCD</code> آن‌ها 1 باشد.</p></li><li><p><b>اصل لانه کبوتری (Pigeonhole Principle):</b> این اصل به عنوان یک ابزار مفهومی برای اثبات برخی ویژگی‌ها استفاده می‌شود.</p></li></ul><p>کلید عمومی شما می‌شود <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">(e, n)</code> و کلید خصوصی شما می‌شود <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">(d, n)</code>. <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">e</code> و <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">d</code> با استفاده از <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">φ(n)</code> محاسبه می‌شوند. <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">e</code> عددی است که باید <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">1 &lt; e &lt; φ(n)</code> باشد و <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">GCD(e, φ(n)) = 1</code>. <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">d</code> نیز به گونه‌ای محاسبه می‌شود که <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">(d * e) mod φ(n) = 1</code>.</p><h2>اطلاعیه‌های آموزشی</h2><p>از امروز تا آخر ترم، هر جلسه از شما کوئیز می‌گیرم. نمره میان‌ترم شما احتمالاً 10 نمره، 6 نمره، 8 نمره یا هر عددی که باشد، از مجموع نمرات کوئیزهای شما تشکیل می‌شود. این کار برای این است که شما به صورت مستمر درس را دنبال کنید و مطالب را فراموش نکنید. هر جلسه یک سوال مشترک با جواب‌های کاملاً متفاوت خواهید داشت.</p><p>عکس گرفتن از اسلایدها ایرادی ندارد.</p><p>لطفاً برای جلسه بعد، مفاهیم اعداد اول، هم‌نهشتی، GCD و تابع اویلر را مرور کنید.</p></div></div>','<h1>مقدمه‌ای بر رمزنگاری نامتقارن و چالش‌ها</h1><p>در جلسات قبل در مورد رمزنگاری نامتقارن صحبت کردیم. یکی از نکات مهم این بود که وقتی شما کلید عمومی خود را در اختیار عموم قرار می‌دهید، چگونه می‌توان اطمینان حاصل کرد که این کلید واقعاً متعلق به شماست و نه شخص دیگری که خودش را جای شما جا زده است؟</p><h2>مثال سناریوی حمله Man-in-the-Middle</h2><p>فرض کنید من می‌خواهم پیامی را برای بردیار بفرستم. بردیار کلید عمومی خود را در اختیار عموم قرار می‌دهد. من کلید عمومی بردیار را می‌گیرم، پیامم را با آن رمز می‌کنم و خیالم راحت است که فقط بردیار می‌تواند آن را با کلید خصوصی‌اش باز کند. از طرفی، اگر بردیار بخواهد به من جواب دهد، پیام را با کلید خصوصی خودش رمز می‌کند و من با کلید عمومی خودم آن را باز می‌کنم. این یک فرآیند ساده و کارآمد است.</p><p>اما نکته اصلی اینجاست: وقتی من به بردیار پیام می‌دهم، از کجا مطمئنم که این کلید عمومی که به دست من رسیده، واقعاً مال بردیار است؟ شاید آیدین خودش را جای بردیار جا زده و کلید عمومی خودش را به من داده باشد. در این صورت، من پیام را با کلید عمومی آیدین رمز می‌کنم و آیدین به راحتی آن را باز می‌کند و به محتوای پیام من دسترسی پیدا می‌کند. این همان حمله \'Man-in-the-Middle\' است.</p><p>مشکل این است که ما فکر می‌کنیم امنیت رمزنگاری نامتقارن کامل است، در حالی که اینطور نیست. مسئله توزیع کلید در رمزنگاری نامتقارن برطرف شده است، اما مشکل این است که چطور مطمئن شویم کلید عمومی لزوماً متعلق به شخصی است که ادعا می‌کند. این توضیحات نشان می‌دهد که توزیع کلید آسان‌تر شده، اما همچنان ما مطمئن نیستیم که کلید متعلق به چه کسی است. این‌ها سوالاتی است که باید پرسیده شود.</p><h2>کاربردهای رمزنگاری نامتقارن</h2><p>کاربردهای رمزنگاری نامتقارن چیست؟ نام ببرید.</p><ul><li><strong>امضای دیجیتال (Digital Signature):</strong> این کاربرد به ما اطمینان می‌دهد که فرستنده پیام، همان کسی است که ادعا می‌کند و همچنین از عدم انکار (Non-repudiation) اطمینان حاصل می‌کند. یعنی فرستنده نمی‌تواند بعداً منکر ارسال پیام شود.</li><li><strong>توزیع کلید (Key Distribution):</strong> رمزنگاری نامتقارن به حل مشکل توزیع کلیدهای متقارن کمک می‌کند.</li></ul><p>این‌ها چیزهایی است که از شما پرسیده می‌شود.</p><h2>محدودیت‌ها و حملات</h2><p>یکی از حملاتی که به رمزنگاری کلید عمومی می‌زنند، حمله Brute-Force است که سعی می‌کنند کلید خصوصی را از کلید عمومی محاسبه کنند. نکته مهم این است که هنوز اثبات نشده که ما نمی‌توانیم از کلید عمومی به کلید خصوصی برسیم. همچنین ثابت هم نشده که می‌شود. یعنی هنوز کسی نتوانسته این مسئله را حل کند، اما اثبات هم نشده که نمی‌شود. این نکته بسیار مهمی است. اگر کسی بتواند این کار را انجام دهد، یا جایزه خیلی زیادی می‌برد یا اگر بخواهد خصمانه از آن استفاده کند، می‌تواند کارهای زیادی انجام دهد.</p><h2>الگوریتم RSA</h2><p>الگوریتم RSA در دانشگاه MIT ساخته شده و مشهورترین و پرکاربردترین الگوریتم رمزنگاری کلید عمومی است. این الگوریتم مبتنی بر توان‌رسانی پیمانه‌ای (Modular Exponentiation) و استفاده از اعداد طبیعی خیلی بزرگ است. امنیت آن ناشی از دشوار بودن تجزیه اعداد بزرگ (حاصل‌ضرب دو عامل اول بزرگ) می‌باشد. استانداردهای مربوط به آن تحت عنوان PKCS (Public Key Cryptography Standards) استاندارد شده است.</p><h3>نحوه عملکرد RSA</h3><p>الگوریتم RSA چگونه انجام می‌شود؟</p><ul><li>یک پیمانه محاسبه داریم که <code>n</code> است.</li><li>یک <code>e</code> داریم که نمای رمزگذاری (Encryption Exponent) است.</li><li>یک <code>d</code> داریم که نمای رمزگشایی (Decryption Exponent) است.</li><li><code>M</code> هم که پیام اصلی ماست (یک عدد صحیح).</li><li><code>C</code> هم که پیام رمز شده (Ciphertext) است.</li></ul><p>تابع RSA یک تابع یک‌طرفه است:</p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">C = M^e mod n\n</pre><p>و تابع معکوس آن که رمزگشایی است:</p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">M = C^d mod n\n</pre><h3>مفاهیم ریاضی مورد نیاز (پیش‌نمایش برای جلسه بعد)</h3><p>برای درک کامل RSA، نیاز به یادآوری چند مفهوم ریاضی داریم:</p><ul><li><strong>هم‌نهشتی (Congruence):</strong> مفهوم <code>mod</code>.</li><li><strong>اعداد اول (Prime Numbers):</strong> <code>p</code> و <code>q</code> دو عدد اول بزرگ هستند که <code>n = p * q</code>.</li><li><strong>تابع اویلر (Euler\'s Totient Function یا Phi Function):</strong> <code>φ(n)</code></li><li class=\"ql-indent-1\">تعریف: تعداد اعداد کوچک‌تر از <code>n</code> که نسبت به <code>n</code> اول هستند (یعنی بزرگترین مقسوم‌علیه مشترکشان با <code>n</code>، یک است).</li><li class=\"ql-indent-1\">اگر <code>n = p * q</code> باشد (که <code>p</code> و <code>q</code> اعداد اول هستند)، آنگاه <code>φ(n) = (p-1)(q-1)</code>.</li><li class=\"ql-indent-1\">مثال: <code>φ(8)</code> = 4 (اعداد 1، 3، 5، 7 نسبت به 8 اول هستند). <code>φ(6)</code> = 2 (اعداد 1، 5 نسبت به 6 اول هستند).</li><li><strong>بزرگترین مقسوم‌علیه مشترک (GCD):</strong> دو عدد نسبت به هم اول هستند اگر <code>GCD</code> آن‌ها 1 باشد.</li><li><strong>اصل لانه کبوتری (Pigeonhole Principle):</strong> این اصل به عنوان یک ابزار مفهومی برای اثبات برخی ویژگی‌ها استفاده می‌شود.</li></ul><p>کلید عمومی شما می‌شود <code>(e, n)</code> و کلید خصوصی شما می‌شود <code>(d, n)</code>. <code>e</code> و <code>d</code> با استفاده از <code>φ(n)</code> محاسبه می‌شوند. <code>e</code> عددی است که باید <code>1 &lt; e &lt; φ(n)</code> باشد و <code>GCD(e, φ(n)) = 1</code>. <code>d</code> نیز به گونه‌ای محاسبه می‌شود که <code>(d * e) mod φ(n) = 1</code>.</p><h2>اطلاعیه‌های آموزشی</h2><p>از امروز تا آخر ترم، هر جلسه از شما کوئیز می‌گیرم. نمره میان‌ترم شما احتمالاً 10 نمره، 6 نمره، 8 نمره یا هر عددی که باشد، از مجموع نمرات کوئیزهای شما تشکیل می‌شود. این کار برای این است که شما به صورت مستمر درس را دنبال کنید و مطالب را فراموش نکنید. هر جلسه یک سوال مشترک با جواب‌های کاملاً متفاوت خواهید داشت.</p><p>عکس گرفتن از اسلایدها ایرادی ندارد.</p><p>لطفاً برای جلسه بعد، مفاهیم اعداد اول، هم‌نهشتی، GCD و تابع اویلر را مرور کنید.</p>','completed','2025-12-03 04:08:48','2025-12-03 07:12:56',NULL,NULL,0,NULL,1,NULL),(71,7,1,'نمایش، انواع و منابع داده‌ها در داده‌کاوی','1404/07/07','<div style=\"max-width: 100%; overflow-x: hidden; word-wrap: break-word; padding: 1rem; box-sizing: border-box;\"><h1>نمایش، انواع و منابع داده‌ها در داده‌کاوی</h1><p>در این جلسه به بررسی روش‌های مختلف نمایش داده‌ها، انواع داده‌ها و منابعی که می‌توانیم داده‌ها را از آن‌ها جمع‌آوری کنیم، می‌پردازیم.</p><h2>نمایش داده‌های گراف</h2><h3>ماتریس همسایگی (Adjacency Matrix)</h3><p>این یک ماتریس همسایگی است که از جنس «very sparse, very wasteful, but useful conceptually» می‌باشد. یعنی ممکن است خیلی بزرگ باشد و عناصر آن صفر یا خالی باشند، اما برای مفهوم‌سازی بسیار مفید و کاربردی است. این روش در مواردی مانند Google Maps نیز به همین صورت استفاده می‌شود.</p><ul><li><strong>مزایا:</strong> دسترسی سریع به ارتباطات بین گره‌ها.</li><li><strong>معایب:</strong></li><ul><li>مصرف زیاد حافظه برای گراف‌های تنک (sparse) با تعداد زیادی صفر.</li><li>نگهداری (maintenance) آن در حافظه دشوارتر است.</li></ul></ul><h3>لیست همسایگی (Adjacency List)</h3><p>این روش نمایش، مجموعه داده‌ها را به صورت یک لیست همسایگی نشان می‌دهد. در مقایسه با ماتریس همسایگی، هر گره یک لیست از گره‌های همسایه خود دارد.</p><ul><li><strong>مثال:</strong></li><ul><li>گره ۱ با گره ۲ و ۳ ارتباط مستقیم دارد.</li><li>گره ۲ با گره ۱ و ۳ ارتباط مستقیم دارد.</li><li>گره ۳ با گره ۴، ۱ و ۲ ارتباط مستقیم دارد.</li></ul><li><strong>سازماندهی:</strong> اگر بخواهیم لیست همسایگی را مرتب (sort) کنیم (مثلاً به ترتیب صعودی)، کارایی بهتری خواهد داشت.</li><li><strong>مزایا:</strong></li><ul><li>صرفه‌جویی در فضا (حافظه) نسبت به ماتریس همسایگی، خصوصاً برای گراف‌های تنک.</li><li>مناسب برای نگهداری (maintenance) و پشتیبانی.</li></ul><li><strong>معایب:</strong></li><ul><li>جستجو و مقایسه در آن ممکن است به جستجوی مجدد در مجموعه داده نیاز داشته باشد.</li><li>«Not so easy to maintain» (نگهداری و تغییرات در آن به آسانی ماتریس نیست).</li></ul></ul><h3>لیست جفت‌ها (List of Pairs)</h3><p>این نیز یک نمایش دیگر از داده‌های گراف است که به صورت جفت‌های (node1, node2) نشان داده می‌شود. این روش اغلب ساده‌ترین و کارآمدترین نمایش است.</p><ul><li><strong>مثال:</strong> (۱,۲), (۲,۳), (۳,۴), (۴,۵), (۱,۳)</li><li><strong>مزایا:</strong></li><ul><li>ساده و کارآمد، خصوصاً برای گراف‌هایی که تعداد ارتباطات (یال‌ها) زیاد نیست.</li><li>صرفه‌جویی در فضای ذخیره‌سازی.</li></ul></ul><h3>مقایسه و کاربردها</h3><p>انتخاب روش نمایش بستگی به کاربرد دارد. برای مثال، در شبکه‌های اجتماعی مانند توییتر که تعداد کاربران (گره‌ها) به میلیاردها می‌رسد (مثلاً ۲ میلیارد کاربر فعال فیسبوک، بیش از ۲ میلیارد اکانت)، استفاده از ماتریس همسایگی با ابعاد ۲ میلیارد در ۲ میلیارد، منجر به ماتریسی با ۴ و ۱۸ صفر می‌شود که بسیار بزرگ و غیرقابل مدیریت است. در چنین مواردی، روش‌هایی مانند لیست همسایگی یا لیست جفت‌ها مناسب‌تر هستند زیرا فضای کمتری اشغال می‌کنند و مدیریت ارتباطات فعال را آسان‌تر می‌کنند.</p><p>در حوزه‌هایی مانند شیمی، ساختار شیمیایی عناصر (مانند هیدروژن با اکسیژن) نیز می‌تواند به صورت گراف نمایش داده شود. در اینجا، تعداد ساختارها زیاد است اما ترکیبات آن‌ها (اتصالات) محدود است، بنابراین نمایش به صورت لیست جفت‌ها می‌تواند بسیار کاربردی باشد.</p><h2>انواع داده‌ها</h2><p>داده‌ها انواع مختلفی دارند که معمولاً به دو دسته اصلی تقسیم می‌شوند:</p><ul><li><strong>داده‌های عددی (Numerical Data):</strong> این داده‌ها معمولاً سعی می‌شود به صورت عددی نگهداری شوند، زیرا مقایسه، تصمیم‌گیری، عملیات محاسباتی و فرمول‌های آماری روی اعداد بسیار راحت‌تر پیاده‌سازی می‌شوند. بسیاری از اوقات، داده‌های متنی (text)، کلمه (word) یا رشته (string) به عدد تبدیل شده و سپس محاسبات روی آن‌ها انجام می‌شود.</li><li><strong>داده‌های غیرعددی (Non-Numerical Data):</strong></li></ul><p>انواع دیگر داده‌ها که می‌توانیم تصور کنیم عبارتند از:</p><ul><li><strong>Nominal Data:</strong> داده‌هایی که فقط نام دارند و ترتیب یا مقداری ندارند.</li><li><strong>Categorical Data (طبقه‌بندی شده):</strong> داده‌هایی که در دسته‌های مشخصی قرار می‌گیرند.</li><ul><li><strong>مثال:</strong> رنگ چشم (مشکی، قهوه‌ای، آبی)، رنگ مو، کیفیت محصول (خوب، بد، متوسط)، کد پستی، کد شهر، کد تلفن.</li></ul><li><strong>Set Data:</strong> مجموعه‌ای از داده‌ها بدون ترتیب خاص.</li><li><strong>Ordered Sequence Data (ترتیبی):</strong> داده‌هایی که دارای ترتیب زمانی یا منطقی هستند.</li><ul><li><strong>مثال:</strong> افزایش یا کاهش قیمت یک کالا در بورس، تغییرات دمای هوا در یک بازه زمانی، میزان جمعیت یک کشور در طول سالیان متمادی (مثلاً از سال ۱۳۸۰ تا ۱۴۰۰ برای بررسی نرخ رشد جمعیت).</li></ul><li><strong>Graph Data:</strong> داده‌هایی که به صورت گره‌ها و یال‌ها (ارتباطات) نمایش داده می‌شوند.</li></ul><p>داده‌های عددی نیز خود به دو دسته پیوسته (continuous) و گسسته (discrete) تقسیم می‌شوند. بسته به نوع داده (ترتیبی، ستی، طبقه‌بندی شده، عددی)، الگوریتم‌های مختلفی برای تحلیل و پردازش آن‌ها استفاده می‌شود.</p><h2>منابع داده‌ها (Dataset Sources)</h2><p>برای انجام تحلیل و آنالیز داده‌ها، نیاز به جمع‌آوری داده‌ها از منابع معتبر و استاندارد داریم. برخی از این منابع عبارتند از:</p><ul><li><strong>Kaggle:</strong> یک پلتفرم معروف برای مسابقات و دیتاست‌های یادگیری ماشین و تحلیل داده.</li><li><strong>UCI Machine Learning Repository:</strong> مخزن داده‌های یادگیری ماشین دانشگاه کالیفرنیا، ارواین (UCI) که شامل دیتاست‌های مختلفی مانند Iris، Heart Disease و Bank Marketing است.</li><li><strong>Google Dataset Search:</strong> موتور جستجوی گوگل برای دیتاست‌ها که امکان یافتن داده‌های مربوط به تصویر، ویدئو، صوت، متن و رباتیک را فراهم می‌کند.</li><li><strong>KDD (Knowledge Discovery Nugget):</strong> یک منبع خوب برای یافتن دیتاست‌های مناسب در حوزه تحلیل داده.</li><li><strong>سایر منابع:</strong> سایت‌های تخصصی دیگر که دیتاست‌های خاصی را در حوزه‌های مختلف (مانند Student Stress Level Dataset، Sports Statistics، Web Data Common) ارائه می‌دهند.</li></ul><p><strong>مثال دیتاست Bank Marketing (از UCI):</strong></p><ul><li><strong>هدف:</strong> پیش‌بینی اینکه آیا یک مشتری در یک کمپین بازاریابی مستقیم بانک، برای سپرده مدت‌دار (term deposit) ثبت‌نام می‌کند یا خیر.</li><li><strong>تعداد نمونه‌ها:</strong> ۴۵,۲۱۸</li><li><strong>حوزه داده:</strong> کسب‌وکار (Business)</li><li><strong>وظیفه:</strong> طبقه‌بندی (Classification)</li><li><strong>ویژگی‌ها:</strong> ۱۶ ویژگی/صفت</li><li><strong>نوع ویژگی‌ها:</strong> دسته‌ای (Categorical) و عددی صحیح (Integer)</li><li><strong>برخی از ویژگی‌ها:</strong></li><ul><li><strong>Age:</strong> سن (Integer)</li><li><strong>Job:</strong> شغل (Categorical: دانشجو، کارمند، تکنسین و غیره)</li><li><strong>Marital:</strong> وضعیت تأهل (Categorical: متأهل، مجرد، مطلقه)</li><li><strong>Education:</strong> تحصیلات (Categorical: مقدماتی، دبیرستان، بی‌سواد)</li><li><strong>Default:</strong> آیا اعتبار پیش‌فرض دارد (باینری: ۰ یا ۱)</li><li><strong>Balance:</strong> میزان موجودی (Integer)</li><li><strong>Average Yearly Balance:</strong> میانگین موجودی سالانه (Integer)</li><li><strong>Housing:</strong> آیا مسکن دارد (باینری: ۰ یا ۱)</li></ul></ul><p><strong>مثال دیتاست Student Stress Level (از Kaggle):</strong></p><ul><li><strong>هدف:</strong> تحلیل سطح استرس دانش‌آموزان.</li><li><strong>تعداد ویژگی‌ها:</strong> ۶ ویژگی.</li><li><strong>برخی از ویژگی‌ها:</strong></li><ul><li>تعداد دفعاتی که در هفته از چیزی رنج می‌برید.</li><li>کیفیت خواب.</li><li>میزان بار مطالعاتی.</li><li>تعداد دفعات ورزش در هفته.</li><li>میزان سطح استرس.</li></ul></ul><p><strong>اهمیت دیتاست‌های استاندارد:</strong></p><p>جمع‌آوری و ایجاد دیتاست با فرمت‌های استاندارد (مانند CSV، XML، JSON) خود یک مرحله مهم در حوزه داده‌کاوی است. صرفاً انتخاب و ذخیره اطلاعات با ویژگی‌های دلخواه، به معنای قابلیت استفاده آن در حوزه‌های مختلف داده‌کاوی نیست. دیتاست‌ها باید معتبر و استاندارد باشند تا بتوانند در تحلیل‌ها و مدل‌سازی‌های دقیق به کار روند.</p></div>','<div style=\"max-width: 100%; overflow-x: hidden; word-wrap: break-word; padding: 1rem; box-sizing: border-box;\"><h1>نمایش، انواع و منابع داده‌ها در داده‌کاوی</h1><p>در این جلسه به بررسی روش‌های مختلف نمایش داده‌ها، انواع داده‌ها و منابعی که می‌توانیم داده‌ها را از آن‌ها جمع‌آوری کنیم، می‌پردازیم.</p><h2>نمایش داده‌های گراف</h2><h3>ماتریس همسایگی (Adjacency Matrix)</h3><p>این یک ماتریس همسایگی است که از جنس «very sparse, very wasteful, but useful conceptually» می‌باشد. یعنی ممکن است خیلی بزرگ باشد و عناصر آن صفر یا خالی باشند، اما برای مفهوم‌سازی بسیار مفید و کاربردی است. این روش در مواردی مانند Google Maps نیز به همین صورت استفاده می‌شود.</p><ul><li><strong>مزایا:</strong> دسترسی سریع به ارتباطات بین گره‌ها.</li><li><strong>معایب:</strong></li><ul><li>مصرف زیاد حافظه برای گراف‌های تنک (sparse) با تعداد زیادی صفر.</li><li>نگهداری (maintenance) آن در حافظه دشوارتر است.</li></ul></ul><h3>لیست همسایگی (Adjacency List)</h3><p>این روش نمایش، مجموعه داده‌ها را به صورت یک لیست همسایگی نشان می‌دهد. در مقایسه با ماتریس همسایگی، هر گره یک لیست از گره‌های همسایه خود دارد.</p><ul><li><strong>مثال:</strong></li><ul><li>گره ۱ با گره ۲ و ۳ ارتباط مستقیم دارد.</li><li>گره ۲ با گره ۱ و ۳ ارتباط مستقیم دارد.</li><li>گره ۳ با گره ۴، ۱ و ۲ ارتباط مستقیم دارد.</li></ul><li><strong>سازماندهی:</strong> اگر بخواهیم لیست همسایگی را مرتب (sort) کنیم (مثلاً به ترتیب صعودی)، کارایی بهتری خواهد داشت.</li><li><strong>مزایا:</strong></li><ul><li>صرفه‌جویی در فضا (حافظه) نسبت به ماتریس همسایگی، خصوصاً برای گراف‌های تنک.</li><li>مناسب برای نگهداری (maintenance) و پشتیبانی.</li></ul><li><strong>معایب:</strong></li><ul><li>جستجو و مقایسه در آن ممکن است به جستجوی مجدد در مجموعه داده نیاز داشته باشد.</li><li>«Not so easy to maintain» (نگهداری و تغییرات در آن به آسانی ماتریس نیست).</li></ul></ul><h3>لیست جفت‌ها (List of Pairs)</h3><p>این نیز یک نمایش دیگر از داده‌های گراف است که به صورت جفت‌های (node1, node2) نشان داده می‌شود. این روش اغلب ساده‌ترین و کارآمدترین نمایش است.</p><ul><li><strong>مثال:</strong> (۱,۲), (۲,۳), (۳,۴), (۴,۵), (۱,۳)</li><li><strong>مزایا:</strong></li><ul><li>ساده و کارآمد، خصوصاً برای گراف‌هایی که تعداد ارتباطات (یال‌ها) زیاد نیست.</li><li>صرفه‌جویی در فضای ذخیره‌سازی.</li></ul></ul><h3>مقایسه و کاربردها</h3><p>انتخاب روش نمایش بستگی به کاربرد دارد. برای مثال، در شبکه‌های اجتماعی مانند توییتر که تعداد کاربران (گره‌ها) به میلیاردها می‌رسد (مثلاً ۲ میلیارد کاربر فعال فیسبوک، بیش از ۲ میلیارد اکانت)، استفاده از ماتریس همسایگی با ابعاد ۲ میلیارد در ۲ میلیارد، منجر به ماتریسی با ۴ و ۱۸ صفر می‌شود که بسیار بزرگ و غیرقابل مدیریت است. در چنین مواردی، روش‌هایی مانند لیست همسایگی یا لیست جفت‌ها مناسب‌تر هستند زیرا فضای کمتری اشغال می‌کنند و مدیریت ارتباطات فعال را آسان‌تر می‌کنند.</p><p>در حوزه‌هایی مانند شیمی، ساختار شیمیایی عناصر (مانند هیدروژن با اکسیژن) نیز می‌تواند به صورت گراف نمایش داده شود. در اینجا، تعداد ساختارها زیاد است اما ترکیبات آن‌ها (اتصالات) محدود است، بنابراین نمایش به صورت لیست جفت‌ها می‌تواند بسیار کاربردی باشد.</p><h2>انواع داده‌ها</h2><p>داده‌ها انواع مختلفی دارند که معمولاً به دو دسته اصلی تقسیم می‌شوند:</p><ul><li><strong>داده‌های عددی (Numerical Data):</strong> این داده‌ها معمولاً سعی می‌شود به صورت عددی نگهداری شوند، زیرا مقایسه، تصمیم‌گیری، عملیات محاسباتی و فرمول‌های آماری روی اعداد بسیار راحت‌تر پیاده‌سازی می‌شوند. بسیاری از اوقات، داده‌های متنی (text)، کلمه (word) یا رشته (string) به عدد تبدیل شده و سپس محاسبات روی آن‌ها انجام می‌شود.</li><li><strong>داده‌های غیرعددی (Non-Numerical Data):</strong></li></ul><p>انواع دیگر داده‌ها که می‌توانیم تصور کنیم عبارتند از:</p><ul><li><strong>Nominal Data:</strong> داده‌هایی که فقط نام دارند و ترتیب یا مقداری ندارند.</li><li><strong>Categorical Data (طبقه‌بندی شده):</strong> داده‌هایی که در دسته‌های مشخصی قرار می‌گیرند.</li><ul><li><strong>مثال:</strong> رنگ چشم (مشکی، قهوه‌ای، آبی)، رنگ مو، کیفیت محصول (خوب، بد، متوسط)، کد پستی، کد شهر، کد تلفن.</li></ul><li><strong>Set Data:</strong> مجموعه‌ای از داده‌ها بدون ترتیب خاص.</li><li><strong>Ordered Sequence Data (ترتیبی):</strong> داده‌هایی که دارای ترتیب زمانی یا منطقی هستند.</li><ul><li><strong>مثال:</strong> افزایش یا کاهش قیمت یک کالا در بورس، تغییرات دمای هوا در یک بازه زمانی، میزان جمعیت یک کشور در طول سالیان متمادی (مثلاً از سال ۱۳۸۰ تا ۱۴۰۰ برای بررسی نرخ رشد جمعیت).</li></ul><li><strong>Graph Data:</strong> داده‌هایی که به صورت گره‌ها و یال‌ها (ارتباطات) نمایش داده می‌شوند.</li></ul><p>داده‌های عددی نیز خود به دو دسته پیوسته (continuous) و گسسته (discrete) تقسیم می‌شوند. بسته به نوع داده (ترتیبی، ستی، طبقه‌بندی شده، عددی)، الگوریتم‌های مختلفی برای تحلیل و پردازش آن‌ها استفاده می‌شود.</p><h2>منابع داده‌ها (Dataset Sources)</h2><p>برای انجام تحلیل و آنالیز داده‌ها، نیاز به جمع‌آوری داده‌ها از منابع معتبر و استاندارد داریم. برخی از این منابع عبارتند از:</p><ul><li><strong>Kaggle:</strong> یک پلتفرم معروف برای مسابقات و دیتاست‌های یادگیری ماشین و تحلیل داده.</li><li><strong>UCI Machine Learning Repository:</strong> مخزن داده‌های یادگیری ماشین دانشگاه کالیفرنیا، ارواین (UCI) که شامل دیتاست‌های مختلفی مانند Iris، Heart Disease و Bank Marketing است.</li><li><strong>Google Dataset Search:</strong> موتور جستجوی گوگل برای دیتاست‌ها که امکان یافتن داده‌های مربوط به تصویر، ویدئو، صوت، متن و رباتیک را فراهم می‌کند.</li><li><strong>KDD (Knowledge Discovery Nugget):</strong> یک منبع خوب برای یافتن دیتاست‌های مناسب در حوزه تحلیل داده.</li><li><strong>سایر منابع:</strong> سایت‌های تخصصی دیگر که دیتاست‌های خاصی را در حوزه‌های مختلف (مانند Student Stress Level Dataset، Sports Statistics، Web Data Common) ارائه می‌دهند.</li></ul><p><strong>مثال دیتاست Bank Marketing (از UCI):</strong></p><ul><li><strong>هدف:</strong> پیش‌بینی اینکه آیا یک مشتری در یک کمپین بازاریابی مستقیم بانک، برای سپرده مدت‌دار (term deposit) ثبت‌نام می‌کند یا خیر.</li><li><strong>تعداد نمونه‌ها:</strong> ۴۵,۲۱۸</li><li><strong>حوزه داده:</strong> کسب‌وکار (Business)</li><li><strong>وظیفه:</strong> طبقه‌بندی (Classification)</li><li><strong>ویژگی‌ها:</strong> ۱۶ ویژگی/صفت</li><li><strong>نوع ویژگی‌ها:</strong> دسته‌ای (Categorical) و عددی صحیح (Integer)</li><li><strong>برخی از ویژگی‌ها:</strong></li><ul><li><strong>Age:</strong> سن (Integer)</li><li><strong>Job:</strong> شغل (Categorical: دانشجو، کارمند، تکنسین و غیره)</li><li><strong>Marital:</strong> وضعیت تأهل (Categorical: متأهل، مجرد، مطلقه)</li><li><strong>Education:</strong> تحصیلات (Categorical: مقدماتی، دبیرستان، بی‌سواد)</li><li><strong>Default:</strong> آیا اعتبار پیش‌فرض دارد (باینری: ۰ یا ۱)</li><li><strong>Balance:</strong> میزان موجودی (Integer)</li><li><strong>Average Yearly Balance:</strong> میانگین موجودی سالانه (Integer)</li><li><strong>Housing:</strong> آیا مسکن دارد (باینری: ۰ یا ۱)</li></ul></ul><p><strong>مثال دیتاست Student Stress Level (از Kaggle):</strong></p><ul><li><strong>هدف:</strong> تحلیل سطح استرس دانش‌آموزان.</li><li><strong>تعداد ویژگی‌ها:</strong> ۶ ویژگی.</li><li><strong>برخی از ویژگی‌ها:</strong></li><ul><li>تعداد دفعاتی که در هفته از چیزی رنج می‌برید.</li><li>کیفیت خواب.</li><li>میزان بار مطالعاتی.</li><li>تعداد دفعات ورزش در هفته.</li><li>میزان سطح استرس.</li></ul></ul><p><strong>اهمیت دیتاست‌های استاندارد:</strong></p><p>جمع‌آوری و ایجاد دیتاست با فرمت‌های استاندارد (مانند CSV، XML، JSON) خود یک مرحله مهم در حوزه داده‌کاوی است. صرفاً انتخاب و ذخیره اطلاعات با ویژگی‌های دلخواه، به معنای قابلیت استفاده آن در حوزه‌های مختلف داده‌کاوی نیست. دیتاست‌ها باید معتبر و استاندارد باشند تا بتوانند در تحلیل‌ها و مدل‌سازی‌های دقیق به کار روند.</p></div>','completed','2025-12-03 07:13:28','2025-12-03 07:14:40',NULL,NULL,0,NULL,1,NULL),(72,1,1,'مقدمه‌ای بر جنریک‌ها در جاوا','1404/09/09','<div style=\"max-width: 100%; overflow-x: hidden; word-wrap: break-word; padding: 1rem; box-sizing: border-box;\"><h1>مقدمه‌ای بر جنریک‌ها (Generics)</h1><p>ابتدا بررسی می‌کنیم که چرا به یک مفهوم جدید به نام جنریک (Generic) نیاز داریم.</p><h2>مثال اولیه: کلاس PrintInteger</h2><p>فرض کنید می‌خواهیم کلاسی داشته باشیم که داخل آن یک متد برای چاپ یک عدد صحیح (integer) وجود داشته باشد:</p><pre style=\"white-space: pre-wrap !important; word-wrap: break-word !important; overflow-x: auto !important; max-width: 100% !important; padding: 1rem; background-color: #f5f5f5; border-radius: 4px; direction: ltr; font-family: \'Courier New\', monospace; font-size: 0.9em; line-height: 1.5; margin: 1rem 0;\"><code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; display: block; overflow-x: auto; font-family: \'Courier New\', monospace;\">class PrintInteger {\n    int a;\n\n    public PrintInteger(int a) {\n        this.a = a;\n    }\n\n    public void printer() {\n        System.out.println(a);\n    }\n}\n</code></pre><p>برای ساخت یک شیء از این کلاس و استفاده از آن:</p><pre style=\"white-space: pre-wrap !important; word-wrap: break-word !important; overflow-x: auto !important; max-width: 100% !important; padding: 1rem; background-color: #f5f5f5; border-radius: 4px; direction: ltr; font-family: \'Courier New\', monospace; font-size: 0.9em; line-height: 1.5; margin: 1rem 0;\"><code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; display: block; overflow-x: auto; font-family: \'Courier New\', monospace;\">PrintInteger pi = new PrintInteger(3);\npi.printer(); // خروجی: 3\n</code></pre><h2>مشکل با انواع داده مختلف</h2><p>این کلاس تنها برای اعداد صحیح (<code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">int</code>) کار می‌کند. حال اگر بخواهیم عدد اعشاری (مثلاً <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">3.14</code>) یا انواع داده دیگر را چاپ کنیم، چه باید کرد؟</p><ul><li>**راه حل اول (ناکارآمد):** اضافه کردن کانستراکتورهای بیشتر برای هر نوع داده (مثلاً برای <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">double</code>، <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">float</code>، <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">String</code> و غیره). این کار باعث افزایش تعداد کانستراکتورها و پیچیدگی کد می‌شود.</li><li>**راه حل دوم (ناکارآمدتر):** ایجاد کلاس‌های جداگانه برای هر نوع داده (مثلاً <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">PrintDouble</code>، <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">PrintString</code>). این روش منجر به تکرار زیاد کد (Duplicate Code) می‌شود.</li></ul><p>این مشکل نه تنها برای انواع داده اولیه (primitive data types) مانند <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">int</code> و <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">double</code> وجود دارد، بلکه برای کلاس‌های تعریف‌شده توسط کاربر (مانند <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">Person</code>، <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">Student</code>، <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">Vehicle</code>) نیز صادق است. اگر بخواهیم یک شیء از کلاس <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">Person</code> را چاپ کنیم، مجبوریم همین تکرار کد را دوباره انجام دهیم.</p><h2>انواع داده در جاوا: Primitive و Reference</h2><p>برای درک بهتر جنریک‌ها، لازم است تفاوت بین انواع داده را بدانیم:</p><ul><li><h3>Primitive Data Types (انواع داده اولیه)</h3><ul><li>اینت (<code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">int</code>)، بولیَن (<code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">boolean</code>)، دابل (<code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">double</code>)، فلوت (<code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">float</code>)، وُید (<code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">void</code>)، کَر (<code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">char</code>).</li><li>با حروف کوچک نوشته می‌شوند.</li><li>مستقیماً مقدار را در حافظه استک (Stack) ذخیره می‌کنند.</li></ul></li><li><h3>Reference Data Types (انواع داده ارجاعی)</h3><ul><li>این‌ها نام کلاس‌ها هستند، مانند <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">Person</code>، <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">Teacher</code>، <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">PrintInteger</code>.</li><li>وقتی از یک کلاس شیء می‌سازیم، نام کلاس به عنوان نوع داده آن شیء عمل می‌کند.</li><li>مقدار آن‌ها یک ارجاع (reference) به شیء در حافظه هیپ (Heap) است.</li></ul></li><li><h3>Wrapper Classes (کلاس‌های Wrapper)</h3><p>برای هر نوع داده اولیه (primitive data type)، یک کلاس Wrapper معادل وجود دارد که آن را به یک نوع داده ارجاعی تبدیل می‌کند:</p><ul><li><code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">int</code> → <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">Integer</code></li><li><code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">boolean</code> → <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">Boolean</code></li><li><code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">double</code> → <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">Double</code></li><li><code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">float</code> → <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">Float</code></li><li><code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">char</code> → <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">Character</code></li></ul><p>این کلاس‌ها با حرف بزرگ شروع می‌شوند، زیرا آن‌ها کلاس هستند. دلیل اصلی وجود کلاس‌های Wrapper این است که جنریک‌ها فقط با انواع داده ارجاعی کار می‌کنند. استفاده از انواع داده اولیه (مانند <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">int</code>) برای متغیرهای ساده به دلیل مصرف کمتر حافظه (استک) توصیه می‌شود، اما برای استفاده با جنریک‌ها، نیاز به کلاس‌های Wrapper داریم.</p></li></ul><h2>راه حل: جنریک‌ها (Generics)</h2><p>جنریک‌ها راه حلی برای مشکل تکرار کد در مواجهه با انواع داده مختلف ارائه می‌دهند. آن‌ها به ما اجازه می‌دهند تا کلاس‌ها، متدها و اینترفیس‌ها را با پارامترهای نوع (Type Parameters) تعریف کنیم.</p><h3>نحوه کار جنریک‌ها</h3><p>جنریک‌ها فقط با انواع داده ارجاعی (Reference Data Types) کار می‌کنند و با انواع داده اولیه (Primitive Data Types) کار نمی‌کنند.</p><p>به جای تعریف کلاس برای یک نوع داده خاص (مثلاً <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">int</code>)، از یک پارامتر نوع (معمولاً <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">T</code> به معنای Type) استفاده می‌کنیم:</p><pre style=\"white-space: pre-wrap !important; word-wrap: break-word !important; overflow-x: auto !important; max-width: 100% !important; padding: 1rem; background-color: #f5f5f5; border-radius: 4px; direction: ltr; font-family: \'Courier New\', monospace; font-size: 0.9em; line-height: 1.5; margin: 1rem 0;\"><code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; display: block; overflow-x: auto; font-family: \'Courier New\', monospace;\">class Print&lt;T&gt; {\n    T a;\n\n    public Print(T a) {\n        this.a = a;\n    }\n\n    public void printer() {\n        System.out.println(a);\n    }\n}\n</code></pre><ul><li>علامت <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">&lt;T&gt;</code> پس از نام کلاس، نشان‌دهنده یک پارامتر نوع است.</li><li><code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">T</code> یک متغیر است که در زمان ایجاد شیء، با نوع داده واقعی جایگزین می‌شود.</li><li><code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">T</code> باید با حرف بزرگ نوشته شود.</li><li>بهتر است از <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">T</code> استفاده شود، زیرا مخفف Type است و در بین برنامه‌نویسان جاوا رایج است.</li></ul><h3>استفاده از کلاس جنریک</h3><p>هنگام ساخت شیء از کلاس جنریک، نوع داده مورد نظر را مشخص می‌کنیم:</p><pre style=\"white-space: pre-wrap !important; word-wrap: break-word !important; overflow-x: auto !important; max-width: 100% !important; padding: 1rem; background-color: #f5f5f5; border-radius: 4px; direction: ltr; font-family: \'Courier New\', monospace; font-size: 0.9em; line-height: 1.5; margin: 1rem 0;\"><code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; display: block; overflow-x: auto; font-family: \'Courier New\', monospace;\">// برای اعداد صحیح\nPrint&lt;Integer&gt; pi = new Print&lt;Integer&gt;(3);\npi.printer(); // خروجی: 3\n\n// برای اعداد اعشاری\nPrint&lt;Double&gt; pd = new Print&lt;Double&gt;(3.14);\npd.printer(); // خروجی: 3.14\n\n// برای کلاس‌های سفارشی\nPrint&lt;Person&gt; pp = new Print&lt;Person&gt;(new Person());\npp.printer(); // خروجی: اطلاعات شیء Person\n</code></pre><p>در نسخه‌های جدید جاوا (از Java 7 به بعد)، می‌توانیم در سمت راست انتساب، پارامتر نوع را حذف کنیم (Diamond Operator):</p><pre style=\"white-space: pre-wrap !important; word-wrap: break-word !important; overflow-x: auto !important; max-width: 100% !important; padding: 1rem; background-color: #f5f5f5; border-radius: 4px; direction: ltr; font-family: \'Courier New\', monospace; font-size: 0.9em; line-height: 1.5; margin: 1rem 0;\"><code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; display: block; overflow-x: auto; font-family: \'Courier New\', monospace;\">Print&lt;Integer&gt; pi = new Print&lt;&gt;(3);\n</code></pre><p>اما توصیه می‌شود برای خوانایی بیشتر و سازگاری با کدهای قدیمی‌تر، پارامتر نوع در هر دو سمت نوشته شود.</p><h2>جنریک‌های پیشرفته: Bounded Type Parameters</h2><p>گاهی اوقات می‌خواهیم انواع داده‌ای که می‌توانند جایگزین <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">T</code> شوند را محدود کنیم. این کار با استفاده از Bounded Type Parameters انجام می‌شود:</p><pre style=\"white-space: pre-wrap !important; word-wrap: break-word !important; overflow-x: auto !important; max-width: 100% !important; padding: 1rem; background-color: #f5f5f5; border-radius: 4px; direction: ltr; font-family: \'Courier New\', monospace; font-size: 0.9em; line-height: 1.5; margin: 1rem 0;\"><code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; display: block; overflow-x: auto; font-family: \'Courier New\', monospace;\">class Print&lt;T extends Person&gt; {\n    T a;\n    // ... بقیه کد\n}\n</code></pre><ul><li>با <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">&lt;T extends Person&gt;</code>، مشخص می‌کنیم که <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">T</code> فقط می‌تواند کلاس <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">Person</code> یا هر زیرکلاس (subclass) آن باشد (مانند <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">Student</code> یا <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">Teacher</code>).</li><li>اگر کلاسی مانند <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">Cat</code> از <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">Person</code> ارث‌بری نکرده باشد، نمی‌توانیم از <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">Print&lt;Cat&gt;</code> استفاده کنیم.</li></ul><h3>چندین پارامتر نوع</h3><p>می‌توانیم چندین پارامتر نوع برای یک کلاس جنریک تعریف کنیم:</p><pre style=\"white-space: pre-wrap !important; word-wrap: break-word !important; overflow-x: auto !important; max-width: 100% !important; padding: 1rem; background-color: #f5f5f5; border-radius: 4px; direction: ltr; font-family: \'Courier New\', monospace; font-size: 0.9em; line-height: 1.5; margin: 1rem 0;\"><code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; display: block; overflow-x: auto; font-family: \'Courier New\', monospace;\">class Pair&lt;K, V&gt; {\n    K key;\n    V value;\n    // ... بقیه کد\n}\n</code></pre><p>هر پارامتر نوع می‌تواند محدودیت‌های خاص خود را داشته باشد:</p><pre style=\"white-space: pre-wrap !important; word-wrap: break-word !important; overflow-x: auto !important; max-width: 100% !important; padding: 1rem; background-color: #f5f5f5; border-radius: 4px; direction: ltr; font-family: \'Courier New\', monospace; font-size: 0.9em; line-height: 1.5; margin: 1rem 0;\"><code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; display: block; overflow-x: auto; font-family: \'Courier New\', monospace;\">class Pair&lt;K extends Number, V extends String&gt; {\n    // ... بقیه کد\n}\n</code></pre><h2>خلاصه</h2><p>در این جلسه متوجه شدیم که:</p><ul><li>چرا به جنریک‌ها نیاز داریم: برای جلوگیری از تکرار کد هنگام کار با انواع داده مختلف.</li><li>چگونه از جنریک‌ها استفاده کنیم: با تعریف پارامترهای نوع (مانند <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">&lt;T&gt;</code>) در کلاس‌ها و متدها.</li><li>جنریک‌ها فقط روی انواع داده ارجاعی (Reference Data Types) کار می‌کنند.</li><li>برای استفاده از انواع داده اولیه با جنریک‌ها، از کلاس‌های Wrapper مربوطه (مانند <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">Integer</code> برای <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">int</code>) استفاده می‌کنیم.</li><li>می‌توانیم با استفاده از <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">extends</code>، انواع داده‌ای که می‌توانند جایگزین پارامتر نوع شوند را محدود کنیم.</li></ul></div>','<h1>مقدمه‌ای بر جنریک‌ها (Generics)</h1><p>ابتدا بررسی می‌کنیم که چرا به یک مفهوم جدید به نام جنریک (Generic) نیاز داریم.</p><h2>مثال اولیه: کلاس PrintInteger</h2><p>فرض کنید می‌خواهیم کلاسی داشته باشیم که داخل آن یک متد برای چاپ یک عدد صحیح (integer) وجود داشته باشد:</p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">class PrintInteger {\n    int a;\n\n    public PrintInteger(int a) {\n        this.a = a;\n    }\n\n    public void printer() {\n        System.out.println(a);\n    }\n}\n</pre><p>برای ساخت یک شیء از این کلاس و استفاده از آن:</p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">PrintInteger pi = new PrintInteger(3);\npi.printer(); // خروجی: 3\n</pre><h2>مشکل با انواع داده مختلف</h2><p>این کلاس تنها برای اعداد صحیح (<code>int</code>) کار می‌کند. حال اگر بخواهیم عدد اعشاری (مثلاً <code>3.14</code>) یا انواع داده دیگر را چاپ کنیم، چه باید کرد؟</p><ul><li>**راه حل اول (ناکارآمد):** اضافه کردن کانستراکتورهای بیشتر برای هر نوع داده (مثلاً برای <code>double</code>، <code>float</code>، <code>String</code> و غیره). این کار باعث افزایش تعداد کانستراکتورها و پیچیدگی کد می‌شود.</li><li>**راه حل دوم (ناکارآمدتر):** ایجاد کلاس‌های جداگانه برای هر نوع داده (مثلاً <code>PrintDouble</code>، <code>PrintString</code>). این روش منجر به تکرار زیاد کد (Duplicate Code) می‌شود.</li></ul><p>این مشکل نه تنها برای انواع داده اولیه (primitive data types) مانند <code>int</code> و <code>double</code> وجود دارد، بلکه برای کلاس‌های تعریف‌شده توسط کاربر (مانند <code>Person</code>، <code>Student</code>، <code>Vehicle</code>) نیز صادق است. اگر بخواهیم یک شیء از کلاس <code>Person</code> را چاپ کنیم، مجبوریم همین تکرار کد را دوباره انجام دهیم.</p><h2>انواع داده در جاوا: Primitive و Reference</h2><p>برای درک بهتر جنریک‌ها، لازم است تفاوت بین انواع داده را بدانیم:</p><h3>Primitive Data Types (انواع داده اولیه)</h3><ul><li class=\"ql-indent-1\">اینت (<code>int</code>)، بولیَن (<code>boolean</code>)، دابل (<code>double</code>)، فلوت (<code>float</code>)، وُید (<code>void</code>)، کَر (<code>char</code>).</li><li class=\"ql-indent-1\">با حروف کوچک نوشته می‌شوند.</li><li class=\"ql-indent-1\">مستقیماً مقدار را در حافظه استک (Stack) ذخیره می‌کنند.</li></ul><h3>Reference Data Types (انواع داده ارجاعی)</h3><ul><li class=\"ql-indent-1\">این‌ها نام کلاس‌ها هستند، مانند <code>Person</code>، <code>Teacher</code>، <code>PrintInteger</code>.</li><li class=\"ql-indent-1\">وقتی از یک کلاس شیء می‌سازیم، نام کلاس به عنوان نوع داده آن شیء عمل می‌کند.</li><li class=\"ql-indent-1\">مقدار آن‌ها یک ارجاع (reference) به شیء در حافظه هیپ (Heap) است.</li></ul><h3>Wrapper Classes (کلاس‌های Wrapper)</h3><ul><li>برای هر نوع داده اولیه (primitive data type)، یک کلاس Wrapper معادل وجود دارد که آن را به یک نوع داده ارجاعی تبدیل می‌کند:</li><li class=\"ql-indent-1\"><code>int</code> → <code>Integer</code></li><li class=\"ql-indent-1\"><code>boolean</code> → <code>Boolean</code></li><li class=\"ql-indent-1\"><code>double</code> → <code>Double</code></li><li class=\"ql-indent-1\"><code>float</code> → <code>Float</code></li><li class=\"ql-indent-1\"><code>char</code> → <code>Character</code></li><li>این کلاس‌ها با حرف بزرگ شروع می‌شوند، زیرا آن‌ها کلاس هستند. دلیل اصلی وجود کلاس‌های Wrapper این است که جنریک‌ها فقط با انواع داده ارجاعی کار می‌کنند. استفاده از انواع داده اولیه (مانند <code>int</code>) برای متغیرهای ساده به دلیل مصرف کمتر حافظه (استک) توصیه می‌شود، اما برای استفاده با جنریک‌ها، نیاز به کلاس‌های Wrapper داریم.</li></ul><h2>راه حل: جنریک‌ها (Generics)</h2><p>جنریک‌ها راه حلی برای مشکل تکرار کد در مواجهه با انواع داده مختلف ارائه می‌دهند. آن‌ها به ما اجازه می‌دهند تا کلاس‌ها، متدها و اینترفیس‌ها را با پارامترهای نوع (Type Parameters) تعریف کنیم.</p><h3>نحوه کار جنریک‌ها</h3><p>جنریک‌ها فقط با انواع داده ارجاعی (Reference Data Types) کار می‌کنند و با انواع داده اولیه (Primitive Data Types) کار نمی‌کنند.</p><p>به جای تعریف کلاس برای یک نوع داده خاص (مثلاً <code>int</code>)، از یک پارامتر نوع (معمولاً <code>T</code> به معنای Type) استفاده می‌کنیم:</p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">class Print&lt;T&gt; {\n    T a;\n\n    public Print(T a) {\n        this.a = a;\n    }\n\n    public void printer() {\n        System.out.println(a);\n    }\n}\n</pre><ul><li>علامت <code>&lt;T&gt;</code> پس از نام کلاس، نشان‌دهنده یک پارامتر نوع است.</li><li><code>T</code> یک متغیر است که در زمان ایجاد شیء، با نوع داده واقعی جایگزین می‌شود.</li><li><code>T</code> باید با حرف بزرگ نوشته شود.</li><li>بهتر است از <code>T</code> استفاده شود، زیرا مخفف Type است و در بین برنامه‌نویسان جاوا رایج است.</li></ul><h3>استفاده از کلاس جنریک</h3><p>هنگام ساخت شیء از کلاس جنریک، نوع داده مورد نظر را مشخص می‌کنیم:</p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">// برای اعداد صحیح\nPrint&lt;Integer&gt; pi = new Print&lt;Integer&gt;(3);\npi.printer(); // خروجی: 3\n\n// برای اعداد اعشاری\nPrint&lt;Double&gt; pd = new Print&lt;Double&gt;(3.14);\npd.printer(); // خروجی: 3.14\n\n// برای کلاس‌های سفارشی\nPrint&lt;Person&gt; pp = new Print&lt;Person&gt;(new Person());\npp.printer(); // خروجی: اطلاعات شیء Person\n</pre><p>در نسخه‌های جدید جاوا (از Java 7 به بعد)، می‌توانیم در سمت راست انتساب، پارامتر نوع را حذف کنیم (Diamond Operator):</p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">Print&lt;Integer&gt; pi = new Print&lt;&gt;(3);\n</pre><p>اما توصیه می‌شود برای خوانایی بیشتر و سازگاری با کدهای قدیمی‌تر، پارامتر نوع در هر دو سمت نوشته شود.</p><h2>جنریک‌های پیشرفته: Bounded Type Parameters</h2><p>گاهی اوقات می‌خواهیم انواع داده‌ای که می‌توانند جایگزین <code>T</code> شوند را محدود کنیم. این کار با استفاده از Bounded Type Parameters انجام می‌شود:</p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">class Print&lt;T extends Person&gt; {\n    T a;\n    // ... بقیه کد\n}\n</pre><ul><li>با <code>&lt;T extends Person&gt;</code>، مشخص می‌کنیم که <code>T</code> فقط می‌تواند کلاس <code>Person</code> یا هر زیرکلاس (subclass) آن باشد (مانند <code>Student</code> یا <code>Teacher</code>).</li><li>اگر کلاسی مانند <code>Cat</code> از <code>Person</code> ارث‌بری نکرده باشد، نمی‌توانیم از <code>Print&lt;Cat&gt;</code> استفاده کنیم.</li></ul><h3>چندین پارامتر نوع</h3><p>می‌توانیم چندین پارامتر نوع برای یک کلاس جنریک تعریف کنیم:</p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">class Pair&lt;K, V&gt; {\n    K key;\n    V value;\n    // ... بقیه کد\n}\n</pre><p>هر پارامتر نوع می‌تواند محدودیت‌های خاص خود را داشته باشد:</p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">class Pair&lt;K extends Number, V extends String&gt; {\n    // ... بقیه کد\n}\n</pre><h2>خلاصه</h2><p>در این جلسه متوجه شدیم که:</p><ul><li>چرا به جنریک‌ها نیاز داریم: برای جلوگیری از تکرار کد هنگام کار با انواع داده مختلف.</li><li>چگونه از جنریک‌ها استفاده کنیم: با تعریف پارامترهای نوع (مانند <code>&lt;T&gt;</code>) در کلاس‌ها و متدها.</li><li>جنریک‌ها فقط روی انواع داده ارجاعی (Reference Data Types) کار می‌کنند.</li><li>برای استفاده از انواع داده اولیه با جنریک‌ها، از کلاس‌های Wrapper مربوطه (مانند <code>Integer</code> برای <code>int</code>) استفاده می‌کنیم.</li><li>می‌توانیم با استفاده از <code>extends</code>، انواع داده‌ای که می‌توانند جایگزین پارامتر نوع شوند را محدود کنیم.</li></ul>','completed','2025-12-06 19:19:38','2025-12-06 20:27:56',NULL,NULL,0,NULL,1,NULL),(73,1,1,'مباحث پیشرفته برنامه‌نویسی — Overloading و ساختار پروژه‌های ماژولار','1404/08/18','<div style=\"max-width: 100%; overflow-x: hidden; word-wrap: break-word; padding: 1rem; box-sizing: border-box;\"><h1>مقدمه و بحث آزاد</h1><p>کلاس با صحبت‌های عمومی و تبریک تولد یکی از دانشجویان آغاز شد. پس از آن، بحثی در مورد نحوه حضور و غیاب و نمره‌دهی مطرح شد که بیشتر جنبه شوخی داشت.</p><h2>مباحث فنی: Overloading متدها</h2><h3>چرا متدها با تفاوت صرفاً در Return Type قابل Overload نیستند؟</h3><p>یکی از دانشجویان توضیح داد که اگر فقط نوع بازگشتی (<code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">return type</code>) یک متد متفاوت باشد، آن متد قابل Overload نیست. این موضوع در برنامه‌نویسی شی‌گرا مطرح شد.</p><p>استاد سوال را با جزئیات بیشتری مطرح کرد: \"چرا وقتی دو تابع عیناً یکسان هستند، دو متد عیناً یکسان هستند، فقط <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">return type</code>هایشان متفاوت باشد، این‌ها Overload همدیگر حساب نمی‌شوند و ارور می‌دهند؟\"</p><p>یکی از دانشجویان پاسخ داد که هنگام فراخوانی تابع، کامپایلر به اسم تابع و پارامترهای آن نگاه می‌کند، نه به <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">return type</code>. بنابراین، اگر فقط <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">return type</code> متفاوت باشد، کامپایلر نمی‌تواند تشخیص دهد که کدام تابع را باید فراخوانی کند.</p><p>استاد این توضیح را تایید و تکمیل کرد: مشکل اصلی این است که برنامه نمی‌داند وارد کدام تابع <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">run</code> شود. یعنی نمی‌تواند انتخاب کند که وارد کدام تابع شود تا خروجی مورد نظر (<code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">int</code>، <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">double</code>، <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">float</code> و غیره) را بدهد.</p><h2>پروژه جدید کلاس: رویکرد ماژولار</h2><h3>هدف پروژه</h3><p>استاد پیشنهاد یک پروژه \"باحال\" را مطرح کرد که \"خیلی سخت\" خواهد بود و هدف آن یادگیری عملی تکنولوژی‌ها و کاربردی کردن مباحث است، نه صرفاً تئوری. تاکید شد که این پروژه به مباحث اندروید نیز خواهد رسید و دانشجویان نباید نگران آن باشند. پروژه‌های ترم‌های گذشته که توسط دانشجویان بدون پیش‌زمینه اندروید انجام شده بود، مثال زده شد که به نتایج بسیار خوبی رسیده بودند.</p><h3>ساختار پروژه پیشنهادی</h3><ul><li>یک پروژه تعریف می‌شود.</li><li>این پروژه به ماژول‌های مختلف شکسته می‌شود.</li><li>هر ماژول توسط یک تیم پیاده‌سازی می‌شود.</li><li>هر ماژول به یک فایل <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">JAR</code> تبدیل می‌شود.</li><li>همه این فایل‌های <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">JAR</code> با هم ترکیب شده و به عنوان یک پروژه اصلی استفاده می‌شوند.</li></ul><h3>مزایای رویکرد جدید</h3><ul><li>یادگیری کار با <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">Git</code> و <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">GitHub</code>.</li><li>انجام یک پروژه نسبتاً گروهی.</li><li>یادگیری نحوه کار با تکنولوژی‌ها و مفاهیمی مانند فایل <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">JAR</code>، نحوه اضافه کردن آن به یک پروژه دیگر و ادغام کدها.</li></ul><h3>مثال: ماشین حساب مهندسی</h3><p>استاد برای روشن شدن موضوع، مثال یک \"ماشین حساب مهندسی\" را مطرح کرد. این ماشین حساب شامل عملیات پایه (جمع، تفریق، ضرب، تقسیم)، لگاریتم، سینوس، کسینوس و ... خواهد بود.</p><ul><li>هر یک از این عملیات (مثلاً عملیات پایه، لگاریتم، مثلثاتی) به یک <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">interface</code> تبدیل می‌شود.</li><li>هر تیم مسئول پیاده‌سازی یک یا چند <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">interface</code> به عنوان یک ماژول خواهد بود.</li><li>برنامه اصلی، <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">interface</code>ها را تعریف می‌کند و پیاده‌سازی‌های انجام شده توسط تیم‌ها (که در قالب فایل‌های <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">JAR</code> هستند) به آن اضافه می‌شوند.</li><li>در نهایت، برنامه اصلی از این ماژول‌های <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">JAR</code> شده استفاده می‌کند و نیازی به کدنویسی مجدد آن‌ها نیست.</li></ul><h3>تکلیف اولیه</h3><p>برای شروع، از دانشجویان خواسته شد که:</p><ol><li>یک پروژه ماشین حساب (با هر تعداد عملیات) بنویسند.</li><li>یک پروژه جدید ایجاد کنند.</li><li>پروژه ماشین حساب قبلی را به عنوان یک فایل <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">JAR</code> به پروژه جدید اضافه کنند.</li><li>از متدها و کلاس‌های موجود در فایل <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">JAR</code> در پروژه جدید استفاده کنند.</li></ol><p>این کار چند مزیت دارد:</p><ul><li>حداقل ۲۰ تا ۳۰ درصد از آنچه استاد در ذهن دارد، یاد گرفته می‌شود.</li><li>با دسترسی به اینترنت و <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">ChatGPT</code>، استرس کمتری وجود خواهد داشت و دانشجویان راحت‌تر می‌توانند کار را دنبال کنند.</li><li>پس از انجام این مرحله، مجدداً نظرسنجی می‌شود که آیا کلاس همین رویکرد را در مقیاس بزرگتر ادامه دهد یا به روش قبلی بازگردد.</li></ul><p>استاد تاکید کرد که هدف اصلی، یادگیری و مشارکت است، نه صرفاً نمره یا کیفیت نهایی پروژه. او اشاره کرد که حتی <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">ChatGPT</code> می‌تواند برنامه‌های اندرویدی بهتر بنویسد و توضیحات شی‌گرایی در <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">YouTube</code> بهتر از او ارائه می‌شود. بنابراین، هدف این است که دانشجویان خودشان دست به کار شوند و با ابزارها و مفاهیم کار کنند.</p><h3>نکات پایانی</h3><p>استاد بر اهمیت مشارکت همه دانشجویان تاکید کرد و گفت که نمره اصلی کلاس از او خواهد بود و همیشه به دانشجویان کمک می‌کند. او از دانشجویان خواست که فعالانه در این پروژه جدید شرکت کنند.</p></div>','<div style=\"max-width: 100%; overflow-x: hidden; word-wrap: break-word; padding: 1rem; box-sizing: border-box;\"><h1>مقدمه و بحث آزاد</h1><p>کلاس با صحبت‌های عمومی و تبریک تولد یکی از دانشجویان آغاز شد. پس از آن، بحثی در مورد نحوه حضور و غیاب و نمره‌دهی مطرح شد که بیشتر جنبه شوخی داشت.</p><h2>مباحث فنی: Overloading متدها</h2><h3>چرا متدها با تفاوت صرفاً در Return Type قابل Overload نیستند؟</h3><p>یکی از دانشجویان توضیح داد که اگر فقط نوع بازگشتی (<code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">return type</code>) یک متد متفاوت باشد، آن متد قابل Overload نیست. این موضوع در برنامه‌نویسی شی‌گرا مطرح شد.</p><p>استاد سوال را با جزئیات بیشتری مطرح کرد: \"چرا وقتی دو تابع عیناً یکسان هستند، دو متد عیناً یکسان هستند، فقط <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">return type</code>هایشان متفاوت باشد، این‌ها Overload همدیگر حساب نمی‌شوند و ارور می‌دهند؟\"</p><p>یکی از دانشجویان پاسخ داد که هنگام فراخوانی تابع، کامپایلر به اسم تابع و پارامترهای آن نگاه می‌کند، نه به <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">return type</code>. بنابراین، اگر فقط <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">return type</code> متفاوت باشد، کامپایلر نمی‌تواند تشخیص دهد که کدام تابع را باید فراخوانی کند.</p><p>استاد این توضیح را تایید و تکمیل کرد: مشکل اصلی این است که برنامه نمی‌داند وارد کدام تابع <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">run</code> شود. یعنی نمی‌تواند انتخاب کند که وارد کدام تابع شود تا خروجی مورد نظر (<code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">int</code>، <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">double</code>، <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">float</code> و غیره) را بدهد.</p><h2>پروژه جدید کلاس: رویکرد ماژولار</h2><h3>هدف پروژه</h3><p>استاد پیشنهاد یک پروژه \"باحال\" را مطرح کرد که \"خیلی سخت\" خواهد بود و هدف آن یادگیری عملی تکنولوژی‌ها و کاربردی کردن مباحث است، نه صرفاً تئوری. تاکید شد که این پروژه به مباحث اندروید نیز خواهد رسید و دانشجویان نباید نگران آن باشند. پروژه‌های ترم‌های گذشته که توسط دانشجویان بدون پیش‌زمینه اندروید انجام شده بود، مثال زده شد که به نتایج بسیار خوبی رسیده بودند.</p><h3>ساختار پروژه پیشنهادی</h3><ul><li>یک پروژه تعریف می‌شود.</li><li>این پروژه به ماژول‌های مختلف شکسته می‌شود.</li><li>هر ماژول توسط یک تیم پیاده‌سازی می‌شود.</li><li>هر ماژول به یک فایل <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">JAR</code> تبدیل می‌شود.</li><li>همه این فایل‌های <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">JAR</code> با هم ترکیب شده و به عنوان یک پروژه اصلی استفاده می‌شوند.</li></ul><h3>مزایای رویکرد جدید</h3><ul><li>یادگیری کار با <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">Git</code> و <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">GitHub</code>.</li><li>انجام یک پروژه نسبتاً گروهی.</li><li>یادگیری نحوه کار با تکنولوژی‌ها و مفاهیمی مانند فایل <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">JAR</code>، نحوه اضافه کردن آن به یک پروژه دیگر و ادغام کدها.</li></ul><h3>مثال: ماشین حساب مهندسی</h3><p>استاد برای روشن شدن موضوع، مثال یک \"ماشین حساب مهندسی\" را مطرح کرد. این ماشین حساب شامل عملیات پایه (جمع، تفریق، ضرب، تقسیم)، لگاریتم، سینوس، کسینوس و ... خواهد بود.</p><ul><li>هر یک از این عملیات (مثلاً عملیات پایه، لگاریتم، مثلثاتی) به یک <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">interface</code> تبدیل می‌شود.</li><li>هر تیم مسئول پیاده‌سازی یک یا چند <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">interface</code> به عنوان یک ماژول خواهد بود.</li><li>برنامه اصلی، <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">interface</code>ها را تعریف می‌کند و پیاده‌سازی‌های انجام شده توسط تیم‌ها (که در قالب فایل‌های <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">JAR</code> هستند) به آن اضافه می‌شوند.</li><li>در نهایت، برنامه اصلی از این ماژول‌های <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">JAR</code> شده استفاده می‌کند و نیازی به کدنویسی مجدد آن‌ها نیست.</li></ul><h3>تکلیف اولیه</h3><p>برای شروع، از دانشجویان خواسته شد که:</p><ol><li>یک پروژه ماشین حساب (با هر تعداد عملیات) بنویسند.</li><li>یک پروژه جدید ایجاد کنند.</li><li>پروژه ماشین حساب قبلی را به عنوان یک فایل <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">JAR</code> به پروژه جدید اضافه کنند.</li><li>از متدها و کلاس‌های موجود در فایل <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">JAR</code> در پروژه جدید استفاده کنند.</li></ol><p>این کار چند مزیت دارد:</p><ul><li>حداقل ۲۰ تا ۳۰ درصد از آنچه استاد در ذهن دارد، یاد گرفته می‌شود.</li><li>با دسترسی به اینترنت و <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">ChatGPT</code>، استرس کمتری وجود خواهد داشت و دانشجویان راحت‌تر می‌توانند کار را دنبال کنند.</li><li>پس از انجام این مرحله، مجدداً نظرسنجی می‌شود که آیا کلاس همین رویکرد را در مقیاس بزرگتر ادامه دهد یا به روش قبلی بازگردد.</li></ul><p>استاد تاکید کرد که هدف اصلی، یادگیری و مشارکت است، نه صرفاً نمره یا کیفیت نهایی پروژه. او اشاره کرد که حتی <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">ChatGPT</code> می‌تواند برنامه‌های اندرویدی بهتر بنویسد و توضیحات شی‌گرایی در <code style=\"white-space: pre-wrap !important; word-wrap: break-word !important; max-width: 100%; display: inline-block; font-family: \'Courier New\', monospace; font-size: 0.9em;\">YouTube</code> بهتر از او ارائه می‌شود. بنابراین، هدف این است که دانشجویان خودشان دست به کار شوند و با ابزارها و مفاهیم کار کنند.</p><h3>نکات پایانی</h3><p>استاد بر اهمیت مشارکت همه دانشجویان تاکید کرد و گفت که نمره اصلی کلاس از او خواهد بود و همیشه به دانشجویان کمک می‌کند. او از دانشجویان خواست که فعالانه در این پروژه جدید شرکت کنند.</p></div>','completed','2025-12-06 19:22:48','2025-12-06 19:24:59',NULL,NULL,0,NULL,1,NULL);
/*!40000 ALTER TABLE `notes` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `notifications`
--

DROP TABLE IF EXISTS `notifications`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `notifications` (
  `id` int unsigned NOT NULL AUTO_INCREMENT,
  `user_id` int unsigned NOT NULL,
  `type` enum('note_completed','note_failed','subscription_expiring','quota_warning') COLLATE utf8mb4_unicode_ci NOT NULL,
  `title` varchar(100) COLLATE utf8mb4_unicode_ci NOT NULL,
  `message` varchar(500) COLLATE utf8mb4_unicode_ci NOT NULL,
  `is_read` tinyint(1) NOT NULL DEFAULT '0',
  `related_note_id` int unsigned DEFAULT NULL,
  `created_at` timestamp NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  KEY `user_id` (`user_id`),
  KEY `related_note_id` (`related_note_id`),
  CONSTRAINT `notifications_ibfk_1` FOREIGN KEY (`user_id`) REFERENCES `users` (`id`) ON DELETE CASCADE,
  CONSTRAINT `notifications_ibfk_2` FOREIGN KEY (`related_note_id`) REFERENCES `notes` (`id`) ON DELETE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=43 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `notifications`
--

LOCK TABLES `notifications` WRITE;
/*!40000 ALTER TABLE `notifications` DISABLE KEYS */;
INSERT INTO `notifications` VALUES (2,1,'note_completed','یادداشت آماده است','یادداشت \'مفاهیم برنامه‌نویسی شیءگرا و ابزارهای توسعه جاوا (جلسه دوم)\' با موفقیت پردازش شد',1,26,'2025-10-13 11:21:32'),(4,1,'note_completed','یادداشت آماده است','یادداشت \'مفاهیم پیشرفته در برنامه‌نویسی شیءگرا: انتزاع، واسط‌ها و سازنده‌ها\' با موفقیت پردازش شد',1,28,'2025-10-26 08:02:42'),(5,1,'note_completed','یادداشت آماده است','یادداشت \'یادگیری ماشین: مفاهیم و رویکردها\' با موفقیت پردازش شد',1,29,'2025-10-26 08:27:51'),(9,1,'note_completed','یادداشت آماده است','یادداشت \'مقدمه‌ای بر رمزنگاری کلاسیک و تحلیل رمز\' با موفقیت پردازش شد',1,35,'2025-10-29 03:54:30'),(10,1,'note_completed','یادداشت آماده است','یادداشت \'مفاهیم پیشرفته شی‌گرایی — حافظه Stack و Heap، Polymorphism و کلاس‌های Abstract\' با موفقیت پردازش شد',1,36,'2025-11-04 08:55:04'),(11,1,'note_completed','یادداشت آماده است','یادداشت \'روش‌های رمزنگاری کلاسیک\' با موفقیت پردازش شد',1,37,'2025-11-04 09:04:10'),(12,1,'note_completed','یادداشت آماده است','یادداشت \'رمزنگاری کلاسیک: جایگشتی و مبانی رمزنگاری مدرن\' با موفقیت پردازش شد',1,38,'2025-11-09 05:46:37'),(13,1,'note_completed','یادداشت آماده است','یادداشت \'هوش مصنوعی مولد (Generative AI) و معماری ترانسفورمر\' با موفقیت پردازش شد',1,43,'2025-11-09 06:33:45'),(14,1,'note_completed','یادداشت آماده است','یادداشت \'مقدمه‌ای بر مسائل پیچیدگی و الگوریتم‌های جستجو در هوش مصنوعی\' با موفقیت پردازش شد',1,44,'2025-11-09 06:42:36'),(20,1,'note_completed','یادداشت آماده است','یادداشت \'هوش مصنوعی و داده (جلسه اول)\' با موفقیت پردازش شد',1,50,'2025-11-09 07:07:49'),(21,1,'note_completed','یادداشت آماده است','یادداشت \'سازنده‌ها و وراثت\' با موفقیت پردازش شد',1,51,'2025-11-09 07:31:41'),(22,1,'note_completed','یادداشت آماده است','یادداشت \'هوش مصنوعی مولد (Generative AI) — کلیات و معماری ترانسفورمر\' با موفقیت پردازش شد',1,52,'2025-11-09 07:36:36'),(24,1,'note_completed','یادداشت آماده است','یادداشت \'کلاس‌های انتزاعی، اینترفیس‌ها و مدیریت حافظه (Stack و Heap)\' با موفقیت پردازش شد',1,54,'2025-11-09 08:24:31'),(25,1,'note_failed','خطا در پردازش','یادداشت \'_Khone Barat Ridan\' با خطا مواجه شد: خطای غیرمنتظره در پردازش فایل: FileTooLargeError. لطفاً با پشتیبانی تماس بگیرید.',1,55,'2025-11-15 15:20:30'),(26,1,'note_failed','خطا در پردازش','یادداشت \'_Khone Barat Ridan\' با خطا مواجه شد: خطای غیرمنتظره در پردازش فایل: FileTooLargeError. لطفاً با پشتیبانی تماس بگیرید.',1,56,'2025-11-15 15:30:27'),(27,1,'note_failed','خطا در پردازش','یادداشت \'_⁨داده کاوی⁩\' با خطا مواجه شد: خطای غیرمنتظره در پردازش فایل: FileTooLargeError. لطفاً با پشتیبانی تماس بگیرید.',1,57,'2025-12-01 18:52:29'),(28,1,'note_failed','خطا در پردازش','یادداشت \'_⁨داده کاوی⁩\' با خطا مواجه شد: خطای غیرمنتظره در پردازش فایل: FileTooLargeError. لطفاً با پشتیبانی تماس بگیرید.',1,58,'2025-12-01 18:54:02'),(29,1,'note_failed','خطا در پردازش','یادداشت \'_⁨داده کاوی⁩\' با خطا مواجه شد: خطای غیرمنتظره در پردازش فایل: FileTooLargeError. لطفاً با پشتیبانی تماس بگیرید.',1,59,'2025-12-01 18:55:09'),(30,1,'note_failed','خطا در پردازش','یادداشت \'_⁨داده کاوی⁩\' با خطا مواجه شد: خطای غیرمنتظره در پردازش فایل: FileTooLargeError. لطفاً با پشتیبانی تماس بگیرید.',1,60,'2025-12-01 18:56:15'),(31,1,'note_failed','خطا در پردازش','یادداشت \'_⁨داده کاوی⁩\' با خطا مواجه شد: خطای غیرمنتظره در پردازش فایل: InvalidFormatError. لطفاً با پشتیبانی تماس بگیرید.',1,61,'2025-12-01 19:04:59'),(32,1,'note_failed','خطا در پردازش','یادداشت \'_⁨داده کاوی⁩\' با خطا مواجه شد: خطای غیرمنتظره در پردازش فایل: InvalidFormatError. لطفاً با پشتیبانی تماس بگیرید.',1,62,'2025-12-01 19:06:19'),(35,1,'note_failed','خطا در پردازش','یادداشت \'_⁨داده کاوی⁩\' با خطا مواجه شد: خطای غیرمنتظره در پردازش فایل: NetworkError. لطفاً با پشتیبانی تماس بگیرید.',1,65,'2025-12-02 08:45:03'),(36,1,'note_failed','خطا در پردازش','یادداشت \'_⁨داده کاوی⁩\' با خطا مواجه شد: خطای غیرمنتظره در پردازش فایل: NetworkError. لطفاً با پشتیبانی تماس بگیرید.',1,66,'2025-12-02 09:08:11'),(37,1,'note_failed','خطا در پردازش','یادداشت \'_⁨داده کاوی⁩\' با خطا مواجه شد: خطای غیرمنتظره در پردازش فایل: NetworkError. لطفاً با پشتیبانی تماس بگیرید.',0,67,'2025-12-02 20:10:13'),(38,1,'note_completed','یادداشت آماده است','یادداشت \'نمایش داده‌ها و انواع داده‌ها در داده‌کاوی\' با موفقیت پردازش شد',0,68,'2025-12-02 20:29:39'),(39,1,'note_completed','یادداشت آماده است','یادداشت \'رمزنگاری نامتقارن و الگوریتم RSA – چالش‌ها و کاربردها\' با موفقیت پردازش شد',1,70,'2025-12-03 04:09:43'),(40,1,'note_completed','یادداشت آماده است','یادداشت \'نمایش، انواع و منابع داده‌ها در داده‌کاوی\' با موفقیت پردازش شد',0,71,'2025-12-03 07:14:56'),(41,1,'note_completed','یادداشت آماده است','یادداشت \'مقدمه‌ای بر جنریک‌ها در جاوا\' با موفقیت پردازش شد',0,72,'2025-12-06 19:22:29'),(42,1,'note_completed','یادداشت آماده است','یادداشت \'مباحث پیشرفته برنامه‌نویسی — Overloading و ساختار پروژه‌های ماژولار\' با موفقیت پردازش شد',0,73,'2025-12-06 19:25:00');
/*!40000 ALTER TABLE `notifications` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `payments`
--

DROP TABLE IF EXISTS `payments`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `payments` (
  `id` int unsigned NOT NULL AUTO_INCREMENT,
  `user_id` int unsigned NOT NULL,
  `subscription_id` int unsigned NOT NULL,
  `amount_toman` decimal(10,0) NOT NULL,
  `payment_gateway` varchar(50) COLLATE utf8mb4_unicode_ci NOT NULL,
  `transaction_ref_id` varchar(500) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `status` enum('pending','completed','failed') COLLATE utf8mb4_unicode_ci NOT NULL,
  `paid_at` timestamp NULL DEFAULT NULL,
  `created_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  UNIQUE KEY `transaction_ref_id` (`transaction_ref_id`),
  KEY `subscription_id` (`subscription_id`),
  KEY `idx_transaction` (`transaction_ref_id`),
  KEY `idx_user_payment` (`user_id`,`status`),
  CONSTRAINT `payments_ibfk_1` FOREIGN KEY (`user_id`) REFERENCES `users` (`id`) ON DELETE CASCADE,
  CONSTRAINT `payments_ibfk_2` FOREIGN KEY (`subscription_id`) REFERENCES `user_subscriptions` (`id`) ON DELETE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=14 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `payments`
--

LOCK TABLES `payments` WRITE;
/*!40000 ALTER TABLE `payments` DISABLE KEYS */;
INSERT INTO `payments` VALUES (4,1,5,249000,'mock','26014179-abd5-45de-813a-c51b58749766','completed','2025-10-10 20:06:34','2025-10-10 23:36:34'),(11,1,12,99000,'mock','9c454c6f-0302-4671-bb6f-c41f0ffa140b','completed','2025-11-09 03:30:35','2025-11-09 07:00:34'),(12,1,13,0,'mock','080221e1-76a6-48b9-8976-7b817797f938','completed','2025-12-02 17:15:10','2025-12-02 20:45:10'),(13,1,14,99000,'mock','9fec358a-8355-4032-97f2-5e869d7981ec','completed','2025-12-06 15:52:36','2025-12-06 19:22:36');
/*!40000 ALTER TABLE `payments` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `plans`
--

DROP TABLE IF EXISTS `plans`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `plans` (
  `id` smallint unsigned NOT NULL AUTO_INCREMENT,
  `name` varchar(50) COLLATE utf8mb4_unicode_ci NOT NULL,
  `price_toman` decimal(10,0) NOT NULL,
  `duration_days` int NOT NULL,
  `max_minutes` int unsigned NOT NULL,
  `max_notebooks` int unsigned NOT NULL,
  `features` json DEFAULT NULL,
  `is_active` tinyint(1) NOT NULL DEFAULT '1',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `plans`
--

LOCK TABLES `plans` WRITE;
/*!40000 ALTER TABLE `plans` DISABLE KEYS */;
INSERT INTO `plans` VALUES (1,'پلن رایگان',0,30,30,3,'[\"30 دقیقه تبدیل\", \"3 دفتر\", \"پشتیبانی پایه\"]',1),(2,'پلن ماهانه',99000,30,300,10,'[\"300 دقیقه تبدیل\", \"10 دفتر\", \"پشتیبانی اولویت‌دار\", \"خروجی PDF\"]',1),(3,'پلن سه‌ماهه',249000,90,1000,50,'[\"1000 دقیقه تبدیل\", \"50 دفتر\", \"پشتیبانی VIP\", \"خروجی PDF\", \"ویرایشگر پیشرفته\"]',1);
/*!40000 ALTER TABLE `plans` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `processing_queue`
--

DROP TABLE IF EXISTS `processing_queue`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `processing_queue` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `note_id` int unsigned NOT NULL,
  `user_id` int unsigned NOT NULL,
  `priority` smallint NOT NULL DEFAULT '0' COMMENT '0=normal, 1=premium, 2=urgent',
  `status` enum('waiting','processing','completed','failed') COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT 'waiting',
  `retry_count` smallint NOT NULL DEFAULT '0',
  `estimated_credits` decimal(10,2) DEFAULT NULL COMMENT 'Estimated credits required',
  `added_at` timestamp NULL DEFAULT CURRENT_TIMESTAMP,
  `started_at` timestamp NULL DEFAULT NULL,
  `completed_at` timestamp NULL DEFAULT NULL,
  `error_message` text COLLATE utf8mb4_unicode_ci,
  PRIMARY KEY (`id`),
  UNIQUE KEY `note_id` (`note_id`),
  KEY `idx_status_priority` (`status`,`priority`),
  KEY `idx_user` (`user_id`),
  KEY `idx_added_at` (`added_at`),
  KEY `idx_started_at` (`started_at`),
  CONSTRAINT `processing_queue_ibfk_1` FOREIGN KEY (`note_id`) REFERENCES `notes` (`id`) ON DELETE CASCADE,
  CONSTRAINT `processing_queue_ibfk_2` FOREIGN KEY (`user_id`) REFERENCES `users` (`id`) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='Processing queue for notes';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `processing_queue`
--

LOCK TABLES `processing_queue` WRITE;
/*!40000 ALTER TABLE `processing_queue` DISABLE KEYS */;
/*!40000 ALTER TABLE `processing_queue` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `uploads`
--

DROP TABLE IF EXISTS `uploads`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `uploads` (
  `id` int unsigned NOT NULL AUTO_INCREMENT,
  `note_id` int unsigned NOT NULL,
  `user_id` int unsigned NOT NULL,
  `original_file_name` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL,
  `storage_path` varchar(512) COLLATE utf8mb4_unicode_ci NOT NULL,
  `file_type` varchar(20) COLLATE utf8mb4_unicode_ci NOT NULL,
  `file_size_bytes` bigint unsigned NOT NULL,
  `duration_seconds` int unsigned DEFAULT NULL,
  `created_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  KEY `user_id` (`user_id`),
  KEY `idx_note_upload` (`note_id`),
  CONSTRAINT `uploads_ibfk_1` FOREIGN KEY (`note_id`) REFERENCES `notes` (`id`) ON DELETE CASCADE,
  CONSTRAINT `uploads_ibfk_2` FOREIGN KEY (`user_id`) REFERENCES `users` (`id`) ON DELETE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=90 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `uploads`
--

LOCK TABLES `uploads` WRITE;
/*!40000 ALTER TABLE `uploads` DISABLE KEYS */;
INSERT INTO `uploads` VALUES (16,13,1,'photo_2_2025-10-12_12-26-06.jpg','./uploads/13a3143f-aac4-498e-b4df-123374070d1d.jpg','image/jpeg',227944,NULL,'2025-10-12 08:57:35'),(17,13,1,'photo_1_2025-10-12_12-26-06.jpg','./uploads/2c962be7-d8d4-466d-af07-d7f824def996.jpg','image/jpeg',249508,NULL,'2025-10-12 08:57:35'),(18,13,1,'دانشگاه گلستان 6.m4a','./uploads/ec828a1d-5b47-4051-9dfe-10e06747ae6c.m4a','audio/x-m4a',10377564,NULL,'2025-10-12 08:57:35'),(19,13,1,'دانشگاه گلستان 5.m4a','./uploads/dcb749f3-68d0-40a2-8fdf-274d7f8ed448.m4a','audio/x-m4a',11105943,NULL,'2025-10-12 08:57:35'),(35,26,1,'سیار ۳.m4a','./uploads/52b871a3-3c57-446b-bd37-c27971fcce90.m4a','audio/x-m4a',35042749,NULL,'2025-10-13 11:20:20'),(40,28,1,'_⁨سیار۲۷-۱⁩.m4a','./uploads/2d37e6e7-d590-4b7c-883a-cf6925f467cb.m4a','audio/x-m4a',8949737,NULL,'2025-10-26 07:56:28'),(41,28,1,'_⁨سیار۲۷-۳⁩.m4a','./uploads/5c5042fc-f821-43dc-acbf-8b225c9e72ff.m4a','audio/x-m4a',7961778,NULL,'2025-10-26 07:56:28'),(42,28,1,'_⁨سیار۲۷-۴⁩.m4a','./uploads/231b9d0d-462b-44d3-9a00-8135ed4e1cea.m4a','audio/x-m4a',5647444,NULL,'2025-10-26 07:56:28'),(43,28,1,'_⁨سیار۲۷-۲⁩.m4a','./uploads/739843dd-2158-4622-bbff-1d597a8828ac.m4a','audio/x-m4a',7393668,NULL,'2025-10-26 07:56:28'),(44,29,1,'_⁨دانشگاه گلستان 10⁩.m4a','./uploads/83b2b99e-3a90-423b-b2cc-7c0001a50fb9.m4a','audio/x-m4a',15266906,NULL,'2025-10-26 08:22:57'),(50,35,1,'_⁨امنیت۵⁩.m4a','./uploads/2153e478-b8a4-41c3-866e-0a5dd0e32f7a.m4a','audio/x-m4a',24011742,NULL,'2025-10-29 03:46:50'),(51,36,1,'_⁨سیار ۱۱⁩.m4a','./uploads/4794a171-239a-4512-9f98-be94c893097c.m4a','audio/x-m4a',18229582,NULL,'2025-11-04 08:51:20'),(52,37,1,'_⁨امنیت۷⁩.m4a','./uploads/a07c534b-02ec-4420-9517-7749a8c5b6d6.m4a','audio/x-m4a',32074686,NULL,'2025-11-04 08:57:02'),(53,38,1,'_⁨امنیت ۱۴ ابان⁩.m4a','./uploads/0d7126b4-df84-412f-a689-8302243cb581.m4a','audio/x-m4a',23186650,NULL,'2025-11-09 05:42:17'),(58,43,1,'_⁨هوش ۵⁩.m4a','./uploads/a69d39a5-eacb-48cb-bdd1-c1486a8c4887.m4a','audio/x-m4a',17728426,NULL,'2025-11-09 06:30:35'),(59,44,1,'_⁨هوش مصنوعی ۲⁩.m4a','./uploads/3284d845-c8bd-401f-9182-525cefbd8d49.m4a','audio/x-m4a',18825795,NULL,'2025-11-09 06:38:14'),(65,50,1,'_⁨هوش مصنوعی⁩.m4a','./uploads/77e1ecc9-f32f-41e1-9df2-a37394a95585.m4a','audio/x-m4a',33961774,NULL,'2025-11-09 07:00:48'),(66,51,1,'_⁨سیار۲۷-۴⁩.m4a','./uploads/cefbed3a-4455-4a9a-a7a3-658911b87812.m4a','audio/x-m4a',5647444,NULL,'2025-11-09 07:28:35'),(67,52,1,'_⁨هوش ۵⁩.m4a','./uploads/383f7ddf-f73b-4c0e-b3b6-8982b264a8c0.m4a','audio/x-m4a',17728426,NULL,'2025-11-09 07:30:45'),(68,53,1,'_⁨هوش ۵⁩.m4a','./uploads/9f941b01-aa27-49ae-aedb-75355159656e.m4a','audio/x-m4a',17728426,NULL,'2025-11-09 08:13:20'),(69,54,1,'_⁨سیار ۱۱⁩.m4a','./uploads/6a2b6395-20f4-4ac0-86b4-a92543a72ce8.m4a','audio/x-m4a',18229582,NULL,'2025-11-09 08:20:53'),(70,55,1,'_Khone Barat Ridan.mp3','./uploads/028a7a02-0eb1-4479-8592-1b4a46fd3df7.mp3','audio/mpeg',4031539,NULL,'2025-11-15 15:20:29'),(71,56,1,'_Khone Barat Ridan.mp3','./uploads/b66e70c5-8106-4970-9a7c-3338f490ac15.mp3','audio/mpeg',4031539,NULL,'2025-11-15 15:30:17'),(72,57,1,'_⁨داده کاوی⁩.m4a','./uploads/b0399451-e369-40cd-92d5-32f487c9bf8f.m4a','audio/x-m4a',17340541,NULL,'2025-12-01 18:52:27'),(73,58,1,'_⁨داده کاوی⁩.m4a','./uploads/9edca0ac-70e4-48df-95e9-bd0e64204f6f.m4a','audio/x-m4a',17340541,NULL,'2025-12-01 18:54:01'),(74,59,1,'_⁨داده کاوی⁩.m4a','./uploads/894a3a5c-bfb1-4747-9f33-7d78585d8a82.m4a','audio/x-m4a',17340541,NULL,'2025-12-01 18:55:03'),(75,60,1,'_⁨داده کاوی⁩.m4a','./uploads/e1a48419-853a-4100-b04f-b043a484df01.m4a','audio/x-m4a',17340541,NULL,'2025-12-01 18:56:13'),(76,61,1,'_⁨داده کاوی⁩.m4a','./uploads/134a7177-37e9-4137-a727-415a62c4c8fb.m4a','audio/x-m4a',17340541,NULL,'2025-12-01 19:04:56'),(77,62,1,'_⁨داده کاوی⁩.m4a','./uploads/70cd3b0e-17a6-4ff4-8177-768712239f8e.m4a','audio/x-m4a',17340541,NULL,'2025-12-01 19:06:17'),(78,63,1,'_⁨داده کاوی⁩.m4a','./uploads/247967e6-e04f-4d16-b4de-fb40dfac1851.m4a','audio/x-m4a',17340541,NULL,'2025-12-01 19:11:20'),(79,64,1,'_⁨داده کاوی⁩.m4a','./uploads/ebb72584-2fe4-4484-8eea-56cecc9990c0.m4a','audio/x-m4a',17340541,NULL,'2025-12-02 08:34:24'),(80,65,1,'_⁨داده کاوی⁩.m4a','./uploads/cf17203e-5ae7-4429-9281-d0ed493e6a3a.m4a','audio/x-m4a',17340541,NULL,'2025-12-02 08:35:00'),(81,66,1,'_⁨داده کاوی⁩.m4a','./uploads/6b017460-49a0-41c6-99b4-df3d27de2c1f.m4a','audio/x-m4a',17340541,NULL,'2025-12-02 08:58:08'),(82,67,1,'_⁨داده کاوی⁩.m4a','./uploads/fac525c6-2fb4-4128-93da-a3ee79175b0d.m4a','audio/x-m4a',17340541,NULL,'2025-12-02 20:00:08'),(83,68,1,'_⁨داده کاوی⁩.m4a','./uploads/9769d09a-8027-4b08-a485-4dce55edec9b.m4a','audio/x-m4a',17340541,NULL,'2025-12-02 20:21:17'),(84,68,1,'photo_2025-11-29_15-19-56.jpg','./uploads/94c5ac8e-2621-406d-bb41-d104ed471536.jpg','image/jpeg',22715,NULL,'2025-12-02 20:21:18'),(85,69,1,'_⁨داده کاوی⁩.m4a','./uploads/30634f62-8afe-4602-8357-78fc09b247b0.m4a','audio/x-m4a',17340541,NULL,'2025-12-02 20:46:27'),(86,70,1,'_⁨امنیت ۵اذر-۱⁩.m4a','./uploads/bb9d989d-88f4-4dc5-aa95-8b564e830f13.m4a','audio/x-m4a',14959922,NULL,'2025-12-03 04:08:48'),(87,71,1,'_⁨داده کاوی⁩.m4a','./uploads/d210d672-0d25-4136-a198-bd5c8f29ca5a.m4a','audio/x-m4a',17340541,NULL,'2025-12-03 07:13:28'),(88,72,1,'_⁨اندروید-۹اذر⁩.m4a','./uploads/306f09e1-a1c4-4d55-9abb-8510a8d96444.m4a','audio/x-m4a',13152310,NULL,'2025-12-06 19:19:38'),(89,73,1,'_⁨سیار⁩.m4a','./uploads/1b3d5b63-7dcf-4d6e-b9c9-7da731bbf53a.m4a','audio/x-m4a',9284215,NULL,'2025-12-06 19:22:48');
/*!40000 ALTER TABLE `uploads` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `user_otps`
--

DROP TABLE IF EXISTS `user_otps`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `user_otps` (
  `id` int unsigned NOT NULL AUTO_INCREMENT,
  `user_id` int unsigned NOT NULL,
  `otp_code` varchar(6) COLLATE utf8mb4_unicode_ci NOT NULL,
  `expires_at` timestamp NOT NULL,
  `is_used` tinyint(1) NOT NULL DEFAULT '0',
  `created_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  KEY `idx_user_otp` (`user_id`,`otp_code`,`is_used`),
  CONSTRAINT `user_otps_ibfk_1` FOREIGN KEY (`user_id`) REFERENCES `users` (`id`) ON DELETE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=79 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `user_otps`
--

LOCK TABLES `user_otps` WRITE;
/*!40000 ALTER TABLE `user_otps` DISABLE KEYS */;
INSERT INTO `user_otps` VALUES (1,1,'524312','2025-10-10 15:41:45',1,'2025-10-10 19:06:44'),(2,1,'672636','2025-10-10 15:42:01',1,'2025-10-10 19:07:01'),(3,1,'898062','2025-10-10 15:46:01',1,'2025-10-10 19:11:00'),(4,1,'712318','2025-10-10 15:57:55',1,'2025-10-10 19:22:55'),(5,1,'082902','2025-10-10 16:00:06',1,'2025-10-10 19:25:05'),(6,1,'358490','2025-10-10 16:01:50',1,'2025-10-10 19:26:50'),(7,1,'633149','2025-10-10 16:06:47',1,'2025-10-10 19:31:46'),(8,1,'358240','2025-10-10 16:09:27',1,'2025-10-10 19:34:26'),(9,1,'868388','2025-10-10 16:11:22',1,'2025-10-10 19:36:22'),(10,1,'253442','2025-10-10 16:15:27',1,'2025-10-10 19:40:26'),(11,1,'466105','2025-10-10 16:16:17',1,'2025-10-10 19:41:16'),(12,1,'209153','2025-10-10 16:18:40',1,'2025-10-10 19:43:40'),(13,1,'344132','2025-10-10 16:20:11',1,'2025-10-10 19:45:10'),(14,1,'713396','2025-10-10 16:27:15',1,'2025-10-10 19:52:15'),(15,1,'368659','2025-10-10 16:31:48',1,'2025-10-10 19:56:48'),(16,1,'555555','2025-10-10 18:50:23',1,'2025-10-10 22:15:22'),(17,1,'762737','2025-10-10 19:13:39',1,'2025-10-10 22:38:38'),(18,1,'330369','2025-10-10 19:46:01',1,'2025-10-10 23:11:01'),(19,1,'908661','2025-10-10 20:16:26',1,'2025-10-10 23:41:25'),(20,1,'097227','2025-10-10 20:47:29',1,'2025-10-11 00:12:28'),(21,1,'173727','2025-10-10 21:15:59',1,'2025-10-11 00:40:58'),(22,1,'448342','2025-10-11 05:33:45',1,'2025-10-11 08:58:45'),(23,1,'330914','2025-10-11 05:37:44',1,'2025-10-11 09:02:44'),(24,1,'996039','2025-10-11 06:08:13',1,'2025-10-11 09:33:12'),(25,1,'856000','2025-10-11 08:51:10',1,'2025-10-11 12:16:09'),(26,1,'430385','2025-10-11 09:24:58',1,'2025-10-11 12:49:58'),(27,1,'021614','2025-10-11 10:09:58',1,'2025-10-11 13:34:58'),(28,1,'758622','2025-10-12 05:26:47',1,'2025-10-12 08:51:46'),(29,1,'190760','2025-10-12 10:33:33',1,'2025-10-12 13:58:32'),(30,1,'504533','2025-10-12 11:09:56',1,'2025-10-12 14:34:56'),(31,1,'529065','2025-10-12 11:43:13',1,'2025-10-12 15:08:13'),(32,1,'688546','2025-10-12 12:14:32',1,'2025-10-12 15:39:32'),(33,1,'395136','2025-10-12 12:44:55',1,'2025-10-12 16:09:54'),(34,1,'821293','2025-10-12 13:45:07',1,'2025-10-12 17:10:07'),(35,1,'765367','2025-10-13 06:40:28',1,'2025-10-13 10:05:28'),(36,1,'044001','2025-10-13 07:31:23',1,'2025-10-13 10:56:23'),(37,1,'904254','2025-10-14 04:42:26',1,'2025-10-14 08:07:25'),(38,1,'267980','2025-10-19 05:00:59',1,'2025-10-19 08:25:59'),(39,1,'923705','2025-10-26 04:29:24',1,'2025-10-26 07:54:23'),(40,1,'268684','2025-10-26 05:07:58',1,'2025-10-26 08:32:57'),(41,1,'088470','2025-10-26 05:59:24',1,'2025-10-26 09:24:23'),(42,1,'442945','2025-10-26 12:42:15',1,'2025-10-26 16:07:14'),(43,1,'889973','2025-10-26 13:18:26',1,'2025-10-26 16:43:26'),(44,1,'076930','2025-10-26 13:49:20',1,'2025-10-26 17:14:19'),(45,1,'966153','2025-10-29 00:21:26',1,'2025-10-29 03:46:25'),(46,1,'996286','2025-11-02 04:03:03',1,'2025-11-02 07:28:02'),(47,1,'712474','2025-11-02 04:37:06',0,'2025-11-02 08:02:05'),(48,1,'803939','2025-11-02 04:37:20',1,'2025-11-02 08:02:19'),(49,1,'305437','2025-11-04 05:24:42',0,'2025-11-04 08:49:42'),(50,1,'564190','2025-11-04 05:25:12',1,'2025-11-04 08:50:12'),(51,1,'990368','2025-11-09 02:13:40',1,'2025-11-09 05:38:40'),(52,1,'315256','2025-11-09 02:44:18',1,'2025-11-09 06:09:18'),(53,1,'830092','2025-11-09 03:10:59',0,'2025-11-09 06:35:58'),(54,1,'013754','2025-11-09 03:11:13',0,'2025-11-09 06:36:12'),(55,1,'390495','2025-11-09 03:12:08',0,'2025-11-09 06:37:08'),(56,1,'107320','2025-11-09 03:12:30',1,'2025-11-09 06:37:30'),(57,1,'661548','2025-11-09 03:18:12',1,'2025-11-09 06:43:12'),(58,1,'856774','2025-11-09 03:53:39',1,'2025-11-09 07:18:39'),(59,1,'201909','2025-11-09 04:24:39',1,'2025-11-09 07:49:39'),(60,1,'836427','2025-11-09 04:55:26',1,'2025-11-09 08:20:26'),(61,1,'465151','2025-11-15 11:54:06',1,'2025-11-15 15:19:06'),(62,1,'225975','2025-12-01 15:16:17',1,'2025-12-01 18:41:17'),(63,1,'127172','2025-12-01 15:50:45',1,'2025-12-01 19:15:44'),(64,2,'695252','2025-12-01 16:25:17',1,'2025-12-01 19:50:16'),(65,1,'852306','2025-12-01 16:26:02',1,'2025-12-01 19:51:01'),(66,1,'767655','2025-12-01 17:51:03',1,'2025-12-01 21:16:03'),(67,1,'011832','2025-12-01 18:22:47',1,'2025-12-01 21:47:47'),(68,1,'198619','2025-12-02 04:58:15',1,'2025-12-02 08:23:14'),(69,1,'849512','2025-12-02 05:32:15',1,'2025-12-02 08:57:15'),(70,1,'203508','2025-12-02 16:34:50',1,'2025-12-02 19:59:49'),(71,1,'238417','2025-12-02 17:05:22',1,'2025-12-02 20:30:21'),(72,1,'282980','2025-12-03 00:42:55',1,'2025-12-03 04:07:54'),(73,1,'210230','2025-12-03 03:41:41',1,'2025-12-03 07:06:40'),(74,1,'838329','2025-12-03 03:46:55',1,'2025-12-03 07:11:54'),(75,3,'824665','2025-12-03 03:49:42',0,'2025-12-03 07:14:42'),(76,1,'392950','2025-12-06 15:48:14',1,'2025-12-06 19:13:14'),(77,1,'389301','2025-12-06 17:02:44',1,'2025-12-06 20:27:44'),(78,1,'021602','2025-12-07 12:33:22',1,'2025-12-07 15:58:22');
/*!40000 ALTER TABLE `user_otps` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `user_quotas`
--

DROP TABLE IF EXISTS `user_quotas`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `user_quotas` (
  `id` int NOT NULL AUTO_INCREMENT,
  `user_id` int unsigned NOT NULL,
  `daily_upload_count` int NOT NULL DEFAULT '0',
  `last_upload_at` timestamp NULL DEFAULT NULL,
  `concurrent_processing` smallint NOT NULL DEFAULT '0',
  `total_minutes_used_today` decimal(10,2) NOT NULL DEFAULT '0.00',
  `last_reset_at` date DEFAULT (curdate()),
  PRIMARY KEY (`id`),
  UNIQUE KEY `user_id` (`user_id`),
  KEY `idx_user` (`user_id`),
  KEY `idx_last_reset` (`last_reset_at`),
  CONSTRAINT `user_quotas_ibfk_1` FOREIGN KEY (`user_id`) REFERENCES `users` (`id`) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='User rate limiting and quotas';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `user_quotas`
--

LOCK TABLES `user_quotas` WRITE;
/*!40000 ALTER TABLE `user_quotas` DISABLE KEYS */;
/*!40000 ALTER TABLE `user_quotas` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `user_subscriptions`
--

DROP TABLE IF EXISTS `user_subscriptions`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `user_subscriptions` (
  `id` int unsigned NOT NULL AUTO_INCREMENT,
  `user_id` int unsigned NOT NULL,
  `plan_id` smallint unsigned NOT NULL,
  `start_date` timestamp NOT NULL,
  `end_date` timestamp NOT NULL,
  `minutes_consumed` int unsigned NOT NULL DEFAULT '0',
  `status` enum('active','expired','cancelled') COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT 'active',
  PRIMARY KEY (`id`),
  KEY `plan_id` (`plan_id`),
  KEY `idx_user_status` (`user_id`,`status`,`end_date`),
  CONSTRAINT `user_subscriptions_ibfk_1` FOREIGN KEY (`user_id`) REFERENCES `users` (`id`) ON DELETE CASCADE,
  CONSTRAINT `user_subscriptions_ibfk_2` FOREIGN KEY (`plan_id`) REFERENCES `plans` (`id`) ON DELETE RESTRICT
) ENGINE=InnoDB AUTO_INCREMENT=15 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `user_subscriptions`
--

LOCK TABLES `user_subscriptions` WRITE;
/*!40000 ALTER TABLE `user_subscriptions` DISABLE KEYS */;
INSERT INTO `user_subscriptions` VALUES (5,1,3,'2025-10-10 20:06:34','2025-11-10 03:30:35',1000,'active'),(12,1,2,'2025-11-09 03:30:35','2025-12-09 03:30:35',300,'active'),(13,1,1,'2025-12-02 17:15:10','2026-01-01 17:15:10',30,'active'),(14,1,2,'2025-12-06 15:52:36','2026-01-05 15:52:36',11,'active');
/*!40000 ALTER TABLE `user_subscriptions` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `users`
--

DROP TABLE IF EXISTS `users`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `users` (
  `id` int unsigned NOT NULL AUTO_INCREMENT,
  `phone_number` varchar(20) COLLATE utf8mb4_unicode_ci NOT NULL,
  `email` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `full_name` varchar(100) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `university` varchar(100) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `field_of_study` varchar(100) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `created_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `updated_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  UNIQUE KEY `phone_number` (`phone_number`),
  UNIQUE KEY `email` (`email`),
  KEY `idx_phone` (`phone_number`)
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `users`
--

LOCK TABLES `users` WRITE;
/*!40000 ALTER TABLE `users` DISABLE KEYS */;
INSERT INTO `users` VALUES (1,'09357895642',NULL,'لیلی حسینی','الزهرا','','2025-10-10 19:06:44','2025-11-09 08:12:42'),(2,'09357895695',NULL,'','','','2025-12-01 19:50:16','2025-12-01 19:50:49'),(3,'0123456789',NULL,NULL,NULL,NULL,'2025-12-03 07:14:42','2025-12-03 07:14:42');
/*!40000 ALTER TABLE `users` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2025-12-07 19:49:12
